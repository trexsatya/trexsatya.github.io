{"name":"Java Declarative and Functional Programming","id":68,"content":"<h2>Why Functional Programming could be better?</h2>\n\n<p>What is Functional Programming? - In simple words, it is a way of writing programs in which you treat your program as a set of <s>mathematical</s>&nbsp;pure <strong>functions</strong>. Functions are first class citizens, they can be created, stored, passed around, composed, partially applied.</p>\n\n<p>To describe the benefits we first have to criticize other paradigms especially &#39;Object-Oriented Programming&#39;</p>\n\n<p>......</p>\n\n<p>Now, the benefits of functional programming.</p>\n\n<p>FP enforces some ideas that are helpful in reducing bugs (unexpected scenarios). The ideas enforced are these.</p>\n\n<ol>\n\t<li>(Apparently) No Side-Effects: Pure functions do not allow side-effects. You cannot change a global state&nbsp;or state of an object.</li>\n\t<li>Immutability: You cannot change an object after creation.</li>\n\t<li>Easy to convert into asynchronous/multithreaded context with very little to worry about null-safety. You can handle a piece of computation asynchronously leaving other parts untouched.</li>\n\t<li>Approaching a solution is more natural.</li>\n\t<li>Code Clarity: You see a highly reduced number of if-else, try-catch, switch, break, continue things which make code unreadable. Instead, you get a clear picture of what is supposed to happen in this code.</li>\n</ol>\n\n<p>Compared to the imperative style of programming, <strong><em>&quot;You do not tell how to do things, rather what you want&quot;</em></strong>. Of course, ultimately the computer needs to be told how to do things, but the point is that we have battle-tested libraries for that. You should just enjoy the benefit of that.</p>\n\n<h2>What Do You Need For Functional Programming?</h2>\n\n<ol>\n\t<li>You need the ability to create Immutable Objects, Immutable Data Structures.</li>\n\t<li>You need the ability to store functions, pass them around as parameter to other functions, compose them, curry them.</li>\n\t<li>You need Monads. They encapsulate some typical situations and way of handling them. E.g. Optional&lt;T&gt; encapsulates a situation that a value may be present or not, and it gives the functionality to use the value if present, get value from somewhere else if not present, etc.</li>\n</ol>\n\n<h2>Functional Programming&nbsp;Using Vavr</h2>\n\n<p>Vavr offers immutable collections, monads like Option&lt;T&gt;, Try&lt;T&gt;, Either&lt;L, R&gt;. Along with these monads, Vavr offers many useful methods which operate on collections.</p>\n\n<p>&nbsp;</p>\n\n<h2>Examples of FP:</h2>\n\n<p>&nbsp;</p>\n\n<h3><span style=\"\">Counting character frequency of a string</span><br />\n&nbsp;</h3>\n\n<pre>\n<code class=\"language-java\">Map&lt;String, Long&gt; collect = Arrays.stream(\"This is the string given\".split(\"\"))\n                            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n\n//In Groovy:\n//\"This is the string given\".split(\"\").countBy{it}</code></pre>\n\n<h3><br />\n<span style=\"\">Finding Prime Numbers&nbsp;</span></h3>\n\n<p>Pseudocode: number N is prime if&nbsp;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in the range from 2 to number, no number divides N<br />\nDeclarative Code in Java:</p>\n\n<pre>\n<code class=\"language-java\">boolean Â  isPrime = range(2,N).noneMatch( n =&gt; N%n == 0)</code></pre>\n\n<h3><br />\n<span>Split a list by some special element</span><br />\n&nbsp;</h3>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; list = Arrays.asList(\"1\",\"2\",\"3\",\"#\",\"4\",\"5\", \"#\",\"6\",\"7\",\"8\",\"9\");\n\nPredicate&lt;String&gt; predicate = t -&gt; t.equals(\"#\");\n\nint[] edges = IntStream.range(-1, list.size()+1)\n                .filter(i -&gt; i == -1 || predicate.test( list.get(i)) || i == list.size() )\n                .toArray();\n\nList&lt;List&lt;String&gt;&gt; collect = IntStream.range(0, edges.length - 1)\n                .mapToObj(k -&gt; list.subList(edges[k] + 1, edges[k + 1]))\n                .collect(Collectors.toList());\n\nSystem.out.println(collect);</code></pre>\n","authorId":null,"subject":"linked-to-143","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:22.950+0000"}