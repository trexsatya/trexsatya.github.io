{"name":"Serialization and Deserialisation","id":90,"content":"<p>When you create objects, they reside in the&nbsp;Main Memory of computer. But sometimes you may want to store them on disks, or maybe transfer over a&nbsp;network to other computer systems.</p>\n\n<p>For example, you have a&nbsp;Game&nbsp;object in a game, you might want to save it to disk, when the game is paused, so that later that Game&nbsp;object could start right from where it left off OR you might want to send the whole game object to another computer machine, so that it can run there same as it is running here.</p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">What is Serialization?</span></h2>\n\n<p>Simply, it is the process of writing objects in the form of &quot;bytes&quot;. Of course, there has to be a defined format for laying out the bytes. And there are certain rules about how serialisation is done in Java.</p>\n\n<p>If you are thinking&nbsp;&quot;why not just store all the information related to a&nbsp;Game object in a file as text?&quot;&nbsp;In answer to that, it is possible, but the thing is that storing as the&nbsp;string will consume more memory space and while converting it to Game object again, it will require more processing.</p>\n\n<p><span style=\"font-family:Comic Sans MS,cursive;\">Notice: Serialisation in Java is more complicated than it has to be.</span></p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">How do I convert an&nbsp;object into a&nbsp;byte sequence?</span></h2>\n\n<p>You don&#39;t have to do it by yourself. There is a class in Java language, that does this: <code>ObjectOutputStream</code></p>\n\n<p><code>ObjectOutputStream </code>needs an <code>OutputStream </code>where it can write the bytes produced.</p>\n\n<pre>\n<code class=\"language-java\">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(filename)); \n              \n// Method for serialization of object \nout.writeObject(object); \n\n//There's ObjectInputStream to read object.</code></pre>\n\n<h2><br />\n<span style=\"font-family:Arial,Helvetica,sans-serif;\">Can I serialize any object of any class?</span></h2>\n\n<p>NO. You have to tell Java that this class can be serialized by implementing <code>Serializable</code> interface on class. Might be to your surprise that this interface does not have any method which you need to implement. It just marks the class as serializable.</p>\n\n<p>Will all the fields of the&nbsp;class be serialized?</p>\n\n<p>No, only the live state related to the&nbsp;object will be serialized. Remember static fields are not considered to be part of the state, so they will not be serialized. If there is a&nbsp;reference to another object in the object you are serializing, then that object&#39;s class must be implementing Serializable interface in order to be serializable, otherwise, an error will be thrown. If you do not want that object to be serialized and also no error should throw, then mark its reference as &quot;<strong>transient&quot;</strong>.</p>\n\n<p>If a class is marked <code>Serializable</code>, all its subclasses will also be serialisable. To prevent this from happening, you will have to implement <code>readObject()</code> and <code>writeObject()</code> methods and throw an&nbsp;exception from there.</p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">What if I serialize an object of a class, and then change the class structure </span><span style=\"font-family:Arial,Helvetica,sans-serif;\">itself?</span></h2>\n\n<p>Java automatically calculates an ID for object&#39;s class by generating a hash from about everything in the&nbsp;given source file ( method names, field names, field types, access modifiers, &nbsp;etc), when it serializes an object. You can also provide this ID, by declaring <em><strong>serialVersionUID</strong></em>&nbsp;static field in class. When deserialising a saved object, it compares the ID&#39;s of stored object and calculated/retrieved from class, if they do not match Java throws an exception.&nbsp;</p>\n\n<p>You can use <strong>serialver</strong> command ( which is supplied with JDK) to find out what was the serial version UID used to store the object.&nbsp;</p>\n\n<p>When you refactor, you should use that command to find the serial version uid and use it in the refactored code. If you are writing the class for the first time, or the class has not been used in the&nbsp;serialization process before, you can provide any value for serialVersionUID, it doesn&#39;t matter.</p>\n\n<p>Serialization mechanism doesn&#39;t mind these refactorings:</p>\n\n<ul>\n\t<li>Adding new fields to a class</li>\n\t<li>Changing the fields from static to nonstatic</li>\n\t<li>Changing the fields from transient to nontransient<br />\n\t(All these operations can be accommodated by expanding the memory layout structure, however, the opposite of them will corrupt the memory layout, and the&nbsp;compiler would not be able to figure out how to accommodate those changes).</li>\n</ul>\n\n<p>&nbsp; &nbsp; &nbsp;The other way round does affect it, and then you have to use serialVersionUID.</p>\n\n<p>Read the <a href=\"https://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/version.html#6678\" target=\"_blank\">Oracle guide</a>.</p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">But doesn&#39;t object stored in byte format reveal private field values, is it secure?</span></h2>\n\n<p><span style=\"\"><span style=\"color:#660099;\">Yes, indeed it is not secure, because while you are sending serialized object on </span></span><span style=\"color:#660099;\"><span style=\"font-family:Arial,Helvetica,sans-serif;\">network</span><span style=\"font-family:Arial,Helvetica,sans-serif;\">,</span></span><span style=\"\"><span style=\"color:#660099;\"> if someone is able to intercept it, he/she can see the whole data even private ones.</span></span></p>\n\n<p><span style=\"\">The Solution is there: you can add a</span><span style=\"color:#660099;\"><span style=\"\"> <code>writeObject</code></span><code><span style=\"\">(</span></code></span><code>java.io.ObjectOutputStream stream<span style=\"color:#660099;\"><span style=\"\">)</span></span></code><span style=\"\"><code>{ .. }</code> method in your class which encrypts the data before serialising</span><span style=\"color:#660099;\"><span style=\"\">.</span></span>&nbsp;Also <code>readObject(java.io.ObjectInputStream stream){ .. }</code> to unencrypt it later while deserialising.</p>\n\n<p>Read this <a href=\"https://docs.oracle.com/javase/9/docs/api/java/io/Serializable.html\" target=\"_blank\">JavaDoc</a>. It&#39;s very clear and concise.</p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">What if I don&#39;t want to store the whole object, only a minor part of it?</span></h2>\n\n<p>You could mark the fields&nbsp;<em>transient</em>, but the class would still have to explicitly produce code to check whether a field was initialized every time a method accessed it.</p>\n\n<p>So there&#39;s a better way.</p>\n\n<p><code>writeReplace</code>&nbsp;and&nbsp;<code>readResolve</code>&nbsp;methods.</p>\n\n<p>When these methods are implemented, the objects returned/received will be used instead of the object we are serialising.</p>\n\n<p>The&nbsp;<code>readResolve</code>&nbsp;method is called when&nbsp;<code>ObjectInputStream</code>&nbsp;has read an object from the stream and is preparing to return it to the caller.&nbsp;<code>ObjectInputStream</code>&nbsp;checks whether the class of the object defines the&nbsp;<code>readResolve</code>&nbsp;method. If the method is defined, the&nbsp;<code>readResolve</code>&nbsp;method is called to allow the object in the stream to designate the object to be returned. The object returned should be of a type that is compatible with all uses. If it is not compatible, a&nbsp;<code>ClassCastException</code>&nbsp;will be thrown when the type mismatch is discovered.</p>\n\n<p>The use-cases for using this are: when implementing the&nbsp;singleton pattern, you don&#39;t want another object as a result of deserialization. When you want to plug-in some computation of the transient state in the object e.g. recreating a cache after deserialization.</p>\n\n<h2>Can I have full control over Serialization process?</h2>\n\n<p>Yes, using&nbsp;the&nbsp;<code>java.io.Externalizable</code>&nbsp;interface, but then you need to be more careful when refactoring your class.&nbsp;The Externalizable interface extends the Serializable interface and adds two methods, writeExternal() and readExternal(). These are automatically called while serialization or deserialization.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://stackoverflow.com/questions/817853/what-is-the-difference-between-serializable-and-externalizable-in-java\" target=\"_blank\">https://stackoverflow.com/questions/817853/what-is-the-difference-between-serializable-and-externalizable-in-java</a></p>\n\n<p><code>Serializable</code>&nbsp;uses reflection to construct object and does not require no arg constructor. But&nbsp;<code>Externalizable</code>&nbsp;demands public no-arg constructor.</p>\n\n<p>If you implement&nbsp;<code>Externalizable</code>, it&#39;s your responsibility to serialize&nbsp;<code>super</code>&nbsp;class.&nbsp;</p>\n\n<p>Using&nbsp;<code>Externalizable</code>&nbsp;might be faster, but you shouldn&#39;t opt for this performance prematurely as a rule of thumb.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://stackoverflow.com/questions/888335/why-generate-long-serialversionuid-instead-of-a-simple-1l\" target=\"_blank\">https://stackoverflow.com/questions/888335/why-generate-long-serialversionuid-instead-of-a-simple-1l</a></p>\n\n<p>Summary: You can use 1L. Just remember to update it whenever you change the class structure in a way that affects serialization. Generating using serialver tool or using IDE just makes sure that it will make it compatible with previous releases.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/605828/does-it-matter-what-i-choose-for-serialversionuid-when-extending-serializable-cla/605832#605832\" target=\"_blank\">https://stackoverflow.com/questions/605828/does-it-matter-what-i-choose-for-serialversionuid-when-extending-serializable-cla/605832#605832</a></p>\n\n<p>Summary: No, it doesn&#39;t just make sure you update it whenever you make breaking changes to class structure.</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-38","tags":["medium"],"img":"/images/serialization.gif","summary":"How do you save live objects and later restore them?","lastUpdated":"2018-07-01T13:59:23.637+0000"}