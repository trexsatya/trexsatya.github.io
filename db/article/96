{"name":"Better Unit Tests","id":96,"content":"<p>A very common argument against writing unit tests is that &quot;Tests are yet another liability&quot;</p>\n\n<p>What&#39;s the solution then? - Simple, write tests in such a way that they are not liability, they should be perfectly clear, concise, to-the-point, test one thing only and test everything about the unit. Also, write them responsibly. <em>Not writing tests is not the solution.</em></p>\n\n<p>Unit Tests can also tell you how good (readable, maintainable) your code is. It will be difficult for you to write unit tests if your code is not flexible, extendable, maintainable.</p>\n\n<p>In Java JUnit is the most widely used framework for writing unit tests.</p>\n\n<p>With version 5, JUnit is now more advanced, a bit different from earlier versions.</p>\n\n<p>&nbsp;</p>\n\n<h2>Composing and Grouping Tests</h2>\n\n<p>When you write a lot of tests, you should categorize them, group them based on different dimensions. E.g. Slow Tests, Fast Tests etc. You can use custom annotations e.g.</p>\n\n<pre>\n<code class=\"language-java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Tag(\"fast\")\n@Test\npublic @interface FastTest {\n}\n\n@FastTest\nvoid myFastTest() {\n    // ...\n}</code></pre>\n\n<p>You can use <code data-lang=\"java\"><span class=\"annotation\">@DisplayName</span></code> to change the names of test (on both test class and test methods) in reports.</p>\n\n<pre>\n<code class=\"language-java\">class DisplayNameGeneratorDemo {\n\n    @Nested\n    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)\n    class A_year_is_not_supported {\n\n        @Test\n        void if_it_is_zero() {\n        }\n\n        @DisplayName(\"A negative value for year is not supported by the leap year computation.\")\n        @ParameterizedTest(name = \"For example, year {0} is not supported.\")\n        @ValueSource(ints = { -1, -4 })\n        void if_it_is_negative(int year) {\n        }\n\n    }\n\n    @Nested\n    @DisplayNameGeneration(IndicativeSentences.class)\n    class A_year_is_a_leap_year {\n\n        @Test\n        void if_it_is_divisible_by_4_but_not_by_100() {\n        }\n\n        @ParameterizedTest(name = \"Year {0} is a leap year.\")\n        @ValueSource(ints = { 2016, 2020, 2048 })\n        void if_it_is_one_of_the_following_years(int year) {\n        }\n\n    }\n\n    static class IndicativeSentences extends DisplayNameGenerator.ReplaceUnderscores {\n\n        @Override\n        public String generateDisplayNameForClass(Class&lt;?&gt; testClass) {\n            return super.generateDisplayNameForClass(testClass);\n        }\n\n        @Override\n        public String generateDisplayNameForNestedClass(Class&lt;?&gt; nestedClass) {\n            return super.generateDisplayNameForNestedClass(nestedClass) + \"...\";\n        }\n\n        @Override\n        public String generateDisplayNameForMethod(Class&lt;?&gt; testClass, Method testMethod) {\n            String name = testClass.getSimpleName() + ' ' + testMethod.getName();\n            return name.replace('_', ' ') + '.';\n        }\n\n    }\n\n}</code></pre>\n\n<p>You can use <code data-lang=\"java\"><span class=\"annotation\">@TestMethodOrder</span>(OrderAnnotation.class) </code>to enforce order of execution of tests. &nbsp;</p>\n\n<p>Your tests can use some of the model values that JUnit injects in your test class constructor and test methods if you declare them e.g.</p>\n\n<pre>\n<code class=\"language-java\">    @Test\n    void reportSingleValue(TestInfo testInfo, TestReporter testReporter) {\n        testReporter.publishEntry(\"a status message\");\n    }</code></pre>\n\n<p>You can use custom implementation of parameter resolvers to inject values.</p>\n\n<p>e.g.</p>\n\n<pre>\n<code class=\"language-java\">public class RandomParametersExtension implements ParameterResolver {\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.PARAMETER)\n\tpublic @interface Random {\n\t}\n\n\t@Override\n\tpublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn parameterContext.isAnnotated(Random.class);\n\t}\n\n\t@Override\n\tpublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {\n\t\treturn getRandomValue(parameterContext.getParameter(), extensionContext);\n\t}\n\n\tprivate Object getRandomValue(Parameter parameter, ExtensionContext extensionContext) {\n\t\tClass&lt;?&gt; type = parameter.getType();\n\t\tjava.util.Random random = extensionContext.getRoot().getStore(Namespace.GLOBAL)//\n\t\t\t\t.getOrComputeIfAbsent(java.util.Random.class);\n\t\tif (int.class.equals(type)) {\n\t\t\treturn random.nextInt();\n\t\t}\n\t\tif (double.class.equals(type)) {\n\t\t\treturn random.nextDouble();\n\t\t}\n\t\tthrow new ParameterResolutionException(\"No random generator implemented for \" + type);\n\t}\n\n}\n\n\n@ExtendWith(RandomParametersExtension.class)\nclass MyRandomParametersTest {\n\n    @Test\n    void injectsInteger(@Random int i, @Random int j) {\n        assertNotEquals(i, j);\n    }\n\n    @Test\n    void injectsDouble(@Random double d) {\n        assertEquals(0.0, d, 1.0);\n    }\n\n}</code></pre>\n\n<p>You can write tests inside interfaes also and make test classes implement them. This gives a feeling of writing contracts.</p>\n\n<p>&nbsp;</p>\n\n<h2>Fluent Code In Tests</h2>\n\n<p>Use Builder pattern to create objects. Use libraries like <a href=\"https://joel-costigliola.github.io/assertj/\">AssertJ</a>, <a href=\"https://hamcrest.org/JavaHamcrest/\">Hamcrest</a>, <a href=\"https://google.github.io/truth/\">Truth</a>, etc.</p>\n\n<p>&nbsp;</p>\n\n<h2>Property Based Testing</h2>\n\n<p>With ParameterResolvers and <code data-lang=\"java\"><span class=\"annotation\">@ParameterizedTest</span></code> you can implement PBT in Java easily. PBT basically means running your test over entire domain of possible inputs.</p>\n\n<pre>\n<code class=\"language-java\">@ParameterizedTest\n@MethodSource(\"stringProvider\") //Jupiter will search for method named testWithExplicitLocalMethodSource that returns String if you do not provide method name with annotation\nvoid testWithExplicitLocalMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream&lt;String&gt; stringProvider() {\n    return Stream.of(\"apple\", \"banana\");\n}\n\n@ParameterizedTest(name = \"{index} ==&gt; str=''{0}'', num={1}\")\n@MethodSource(\"stringIntAndListProvider\")\nvoid testWithMultiArgMethodSource(String str, int num, List&lt;String&gt; list) {\n    assertEquals(5, str.length());\n    assertTrue(num &gt;=1 &amp;&amp; num &lt;=2);\n    assertEquals(2, list.size());\n}\n\nstatic Stream&lt;Arguments&gt; stringIntAndListProvider() {\n    return Stream.of(\n        arguments(\"apple\", 1, Arrays.asList(\"a\", \"b\")),\n        arguments(\"lemon\", 2, Arrays.asList(\"x\", \"y\"))\n    );\n}</code></pre>\n\n<p>&nbsp;If your list of arguments in test methods grows ; you can use ArgumentsAccessor instead.</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-143","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:24.217+0000"}