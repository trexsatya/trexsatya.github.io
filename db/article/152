{"name": "Thread Safety In Java", "id": 152, "content": "<p><strong>NOTE:&nbsp;</strong><em>TO KNOW (MORE) DETAIL ABOUT ANY&nbsp;THING PRESENTED HERE, READ THE BOOK &quot;CONCURRENT PROGRAMMING IN JAVA -by Doug Lee&quot;&nbsp;</em></p>\n\n<p>Thread Safety in Java is quite a deep topic. A lot of situations need to be handled, when you are dealing with multiple threads and they are accessing some common resource(memory location for example).<br />\nWhen Writing multi-threaded programs SAFETY comes first, liveness, efficiency, reusability come later.</p>\n\n<p>Since many threads are accessing shared resource, it&#39;s easy for the state to become inconsistent. Examples of inconsistencies are:</p>\n\n<ul>\n\t<li>&nbsp; <span title=\"Its like you are writing on board, you turn around and someone else has access to board and overwrites it.You don't even come to know about this. This messes whole writing and calculations.\">Lost Update</span>: Meaning one thread makes updates the shared data, but the other thread does not read the correct value. The update is lost in between.</li>\n\t<li>&nbsp; Dirty Read: Meaning that one thread instructs the CPU to update value of data but it has not been updated completely and some other thread comes and reads the partially updated value. E.g. <code>long</code> takes 64 bits, and if you instruct a 32-bit CPU to increment it, it performs two this task in two 32-bit increment operations, and some thread can read the wrong value while only the half of the data/memory has been incremented.</li>\n</ul>\n\n<p>You have to prevent such inconsistencies.&nbsp;</p>\n\n<p>Then there are performance issues which need to be tackled. Context-Switching of threads is quite an overhead.</p>\n\n<p>Deadlock, Livelock, Stagnation, etc are issues related to performance while dealing with multiple threads.</p>\n\n<p>While doing object oriented analysis and modelling for concurrent environment, strive for these in order</p>\n\n<ol>\n\t<li>Immutability, or partial immutability if first not possible</li>\n\t<li>Locking</li>\n\t<li>State dependence (when there is no other way)</li>\n\t<li>Containment (hiding internal objects)</li>\n\t<li>Splitting (separate independent aspects of objects and locks)</li>\n</ol>\n\n<h2>LOCKING</h2>\n\n<p>Locking gives us capability of achieving Atomicity, but at cost of possibility for Deadlock, Livelock.</p>\n\n<pre>\n<code class=\"language-java\">//Simplest way of locking\nsynchronized Point position(){...}\n\n//Same thing, different way\nPoint position(){\n    synchronized(this){\n     //....\n    }   \n}\n\nsynchronized(getClass()) { /* body */ } //is dangerous, as it locks the actual class, which might be different from (a subclass of) the class defining the static fields that need protecting. \n\n//After synchronized keyword '{' means acquire lock, '}' means release lock. Can acquire and release locks many number of times. That's why these basic java locks are called Re-entrant lock.\n\n//synchronized works when all accesses (to shared resource) are synchronized, even getters.\n\n//Lock acquisition triggers reload of thread caches, lock release triggers flushing of them. Hence guaranteeing out inconsistencies.\n\nvolatile int someSharedNumber; //this causes re-loading/flushing of value on each access.\n\nvolatile Object someSharedObject; //volatile here is not useful, volatile reference means re-loading/flushing of reference only, not the referenced object.\n\n</code></pre>\n\n<p>Thread-Safe Traversals</p>\n\n<pre>\n<code class=\"language-java\">//Aggregate operation\nsynchronized void applyToAll(Procedure p) { .. } ///Full safety, but increased possibility of Liveness, and performance problems\n\n//Indexed Traversal\nfor (int i = 0; i &lt; v.size(); ++i) // Is unsafe; there might be interference of other threads between .size() call and .get(i) call\n System.out.println(v.get(i)); \n\nsynchronized(v){ for-loop } //Is safe, but same problems as Aggregate Operation\n\n//Snapshot Traversal\nsynchronized(v){ copy = makeCopy();}\nfor-loop on copy       //Full safety, but possibility of not seeing latest changes\n\n//Versioned, Fail-Fast iterators\n//Every modifying-operation changes version, and next() of iterator checks whether current version is changed or not, if changed then throws exception</code></pre>\n\n<p>There is no fool-proof, solid way to avoid deadlock. A simple way to minimize possibility is this:</p>\n\n<p>Resource-ordering based on hash-codes. Resource-Ordering can also be done by trying e.g <em>while ( !trySwap(a,b) &amp;&amp; ! trySwap(b,a)) sleep(10)</em>;</p>\n\n<pre>\n<code class=\"language-java\">class Cell {\n\t long value;\n\t void swapValue(Cell other) {\n\t\t\t if (other == this) return; // alias check\n\t\t\t Cell fst = this; // order via hash codes\n\t\t\t Cell snd = other;\n\t\t\t if (fst.hashCode() &gt; snd.hashCode()) {\n\t\t\t\t fst = other; snd = this;\n\t\t\t }\n\t\t\t synchronized(fst) {\n\t\t\t\t synchronized (snd) {\n\t\t\t\t long t = fst.value;\n\t\t\t\t fst.value = snd.value;\n\t\t\t\t snd.value = t;\n\t\t\t }\n\t\t }\n\t }\n}</code></pre>\n\n<p>Avoid calling some other (downstream) operation while holding lock. Otherwise, your thread-safety becomes dependent on external call.</p>\n\n<h2>JAVA MEMORY MODEL</h2>\n\n<p>Java Memory model is a specification for JVMs which define the execution-order semantics of program. (In sequential programs, i.e. your program is run by just one thread, program is run in program-order (even after re-arrangements made by smart compilers))</p>\n\n<p>Basically it says, you can view that every thread is run on a different CPU(although it is not true). And by that resemblance every thread has a working-memory (resembling to CPU&#39;s cache and register). Java Memory Model then specifies some rules (guarantees) related to interaction among these working-memories and Main-Memory</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Atomicity</strong></span>: rules which tell which instructions must have indivisible effecs: Reads/Writes of memory cells representing object fields (static/non-static both) (including array elements).</p>\n\n<p style=\"margin-left: 40px;\">Access and Updates to all memory cells corresponding to fields of objects are atomic (except for long, double, they may or may not be atomic depending on JVM implementation)<br />\nAccess and Updates to volatile long, volatile double are atomic.&nbsp;</p>\n\n<p style=\"margin-left: 40px;\">Note: Volatile keyword guarantees that you will be reading the most recent update. Atomicity itself does not guarantee that (it just says that you will be able to read/write all the bits of memory cell at once, without any intervention)</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Visibility</strong></span>: Rules which tell, under what conditions, a write by one thread will be visible to read by another thread.</p>\n\n<p style=\"margin-left: 40px;\">Write by one thread is visible to other thread only if first thread releases the lock (which causes flush of working-memory), and second thread acquires the SAME lock (which causes re-loading of working-memory from Main-Memory). (Locks essentially act as message passing construct, message that I want to send updates, or I want to read updates)</p>\n\n<p style=\"margin-left: 40px;\">Volatile keyword guarantees that you will be reading the most recent update.</p>\n\n<p style=\"margin-left: 40px;\">The first time a thread accesses a field, it either sees the initial value, or the&nbsp;most recent value assigned by any thread till that time.</p>\n\n<p style=\"margin-left: 40px;\">As a thread terminates, all updates are flushed to Main-Memroy, (hence .join() would also make the updates visisble to calling thread)</p>\n\n<p>Ordering: Rules which tell under what conditions, re-ordering of isntructions does not affect the final result.</p>\n\n<p style=\"margin-left: 40px;\">Basically all instructions inside synchronized block, will be in executed in program-order. (This also eliminates possibility of compiler optimizations)</p>\n\n<h2>HANDLING STATE DEPENDENCY</h2>\n\n<p>State Dependency (Check-Then-Act situations) can be handled in many ways:</p>\n\n<ol>\n\t<li>Ignore request if not in right state</li>\n\t<li><span style=\"color:#27ae60;\"><em>[BALKING]</em></span> Fail (throw exception) if not in right state (Vector class used this)</li>\n\t<li><span style=\"color:#27ae60;\"><em>[GUARDING]</em></span> Suspend until in right state</li>\n\t<li><span style=\"color:#27ae60;\"><em>[TRYING]</em></span> Proceed, check if succeeded; if not, roll back</li>\n\t<li><span style=\"color:#27ae60;\"><em>[RETRYING]&nbsp;</em></span>Keep trying until success</li>\n\t<li><span style=\"color:#27ae60;\"><em>[TIME-OUT]&nbsp;</em></span>Wait or retry for a while; then fail</li>\n\t<li><span style=\"color:#27ae60;\"><em>[PLANNING]&nbsp;</em></span>First initiate activity that will achieve right state</li>\n</ol>\n\n<pre>\n<code class=\"language-java\">//Options for GUARDING\n//Busy waits are not correct\n\n  while(!conditionIsTrue());\n\n//Suspension\n  while(!conditionIsTrue()) lock.wait();\n  //do your work i.e updates\n  lock.notifyAll();\n\n//wait(maybe timed), notify, notifyAll, interrupt methods are used to control Java object's inbuilt monitor system; Every Java object is a monitor and has a wait-queue\n//when a thread comes out of wait(timeoutValue), you do not get to know whether wait was over because someone notified or because time elapsed. You would have to calculate it by yourself.\n\n//notify causes one (any) of threads in wait set to try to re-acquire the lock (No guarantee of success in re-acquiring). There is a timed version too\n//Thread.interrupt() causes threads wait(),sleep(),join() to abort. It has same behavior as of notify, except, thread will be resumed at associated catch block.\n\n//To call notify/notifyAll thread must be holding the lock, otherwise IllegalMonitorStateException\n//Thread releases the synchronization lock after call of wait()</code></pre>\n\n<p>Timeout Policy is a middle ground between BALKING and&nbsp; GUARDING. It is used by BlockingQueue implementations.&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">class BoundedBuffer {\n    Object[] data_;\n    int putPtr_ = 0, takePtr_ = 0, size_ = 0;\n    BoundedBuffer(int capacity) {\n        data_ = new Object[capacity];\n    }\n    \n    protected void doPut(Object x){ // mechanics\n        data_[putPtr_] = x;\n        putPtr_ = (putPtr_ + 1) % data_.length;\n        ++size_;\n        notifyAll();\n    }\n\n    protected Object doTake() { // mechanics\n       //opposite of doTake\n    }\n\n    boolean isFull(){ return size_ == data_.length;}\n    boolean isEmpty(){ return size_ == 0; }\n\n    synchronized void put(Object x)throws InterruptedException {\n        while (isFull()) wait();\n        doPut(x);\n    }\n\n    synchronized Object take(){ throws InterruptedException \n        while (isEmpty()) wait();\n        return doTake();\n    }\n\n    synchronized boolean offer(Object x) {\n        if (isFull()) return false;\n        doPut(x);\n        return true;\n    }\n\n    synchronized Object poll() {\n        if (isEmpty()) return null;\n        return doTake();\n    }\n\n    synchronized boolean offer(Object x, long ms) {\n        if (isFull()) {\n            if (ms &lt;= 0) return false;\n            long start = System.currentTimeMillis();\n            long waitTime = ms;\n            for (; ; ) {\n                try {\n                    wait(waitTime);\n                } catch (InterruptedException e) {\n                    return false;\n                }\n                if (!isFull()) break;\n                long now = System.currentTimeMillis();\n                waitTime = ms - (now - start);\n                if (waitTime &lt;= 0) return false;\n            }\n        }\n        return doTake() != null;\n    }\n}\n\nsynchronized Object poll(long ms); // similar</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>Containment (Hiding Internal Details)</h2>\n\n<p>One way is to present Read-Only Adapter/View of mutable object to pass around threads.</p>\n\n<p>Copy-On-Write : Whenever you need to make any update to internal state, use create copy and update (under synchronization). CopyOnWrite collections are useful when client can do just fine with a snapshot. E.g. collection for holding reference to listeners. Fast-Traversal, Slow-Modification, Safe-Iterators</p>\n\n<pre>\n<code class=\"language-java\">class CopyOnWriteArrayList { // Incomplete\n    protected Object[] array = new Object[0];\n    protected synchronized Object[] getArray() { return array; }\n    public synchronized void add(Object element) {\n        int len = array.length;\n        Object[] newArray = new Object[len+1];\n        System.arraycopy(array, 0, newArray, 0, len);\n        newArray[len] = element;\n        array = newArray;\n    }\n    public Iterator iterator() {\n        return new Iterator() {\n            protected final Object[] snapshot = getArray();\n            protected int cursor = 0;\n            public boolean hasNext() {\n                return cursor &lt; snapshot.length;\n            }\n            public Object next() {\n                try {\n                    return snapshot[cursor++];\n                }\n                catch (IndexOutOfBoundsException ex) {\n                    throw new NoSuchElementException();\n                }\n            }\n        };\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>OBJECT-splitting&nbsp;AND LOCK-splitting</h2>\n\n<p>Isolate independent aspects of object&nbsp;into Helper objects. Put together dependent aspects in a (preferrably) immutable class.</p>\n\n<p>For example if move() method is dependent on x and y co-ordinates it&#39;s better to keep x,y in an immutable object, and use that in move() method.</p>\n\n<p>Example of Lock-Splitting can be seen in implementation of ConcurrentHashMap, BlockingQueue&#39;s, and ConcurrentLinkedQueue</p>\n\n<pre>\n<code class=\"language-java\">class LinkedQueue {\n    protected Node head = new Node(null);\n    protected Node last = head;\n    protected final Object pollLock = new Object();\n    protected final Object putLock = new Object();\n    public void put(Object x) {\n        Node node = new Node(x);\n        synchronized (putLock) { // insert at end of list\n            synchronized (last) {\n                last.next = node; // extend list\n                last = node;\n            }\n        }\n    }\n    public Object poll() { // returns null if empty\n        synchronized (pollLock) {\n            synchronized (head) {\n                Object x = null;\n                Node first = head.next; // get to first real node\n                if (first != null) {\n                    x = first.object;\n                    first.object = null; // forget old object\n                    head = first; // first becomes new head\n                }\n                return x;\n            }\n        }\n    }\n    static class Node { // local node class for queue\n        Object object;\n        Node next = null;\n        Node(Object x) { object = x; }\n    }\n}</code></pre>\n\n<p>Optimistic Updates: Rather than holding lock for entire duration of state update operations,&nbsp;they employ synchronization only at the beginnings and ends of update methods.</p>\n\n<ol>\n\t<li>Get a copy of the current state representation (while holding a lock).</li>\n\t<li>Construct a new state representation (without holding any locks).</li>\n\t<li>Commit to the new state only if the old state has not changed since obtaining it.</li>\n</ol>\n\n<p>Optimistic Updates with retry support (spinning until success) may lead to livelock. But if somehow wait-free nature is guaranteed, they succeed after a bounded number of attempts regardless of contention. Most modern micro-processors support compareAndSwap instructions, which makes Optimistic Updates perfectly efficient.</p>\n\n<pre>\n<code class=\"language-java\">class OptimisticBoundedCounter {\n    private Long count_ = new Long(MIN);\n    long value() { return count().longValue(); }\n    synchronized Long count() { return count_;}\n    private synchronized boolean commit(Long oldc, Long newc){\n        boolean success = (count_ == oldc);\n        if (success) count_ = newc;\n        return success;\n    }\n    public void inc() throws InterruptedException{\n        for (;;) { // retry-based\n            if (Thread.interrupted())\n                throw new InterruptedException();\n            Long c = count();\n            long v = c.longValue();\n            if (v &lt; MAX &amp;&amp; commit(c, new Long(v+1)))\n                break;\n            Thread.yield();\n        }\n    }\n    public void dec(){} // symmetrical\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>Reducing Synchronization</h2>\n\n<p>Remove synchronization from accessors, if you are guaranteed that the field is guaranteed to never (event temporarily) see an invalid value (e.g. size field in ArrayList) AND the client code does not mind getting stale value. If the reference can have illegal value and still you remove the synchronization from accessor, make sure that client code applies some technique for handling this (e.g. Double-Checks). Better if you could just remove the need for accessor. Just think why your client need to access field (&nbsp;in a multithreaded environment, it&#39;s usually no good). If the state is guaranteed to be legal, but staleness is not acceptable and you want to remove synchronization use volatile reference.</p>\n\n<p>You can construct/use&nbsp; Atomic classes (e.g. AtomicInteger) for simple values, that will offload some synchronization.&nbsp;</p>\n\n<p>Double-Check pattern is susceptible to inconsistencies</p>\n\n<pre>\n<code class=\"language-java\">//The below one is SAFE : as it uses locking to perform check\nclass LazySingleton {\n    private static LazySingleton s = null;\n    private static final Object classLock = LazySingleton.class;\n    public static LazySingleton instance() {\n        synchronized(classLock) {\n            if (s == null) s = new LazySingleton();\n            return s;\n        }\n    }\n}\n\n//This version with Double-Check is not completely SAFE: \nclass LazySingleton {\n    private static LazySingleton s = null;\n    private static final Object classLock = LazySingleton.class;\n    public static LazySingleton instance() {\n        if(s == null) {\n            synchronized(classLock) {\n                if (s == null) s = new LazySingleton();\n                return s;\n            }\n        }\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>Lock Utilities</h2>\n\n<p>Mutexes (Mutual Exclusion Locks). Have the same functionality as in-built synchronization locks. But unlike in-built synchronization lock it&nbsp;can span beyond code blocks, be passed around. It also provides time version, which can be used for resource-ordering based on trial (i.e Swap locks order if did not succeed)</p>\n\n<pre>\n<code class=\"language-java\">public class Mutex implements Sync {\n    public void acquire() throws InterruptedException;\n    public void release();\n    public boolean attempt(long msec) throws InterruptedException;\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">class ListUsingMutex {\n    static class Node {\n        Object item;\n        Node next;\n        Mutex lock = new Mutex(); // each node keeps its own lock\n        Node(Object x, Node n) { item = x; next = n; }\n    }\n    protected Node head; // pointer to first node of list\n    //Use plain synchronization to protect head field.\n// (We could instead use a Mutex here too but there is no reason to do so.)\n    protected synchronized Node getHead() { return head; }\n    public synchronized void add(Object x) { // simple prepend\n        // for simplicity here, do not allow null elements\n        if (x == null) throw new IllegalArgumentException();\n// The use of synchronized here protects only head field.\n// The method does not need to wait out other traversers that have already made it past head node.\n        head = new Node(x, head);\n    }\n    boolean search(Object x) throws InterruptedException {\n        Node p = getHead();\n        if (p == null || x == null) return false;\n        p.lock.acquire(); // Prime loop by acquiring first lock.\n// If above acquire fails due to interrupt, the method will\n// throw InterruptedException now, so there is no need for further cleanup.\n        for (;;) {\n            Node nextp = null;\n            boolean found;\n            try {\n                found = x.equals(p.item);\n                if (!found) {\n                    nextp = p.next;\n                    if (nextp != null) {\n                        try { // Acquire next lock while still holding current\n                            nextp.lock.acquire();\n                        }\n                        catch (InterruptedException ie) {\n                            throw ie; // Note that finally clause will execute before the throw\n                        }\n                    }\n                }\n            }\n            finally { // release old lock regardless of outcome\n                p.lock.release();\n            }\n            if (found)\n                return true;\n            else if (nextp == null)\n                return false;\n            else\n                p = nextp;\n        }\n    }\n// ... other similar traversal and update methods ...\n}</code></pre>\n\n<p>A generic lock-ordering manager for locks</p>\n\n<pre>\n<code class=\"language-java\">\nclass LockManager { // Code sketch\n    // ...\n    protected void sortLocks(Sync[] locks) { /* ... */ }\n    public void runWithinLocks(Runnable op, Sync[] locks)\n            throws InterruptedException {\n        sortLocks(locks);\n// for help in recovering from exceptions\n        int lastlocked = -1;\n        InterruptedException caught = null;\n        try {\n            for (int i = 0; i &lt; locks.length; ++i) {\n                locks[i].acquire();\n                lastLocked = i;\n            }\n            op.run();\n        }\n        catch (InterruptedException ie) {\n            caught = ie;\n        }\n        finally {\n            for (int j = lastlocked; j &gt;= 0; --j)\n                locks[j].release();\n            if (caught != null)\n                throw caught;\n        }\n    }\n}</code></pre>\n\n<p>Read-Write locks</p>\n\n<pre>\n<code class=\"language-java\">interface ReadWriteLock {\n    Sync readLock();\n    Sync writelock();\n}</code></pre>\n\n<p>The idea is that readLock may be held simultaneously by many readers, but writeLock is mutually exclusive. Read-Write locks are useful in these scenarios:</p>\n\n<ul>\n\t<li>Reading is not permitted while writing methods are in progress. (If reads are permitted during writes, you may instead rely on unsynchronized read methods or copy-on-write updates</li>\n\t<li>Target applications generally have more readers than writers.</li>\n\t<li>The methods in a class can be cleanly separated into those that only access (read) internally held data and those that modify (write).</li>\n\t<li>The methods are relatively time-consuming, so it pays to introduce a bit more overhead associated with read-write locks compared to simpler techniques in order to allow concurrency among reader threads.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">class DataRepository { // Code sketch\n    protected final ReadWriteLock rw = new RWLock();\n    public void access() throws InterruptedException {\n        rw.readLock().acquire();\n        try {\n/* read data */\n        }\n        finally {\n            rw.readLock().release();\n        }\n    }\n    public void modify() throws InterruptedException {\n        rw.writeLock().acquire();\n        try {\n/* write data */\n        }\n        finally {\n            rw.writeLock().release();\n        }\n    }\n}\n</code></pre>\n\n<h2>Dealing With Failures</h2>\n\n<p>Handling Exceptions: Methods may throw exceptions when they found that their precoditions is not met. The strategies to handle this are:</p>\n\n<ul>\n\t<li>Abrupt Termination 9default for uncaught exceptions like NullPointerException )</li>\n\t<li>Continuation (might make sense when failed invocation does not affect overall functionality in long term, e.g. in some situations,&nbsp;listeners&nbsp;even if one event is not notified, it will not affect much)</li>\n\t<li>Rollback/Roll-Forward (or Recovery)</li>\n\t<li>Retry</li>\n\t<li>Delegation to Handlers</li>\n</ul>\n\n<p><strong>Cancellation</strong></p>\n\n<p>Java does not provide any forceful termination/cancellation of thread (after deprecation of stop method). Interruption mechanism is used to perform cancellation, where caller throws InterruptedException if it wants to request cancellation from other threads. Other threads decide what to do on this, they come to know about interruption either by checking interruption status (using Thread.isInterrupted() or thread.interrupted()) or by catching InterruptedException. Thread.stop() may leave objects in inconsistent state (thread receives termination signal and dies while in middle of some update operation). Use it in scenarios, where where you are sure that killing the thread is more useful than anything else.</p>\n\n<p>By convention, interruption status is cleared when InterruptedException is thrown</p>\n\n<p>wait, sleep, join automatically check for interruption and throw InterruptedException.</p>\n\n<p>When you need to propagate interruption status after handling an InterruptedException, you must either rethrow the exception or reset the status via Thread.currentThread().interrupt().</p>\n\n<p>If code in threads you create calls other code that does not properly preserve interruption status (for example, ignoring InterruptedException without resetting status), you may be able to circumvent problems by maintaining a field that remembers cancellation status, setting it whenever calling interrupt and checking it upon return from these problematic calls.</p>\n\n<p>Threads do not respond to&nbsp;interrupts while waiting for a lock used in a synchronized method or block</p>\n\n<pre>\n<code class=\"language-java\">class Terminator {\n    // Try to kill; return true if known to be dead\n    static boolean terminate(Thread t, long maxWaitToDie) {\n        if (!t.isAlive()) return true; // already dead\n        // phase 1 -- graceful cancellation\n        t.interrupt();\n        try { t.join(maxWaitToDie); }\n        catch(InterruptedException e){} // ignore\n        if (!t.isAlive()) return true; // success\n// phase 2 -- trap all security checks\n        theSecurityManager.denyAllChecksFor(t); // a made-up method\n        try { t.join(maxWaitToDie); }\n        catch(InterruptedException ex) {}\n        if (!t.isAlive()) return true;\n        // phase 3 -- minimize damage\n        t.setPriority(Thread.MIN_PRIORITY);\n        return false;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "linked-to-138", "tags": [], "img": "", "summary": "", "lastUpdated": "2021-01-19 12:51:17.558808"}