{"name":"Algorithm Notes -1","id":111,"content":"<h2>Which algo is slower&nbsp;in terms of BigOh?</h2>\n\n<p>&nbsp; n! 4^n 2^n n^2 nlogn log(n!) &nbsp;n 2^log(n) log^2(n) sqrt(log(n)) &nbsp;log(log(n)) 1</p>\n\n<h2>Find all the strings of n-bits ?</h2>\n\n<p>&nbsp;&nbsp; &nbsp;stringsOfLength(1) = 0,1</p>\n\n<p>&nbsp;&nbsp; &nbsp;00, 01, 10, 11<br />\n&nbsp;&nbsp; &nbsp;000, 010, 100, 110, ...</p>\n\n<p>&nbsp;&nbsp; &nbsp;stringsOfLength(3) = 0.concat(stringsOfLength(2)), 1.concat(stringsOfLength(2))</p>\n\n<p>All strings of length n drawn from 0..k-1</p>\n\n<h2><br />\nLinkedLists</h2>\n\n<p>Insertion at beginning, end, middle, given-pointer</p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">To find middle -&gt;&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Two runners: 1,2,3,4,5<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 1,3,5<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; When second is at last, first will be at middle</div>\n\n<p>Deletion at beginning, end, middle, given-pointer</p>\n\n<p>Run-from-start-and-stop-at-point-when-next-node-is-the-target-node-Do-the-transitions.</p>\n\n<p><strong><big>Can we reduce the search-time in linked list?</big></strong><br />\nYES:<br />\n&nbsp;&nbsp; &nbsp;Create-linked-list-of-small-arrays<br />\n&nbsp;&nbsp; &nbsp;Create-linked-list-of-small-circular-linked-lists<br />\n&nbsp;&nbsp; &nbsp;Create-multilevel-pointers-in-linked-list-and-put-elements-in-sorted-order</p>\n\n<p><big><strong>Return Nth element from end in a LinkedList</strong></big></p>\n\n<p>&nbsp;&nbsp; &nbsp;Two runners: Second runner is n-step-formward-from-first. When second hits the end, first will be at (end-N)</p>\n\n<p><strong><big>How To Detect Cycle In Linked List?</big></strong></p>\n\n<p>&nbsp; &nbsp; If there is a cycle and two runners with different speeds start running, they will eventually meet at some point in circle.<br />\n&nbsp;&nbsp; &nbsp;We can also use HashTable to detect this</p>\n\n<p>&nbsp; &nbsp;<strong>How to find the beginning of loop?</strong></p>\n\n<p><b>&nbsp; &nbsp;</b>Suppose the faster pointer moves at twice speed. Then the distance travelled by faster&nbsp;= 2*(distance travelled by slower)</p>\n\n<p>&nbsp; &nbsp;Given m = length-from-head-to-start-of-loop, n=length-of-loop, k=distance-of-meeting-point-from-start-of-loop</p>\n\n<p>&nbsp; &nbsp; (m+n*x+k) = 2*(m+n*y+k) &nbsp;=&gt; &nbsp;m = (x-2y)*n - k</p>\n\n<p>&nbsp; &nbsp; So, if we move a pointer from head, another from meeting point which is at distance of k from -start-of-cycle; then ultimately they will meet at the start-of-cycle itself.</p>\n\n<p><strong><big>How to find intersection node in given linked lists ?</big></strong></p>\n\n<p>&nbsp; &nbsp; Use hashtable.</p>\n\n<p>&nbsp; &nbsp; Use two stacks -&gt; TOP of both will be same for the nodes after intersection point.</p>\n\n<p>&nbsp; &nbsp; Find length of both, take as-many-steps-in-longer -list-as-the-difference-of-lengths, then synchronize the steps. Find the step where next pointers of both point to same node.</p>\n\n<p><big>If the head of the LinkedList is pointing to k-th element, how would you get the elements before k-th element?</big></p>\n\n<p>&nbsp; &nbsp;Use XOR Linked List</p>\n\n<p><strong><big>Is it possible for a data structure to deliver O(1) in case of insertion, deletion, and query all?</big></strong></p>\n\n<p>YES, combine LinkedList with HashTable.</p>\n\n<p>&nbsp; &nbsp;</p>\n","authorId":null,"subject":"notes","tags":null,"img":null,"summary":null,"lastUpdated":null}