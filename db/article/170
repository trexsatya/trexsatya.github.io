{"name":"Enterprise Integration Technologies","id":170,"content":"<p><strong>Why integration?</strong></p>\n\n<p>For enterprise level applications, it becomes necessary at some point that we are able to integrate different applications and services in a smooth way; because not everything can be built from scratch.&nbsp;</p>\n\n<p>If an enterprise acquires some other company it will need to integrate the applications and systems of the acquired company with its own.</p>\n\n<p>&nbsp; &nbsp;(Well there are alternatives to integration in this scenario: Just take their data, and put inside your system using&nbsp;ETL tools; <strong>though its gonna cost more in most cases</strong>)</p>\n\n<p><strong>Solutions:</strong></p>\n\n<p><b>&nbsp;</b>Hand-coding the integration logic - cumbersome, errorprone, time-taking</p>\n\n<p>&nbsp; &nbsp; &nbsp; (Libraries and frameworks can help there e.g. Apache Camel)</p>\n\n<p>Using some ESB solution like Mule ESB.</p>\n\n<hr />\n<p>Apache Camel is a library/framewrork/platform that provides you ability to integrate services easily.</p>\n\n<p>ApacheCamel offers these high-level services:&nbsp;</p>\n\n<ul>\n\t<li>Can Route messages from one endpoint to other (endpoints could be TCP/IP port, HTTP URLs, File/FTP URLs, JMS source/destinations)</li>\n\t<li>Can Transform messages in the appropriate form, it will wrap up the message in javax.jms.Message object before delivering to JMS endpoint.</li>\n\t<li>Gives components to use for message transformation</li>\n\t<li>Can poll endpoints</li>\n\t<li>Can act as API mediator</li>\n</ul>\n\n<h2>Typical Usage Example</h2>\n\n<pre>\n<code class=\"language-java\">//Add dependencies //you could use different version, latest maybe\ncompile org.apache.camel:camel-jms:2.5.0 \ncompile org.apache.activemq:activemq-core:5.3.2\n\nCamelContext context = new DefaultCamelContext();\n \nConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"vm://localhost\");\n\ncontext.addComponent(\"jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\ncontext.addRoues(new RouteBuilder(){\n\tpublic void configure(){\n        from(\"file:data/in\").\n           .filter().xpath(\"/order[not(@test)]\")\n           .transform(intoJSON)\n           .choice()\n            .when(predicate)...\n            .otherwise()..\n           .endChoice()\n        .to(\"jms:queue:SomeQueue\").end();\n\t}\n});\n</code></pre>\n\n<h2><br />\nCamel Components</h2>\n\n<p>The camel component you want to use is defined by first part of uri e.g. &quot;file:&quot;, &quot;jms.queue.SomeQueue&quot;, &quot;timer:&quot;, &quot;http:&quot;, etc.</p>\n\n<p>Camel creates an &#39;exchange&#39; . Before delivering message to consumer it converts into required format automatically.<br />\nCamel supports EventDrivenConsumers and PollingConsumers<br />\n&nbsp;&nbsp; &nbsp;EDC wake up when a message arrives (usually at a TCP/IP port, or JMS queue)<br />\n&nbsp;&nbsp; &nbsp;PollingConsumers generally used for polling FTPs, Email servers</p>\n\n<p>Camel can send message to multiple destinations in parallel</p>\n\n<pre>\n<code class=\"language-java\">from(..)...\n.multicast()\n.stopOnException() // =&gt; stop sending on first exception\n.parallelProcessing().executorService(executor)\n\n//To multicast conditionally\n//Encapsulate condition and routes in separate class; there are other ways, but its neater\npublic class RecipientListBean {\n\t@RecipientList\n\tpublic String[] route(@XPath(\"/order/@customer\") String customer) {\n\t\tif (isGoldCustomer(customer)) {\n\t\t\treturn new String[] {\"jms:accounting\", \"jms:production\"};\n\t\t} else {\n\t\t\treturn new String[] {\"jms:accounting\"};\n\t\t}\n\t}\n}</code></pre>\n\n<h2>&nbsp;</h2>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-137","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:26.264+0000"}