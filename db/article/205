{"name":"Kubernetes and Openshift","id":205,"content":"<h2><strong>Objective</strong></h2>\n\n<p>Suppose, you have containerized your applications using Docker i.e. application is packaged as a <em>docker image</em> which can straight away be deployed to any machine (either physical, or virtual or in <em>cloud</em>). Now you have multiple hosts available on which you can deploy these images. You may also want to scale some containers (<em>run more instances of them</em>).</p>\n\n<p>Since managing multiple hosts, and scaling across them is always a cumbersome task, it is wise to automate this.&nbsp; There are many Container Orchestrators available to help with this:</p>\n\n<ul>\n\t<li><strong>Docker Swarm</strong><br />\n\t<a href=\"https://docs.docker.com/engine/swarm/\" target=\"_blank\">Docker Swarm</a>&nbsp;is a container orchestrator provided by&nbsp;<a href=\"https://www.docker.com/\" target=\"_blank\">Docker, Inc</a>. It is part of&nbsp;<a href=\"https://docs.docker.com/engine/\" target=\"_blank\">Docker Engine</a>.</li>\n\t<li><strong>Kubernetes</strong><br />\n\t<a href=\"https://kubernetes.io/\" target=\"_blank\">Kubernetes</a>&nbsp;was started by Google, but now, it is a part of the&nbsp;<a href=\"https://www.cncf.io/\" target=\"_blank\">Cloud Native Computing Foundation</a>&nbsp;project.</li>\n\t<li><strong>Mesos Marathon</strong><br />\n\t<a href=\"https://github.com/mesosphere/marathon\" target=\"_blank\">Marathon</a>&nbsp;is one of the frameworks to run containers at scale on&nbsp;<a href=\"http://mesos.apache.org/\" target=\"_blank\">Apache Mesos</a>.</li>\n\t<li><strong>Amazon ECS</strong><br />\n\t<a href=\"https://aws.amazon.com/ecs/\" target=\"_blank\">Amazon EC2 Container Service</a>&nbsp;(ECS) is a hosted service provided by AWS to run Docker containers at scale on its infrastructrue.</li>\n\t<li><strong>Hashicorp Nomad</strong><br />\n\t<a href=\"https://www.nomadproject.io/\" target=\"_blank\">Nomad</a>&nbsp;is the container orchestrator provided by&nbsp;<a href=\"https://www.hashicorp.com/\" target=\"_blank\">HashiCorp</a>.</li>\n</ul>\n\n<p>We will see:</p>\n\n<ul>\n\t<li>How Kubernetes works</li>\n\t<li>How to manage containers using Kubernetes</li>\n\t<li>How to scale</li>\n\t<li>How to achieve service discovery, load balancing, storage orchestration&nbsp;</li>\n</ul>\n\n<h2><strong>Kubernetes Architecture and Concepts:</strong></h2>\n\n<p>Kubernetes works on a cluster based model. It has one or more masters and zero or more nodes in the cluster.&nbsp;<b>Kubernetes automates the distribution and scheduling of application containers across a cluster in a more efficient way.</b></p>\n\n<ul>\n\t<li>The&nbsp;<b>Master</b>&nbsp;coordinates the cluster (controls all activities in clsuter e.g. scheduling, scaling, maintaining desired state of application)</li>\n\t<li><b>Nodes</b>&nbsp;are the workers that run applications (nodes run Kubernetes agent called <em>Kubelet</em>, They receive isntructions from master and perform docker operations, it means nodes must have <strong><em>docker</em></strong> (or <em><strong><a href=\"https://coreos.com/rkt/\" target=\"_blank\">rkt</a>, or <a href=\"https://linuxcontainers.org/lxd/\" target=\"_blank\">lxd</a></strong></em>)&nbsp; container runtime&nbsp;installed.</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://prod-edxapp.edx-cdn.org/assets/courseware/v1/8f441b27101be805bc286e67adc671a2/asset-v1:LinuxFoundationX+LFS158x+1T2018+type@asset+block/Kubernetes_Architecture1.png\" style=\"width: 600px; height: 360px;\" /></p>\n\n<p>To learn Kubernetes and for development purposes, there is lighter version of it called Minikube which we can run on single machine. It will create a VM and setup a local cluster.</p>\n\n<p><a href=\"https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/\" target=\"_blank\">https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/</a></p>\n\n<p><strong>Pods</strong></p>\n\n<p>One (or possibly more application <em>docker or any other</em> container) + storage resources + a unique network IP + some configs. A pod represents one running instance of your application.</p>\n\n<p>To <em>scale up</em> means increasing the number of pods.&nbsp;</p>\n\n<p>Containers inside pod can communicate using <em>localhost</em>. (Note multiple containers in a pod is an advanced usage scrnario rarely used)</p>\n\n<p>Data related to pod is persisted in the mounted storage resource.</p>\n\n<p>You do not use Pods directly (you can but you should not), you use them through <strong><em>Controller</em></strong>s.</p>\n\n<ul>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Deployment</a></li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/\">StatefulSet</a></li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/\">DaemonSet</a></li>\n</ul>\n\n<p>Pods are created using a specification defined in YAML file called <em>Pod Template</em>. (&nbsp;<a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod/\" target=\"_blank\">https://kubernetes.io/docs/concepts/workloads/pods/pod/</a>&nbsp;)</p>\n\n<p>You can specify your own API which tells whether the pod is ready or not. For example when the application is up and running, then only Pod should show READY status.</p>\n\n<p><strong>Deployment</strong></p>\n\n<p>Deployment is a Controller that can be used to :-</p>\n\n<ul>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#creating-a-deployment\">Create a Deployment to rollout a ReplicaSet</a>. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment\">Declare the new state of the Pods</a>&nbsp;by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment\">Rollback to an earlier Deployment revision</a>&nbsp;if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment\">Scale up the Deployment to facilitate more load</a>.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment\">Pause the Deployment</a>&nbsp;to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#deployment-status\">Use the status of the Deployment</a>&nbsp;as an indicator that a rollout has stuck.</li>\n\t<li><a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy\">Clean up older ReplicaSets</a>&nbsp;that you don&rsquo;t need anymore</li>\n</ul>\n\n<p>You specify a Deployment by creating a configuration file in YAML format, and then call Kubernetes API or command to create a deployment. The Deployment will then create a ReplicaSet which will create pods according to configurations. You do not directly control ReplicaSets.</p>\n\n<p><strong>StatefulSet</strong></p>\n\n<p>Mostly same as Deployment but suited for situations where following scenarios are required:-</p>\n\n<ul>\n\t<li>Stable, unique network identifiers.</li>\n\t<li>Stable, persistent storage.</li>\n\t<li>Ordered, graceful deployment and scaling.</li>\n\t<li>Ordered, automated rolling updates.</li>\n</ul>\n\n<p>In the above, stable is synonymous with persistence across Pod (re)scheduling.</p>\n\n<p>StatefulSet was a beta resource prior to 1.9 and not available in any Kubernetes release prior to 1.5.</p>\n\n<p><em>StatefulSet have many limitations, and are better avoided</em>.&nbsp;<a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#limitations\">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#limitations</a></p>\n\n<p><span style=\"font-size:18px;\"><strong>How would Pods communicate with each other if each time a pod is created, it&#39;s assigned a unique but unstable IP address?</strong></span></p>\n\n<p><span style=\"font-size:14px;\"><strong>Services</strong></span></p>\n\n<p>Service takes some <a href=\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors\" target=\"_blank\">labels</a>&nbsp; to identify pods and defines a policy of how to access them.&nbsp;A&nbsp;<code>Service</code>&nbsp;in Kubernetes is a REST object, similar to a&nbsp;<code>Pod</code>. Like all of the REST objects, a&nbsp;<code>Service</code>&nbsp;definition can be POSTed to the apiserver to create a new instance.</p>\n\n<p>Service will create a Endpoints object automatically. Every node in Kubernetes cluster runs a&nbsp;kube-proxy, which is responsible for reading Endpoints and create an virtual IP for Service.&nbsp;</p>\n\n<p>How to access these Virtual IPs? (&nbsp;<a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\" target=\"_blank\">https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies</a> )</p>\n\n<ul>\n\t<li>Using Environment variables (exposed automatically after Service is created); <em>less favorable</em>.</li>\n\t<li>Using DNS records (A DNS server automatically watches Services being created, and creates DNS record) with format &lt;service-name&gt;.&lt;name-space-name&gt;. Other services can access this service using this DNS name.</li>\n</ul>\n\n<p>Kubernetes also allows you to use your own Service Discovery mechanism.&nbsp;<a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#headless-services\" target=\"_blank\">https://kubernetes.io/docs/concepts/services-networking/service/#headless-services</a></p>\n\n<p>By default the IP assigned to Service is cluster-local, can only be accessed from within cluster. To access from outside, you need to use different <em>ServiceType.</em></p>\n\n<p><a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#externalname\"><code>ExternalName</code></a>: Maps the service to the contents of the&nbsp;<code>externalName</code>&nbsp;field (e.g.&nbsp;<code>foo.bar.example.com</code>), by returning a&nbsp;<code>CNAME</code>&nbsp;record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of&nbsp;<code>kube-dns</code></p>\n\n<p>Read this for all possible values of ServiceTypes:&nbsp;<a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types\" target=\"_blank\">https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types</a></p>\n\n<h2><strong>Lets create an app and &quot;deploy using Kubernetes&quot;</strong></h2>\n\n<p>Kubernetes can be installed in many ways:</p>\n\n<ul>\n\t<li>All-in-one mode (Master, worker everything on single system)&nbsp;</li>\n\t<li>(Single/Multiple) Master - (Single/Multiple) Nodes mode</li>\n</ul>\n\n<p>Kubernetes can be installed on:</p>\n\n<ul>\n\t<li>Localhost</li>\n\t<li>On-Premise VMs created via&nbsp;Vagrant, VMware vSphere, KVM, etc.&nbsp; OR&nbsp;On-Premise Bare Metal</li>\n\t<li><strong>Hosted Solutions </strong>e.g.&nbsp;<a href=\"https://cloud.google.com/container-engine/\" target=\"_blank\">Google Kubernetes Engine (GKE)</a>,&nbsp;&nbsp;<a href=\"https://aws.amazon.com/eks/\" target=\"[object Object]\">Amazon Elastic Container Service for Kubernetes (EKS)</a>,&nbsp;<a href=\"https://www.openshift.com/dedicated/\" target=\"_blank\">OpenShift Dedicated</a>,&nbsp;<a href=\"https://azure.microsoft.com/en-us/services/container-service/\" target=\"_blank\">Azure Container Service&nbsp;(AKS)</a></li>\n\t<li>Turnkey Cloud Solutions on IaaS platforms e.g.&nbsp;&nbsp;<a href=\"https://kubernetes.io/docs/getting-started-guides/gce/\" target=\"_blank\">Google Compute Engine</a>,&nbsp;&nbsp;<a href=\"https://kubernetes.io/docs/getting-started-guides/aws/\" target=\"_blank\">Amazon AWS</a>,&nbsp;<a href=\"https://kubernetes.io/docs/getting-started-guides/azure/\" target=\"_blank\">Microsoft Azure</a></li>\n\t<li>Cloud Bare-Metal</li>\n</ul>\n\n<p>To setup a Kubernetes cluster and use it, you can either use tools and scripts like <a href=\"https://github.com/kubernetes/kubeadm\" target=\"_blank\">kubeadm</a>,&nbsp;<a href=\"https://github.com/kubernetes-incubator/kubespray\" target=\"_blank\">KubeSpray</a>, <a href=\"https://github.com/kubernetes/kops\" target=\"_blank\">Kops</a>&nbsp;OR <a href=\"https://github.com/kelseyhightower/kubernetes-the-hard-way\" target=\"_blank\">you can install manually from scratch</a>.</p>\n","authorId":null,"subject":"devops","tags":null,"img":null,"summary":null,"lastUpdated":"2018-10-20T11:47:08.119+0000"}