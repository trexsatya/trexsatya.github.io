{"name":"Cuncurrent HashMap","id":83,"content":"<p>ConcurrentHashMap implementation: Java-11 version.</p>\n\n<p>Extract of important documentation and code.</p>\n\n<p><strong>Can threads read and write at the same time in CHM?</strong></p>\n\n<p>Yes, as many threads can read from any bin/bucket at any time and it is guaranteed that they will see the latest update. How is it guaranteed?</p>\n\n<pre>\n<code class=\"language-java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n        final int hash;\n        final K key;\n        volatile V val; //Volatile here, guarantees that you will see the latest value\n        volatile Node&lt;K,V&gt; next; //volatile here guarantees that, even if some other thread put a new value in the same bin and caused the 'next' pointer to update, it will be seen by the reading thread.\n        //....\n}\n\n//See that get method loops on to the list in given bucket/bin\npublic V get(Object key) {\n     if ((tab = this.table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, n - 1 &amp; h)) != null) {\n      //...\n        while ((e = e.next) != null) {\n            if (e.hash == h &amp;&amp;\n                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))\n                return e.val;\n        }\n       //..\n}</code></pre>\n\n<pre style=\"background-color:#ffffff;color:#000000;font-family:'DejaVu Sans Mono';font-size:9.0pt;\">\n\n<span style=\"color:#808080;font-style:italic;\">For aggregate operations\n</span><span style=\"color:#808080;font-style:italic;\">* such as {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@code </span><span style=\"color:#808080;font-style:italic;\">putAll} and {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@code </span><span style=\"color:#808080;font-style:italic;\">clear}, concurrent retrievals may\n</span><span style=\"color:#808080;font-style:italic;\">* reflect insertion or removal of only some entries.  Similarly,\n</span><span style=\"color:#808080;font-style:italic;\">* Iterators, Spliterators and Enumerations return elements reflecting the\n</span><span style=\"color:#808080;font-style:italic;\">* state of the hash table at some point at or since the creation of the\n</span><span style=\"color:#808080;font-style:italic;\">* iterator/enumeration.  They do </span><span style=\"color:#808080;background-color:#e2ffe2;font-style:italic;\">&lt;em&gt;</span><span style=\"color:#808080;font-style:italic;\">not</span><span style=\"color:#808080;background-color:#e2ffe2;font-style:italic;\">&lt;/em&gt;</span><span style=\"color:#808080;font-style:italic;\"> throw {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@link\n</span><span style=\"color:#808080;font-style:italic;\">* java.util.ConcurrentModificationException ConcurrentModificationException}.\n</span><span style=\"color:#808080;font-style:italic;\">* However, iterators are designed to be used by only one thread at a time.\n</span><span style=\"color:#808080;font-style:italic;\">* Bear in mind that the results of aggregate status methods including\n</span><span style=\"color:#808080;font-style:italic;\">* {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@code </span><span style=\"color:#808080;font-style:italic;\">size}, {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@code </span><span style=\"color:#808080;font-style:italic;\">isEmpty}, and {</span><span style=\"color:#808080;font-weight:bold;font-style:italic;\">@code </span><span style=\"color:#808080;font-style:italic;\">containsValue} are typically\n</span><span style=\"color:#808080;font-style:italic;\">* useful only when a map is not undergoing concurrent updates in other threads.\n</span><span style=\"color:#808080;font-style:italic;\">* Otherwise the results of these methods reflect transient states\n</span><span style=\"color:#808080;font-style:italic;\">* that may be adequate for monitoring or estimation purposes, but not\n</span><span style=\"color:#808080;font-style:italic;\">* for program control.</span></pre>\n\n<p>And, as many threads as there are bins/buckets can write simultaneously in a thread-safe way. Why? - Because each bucket is guarded by its own lock which is the first node of bin/bucket.</p>\n\n<p>You can set the concurrency level at the time you create CHM instance. Otherwise there is a default level.</p>\n\n<pre>\n<code class=\"language-java\">DEFAULT_CONCURRENCY_LEVEL = 16</code></pre>\n\n<p>Put operation uses CAS to put the first node in the bin (which is most common if you use a good hash key distribution), then it traverses the list under synchronization lock of the first node.</p>\n\n<pre>\n<code class=\"language-java\">    /** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node&lt;K,V&gt;[] tab = table;;) {\n            Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {\n                if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))\n                    break;                   // no lock when adding to empty bin\n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent // check first node without acquiring lock\n                     &amp;&amp; fh == hash\n                     &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))\n                     &amp;&amp; (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh &gt;= 0) {\n                            binCount = 1;\n                            for (Node&lt;K,V&gt; e = f;; ++binCount) {\n                                K ek;\n                                if (e.hash == hash &amp;&amp;\n                                    ((ek = e.key) == key ||\n                                     (ek != null &amp;&amp; key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node&lt;K,V&gt; pred = e;\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node&lt;K,V&gt;(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            Node&lt;K,V&gt; p;\n                            binCount = 2;\n                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount &gt;= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n</code></pre>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-142","tags":["medium"],"img":"/images/hashmap.jpg","summary":null,"lastUpdated":"2018-07-01T13:59:23.222+0000"}