{"name":"","id":14,"content":"<p>Python gems:</p><p>Unpacking of sequence: _, shares, price, _ = &nbsp;[ 'ACME', 50, 91.1, (2012, 12, 21) ]&nbsp; =&gt; shares = 50, price = 91.1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name, email, *phone_numbers = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212') =&gt; phone_numbers = ( '773-555-1212', '847-555-1212' )<br /> </p><p><strong>Basic algorithms</strong></p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">import heapq\nheapq.nlargest(3,[...]) //You can also pass sequence of objects and a lambda to compare. \nheapq.nsmallest(3, [{}, {}] key = lambda s: s['something'] \n\nAlternatives: heap = heapq.heapify(list( [..] )); heapq.heappop(heap) \nAlso        : sorted([...])[:3] //largest 3   </pre><p>Deduplicate data:</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">Deduplicate normal data: set([...]) //But the order is not preserved. Data will be scrambled.\nTo de-duplicate complex data, convert your data into some hashable type e.g. tuple\n{a: 1, b: 2} ===&gt; (1,2)\n</pre><p> </p><p>Data Structures:</p><p>Multimaps</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">from collections import defaultdict\n\nd = defaultdict(list) or defaultdict(set)\nd['a'].append(1)\n\nThere is also OrderedDict of similar fashion \n\nInvert the map: revMap = zip(d.values(), d.keys()) //But this can be used only once. \n\nFind the entry with minimum of value: d[min(d, key = lambda k:d[k])]; normally key of dictionary is used in aggregations. \nSet operations on dictionaries: Commons/Intersection d1.items() &amp; d2.items() \n                                Differences          d1.items() - d2.items()</pre><p>Frequency map</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">from collections import Counter\nCounter([...]).most_common(3) //Top 3\n</pre><p>Sorting, grouping a map</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">sorted([{...}..], key = lambda d: d['something'])\n\n//But there is a faster (and a better one) alternative\nfrom operator import itemgetter\nsorted([{...}..], key = itemgetter('something')) //There can be more than one something\n\nSimilarly there is a attrgetter('something') to be used with object instances.\n\nfrom itertools import groupby\ngroupby([{..}..], key=itemgetter('something'))\n\n</pre><p>Filtering</p><p>Options are List comprehension, generator expressions, filter function</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">list(filter(someFunction, [...])) //Filter returns an iterator, not actual sequence.\n\n[someFunction(x) for x in [...] if somePredicate(x) ] [someFunction(x) if somePredicate(x) else somethingElse for x in [...] ]\n(someFunction(x) for x in [...] if somePredicate(x) ) \n//The difference is only that list comprehensions are eager.\n\nDictionary comprehensions are faster than passing tuples to dict() e.g. dict((k,v) for k,v in {..}.items() if ..)\n</pre><p>Chain lookup in maps, try to find in map1, if not found then in map2, and so on...</p><p>from collections import ChainMap</p><pre data-pbcklang=\"javascript\" data-pbcktabsize=\"4\" class=\"javascript \">cm = ChainMap(a,b) //cm will show the changes made in a or b</pre><p> </p><p> </p><p> </p>","authorId":null,"subject":"python","tags":["basic"],"img":null,"summary":null,"lastUpdated":null}