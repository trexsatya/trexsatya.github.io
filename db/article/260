{"name": "Spring Transactions", "id": 260, "content": "<p>Source: <a href=\"https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html\">Infoworld article</a></p>\n\n<p>The Spring Framework&#39;s support for the Java Transaction API (JTA) enables applications to use distributed transactions and the XA protocol&nbsp;<a href=\"http://www.javaworld.com/javaworld/jw-04-2007/jw-04-xa.html\">without running in a Java EE container</a>. Even with this support, however, XA is expensive and can be unreliable or cumbersome to administrate. It may come as a welcome surprise, then, that a certain class of applications can avoid the use of XA altogether.</p>\n\n<p><strong>Full XA with 2-Phase Commit:</strong></p>\n\n<p><strong>If you need close-to-bulletproof guarantees that your application&#39;s transactions will recover after an outage, including a server crash, then Full XA is your only choice.&nbsp;</strong></p>\n\n<p>If the application is Spring-enabled, it uses the Spring&nbsp;<code>JtaTransactionManager</code>&nbsp;and Spring declarative transaction management to hide the details of the underlying synchronization. The difference for the developer between using XA and not using XA is all about configuring the factory resources: the&nbsp;<code>DataSource</code>&nbsp;instances, and the transaction manager for the application.</p>\n\n<p><strong>XA with 1PC Optimization</strong></p>\n\n<p>This pattern is an optimization that many transaction managers use to avoid the overhead of 2PC if the transaction includes a single resource. You would expect your application server to be able to figure this out.</p>\n\n<p><strong>XA and the Last Resource Gambit</strong></p>\n\n<p>For scenarios where transactional message processing is done.</p>\n\n<p>Another feature of many XA transaction managers is that they can still provide the same recovery guarantees when all but one resource is XA-capable as they can when they all are. They do this by ordering the resources and using the non-XA resource as a casting vote. If it fails to commit, then all the other resources can be rolled back. It is close to 100 percent bulletproof -- but is not quite that. And when it fails, it fails without leaving much of a trace unless extra steps are taken (as is done in some of the top-end implementations).</p>\n\n<p><strong>Shared Transaction Resource pattern</strong></p>\n\n<p>We can use&nbsp;<a href=\"http://activemq.apache.org/\" rel=\"nofollow\">Apache ActiveMQ</a>&nbsp;for messaging and plug a storage strategy into the message broker.&nbsp; This way both messaging and db will use same resource (<code>DataSource</code>), and need for XA is avoided.</p>\n\n<p>(This pattern can also be useful in other scenarios dealing with multiple DBs e.g. when table synonyms (pointing to tables in another schema), or when DB-links are used.)</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "programming", "tags": [], "img": "", "summary": "string", "lastUpdated": "2021-02-04 03:45:46.564391"}