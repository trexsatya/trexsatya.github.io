{"name":"Always Write Good Code","id":126,"content":"<p>Whenever you have implemented the functionality, make sure that your code is great.</p>\n\n<p>How do you check if the code is great? - The best way to make sure is Think About <em>&quot;How would you like this code when you come back after a holiday for a long time&quot;</em>&nbsp; or &quot;<em>How would other people like this code while they are reading</em>&quot;.</p>\n\n<p>Here&#39;s a checklist of the questions that may ask to determine if the code is good:-</p>\n\n<ol>\n\t<li>Is it clean, readable?</li>\n\t<li>Does it leave a loophole for unhandled exceptions/failure?</li>\n\t<li>Is there a possibility of security attack?</li>\n\t<li>Will the code perform well, given the high load?</li>\n\t<li>Are you using language&#39;s native/specific features (whatever language you are using)?</li>\n\t<li>Is your code testable, how easy it is&nbsp; to write tests for your code?</li>\n\t<li>Is your code maintainable? How easy it is to figure out what is being done where and how easy it is to make changes?</li>\n</ol>\n\n<p>After asking these questions, you may want to check for common mistakes. Or, instead of doing that manually just use some tool/plugin to check for common mistakes e.g SONAR, BugBash. See the complete list <a href=\"https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis\">here on Wikipedia</a>.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<hr />\n<h2>&nbsp;</h2>\n\n<h2><span style=\"\">Is It Clean, Readable?</span></h2>\n\n<p>Try to name classes, functions, variables in a meaningful way. Try to use names from the <strong>problem domain</strong> itself. Create <em>small</em> classes and <em>small</em> functions. A method should not have more than ten lines of code (it&#39;s not a hard and fast rule, but it&#39;s good one).&nbsp;</p>\n\n<p>Keep It Simple. Do Not Repeat Yourself. Use a Standard Formatting.&nbsp;</p>\n\n<p>Closer the code is to English and the domain language, better it is (for example if you are writing an application for banking, do not use jargons, terminologies from other industries, use terminologies used in banking).</p>\n\n<h2><span style=\"\">Does It Leave A Loophole For Exception/Failure?</span></h2>\n\n<p>Do Not Return Null. (Use Optional if using Java8, else use empty objects, empty arrays etc whatever suits your need).</p>\n\n<p>Take care of any null value which might escape.</p>\n\n<p>Write Tests For Each Value Which Can Be Null.</p>\n\n<p>Do Not Leave Possibility Of <em>Unintended Overriding/Extension</em>: Use final classes, methods, variables. Mark&nbsp;utility classes static final.&nbsp;</p>\n\n<p>Minimize The <em>Accessibility</em>. Make exceptions as&nbsp;specific as possible. Handle as many scenarios as possible.</p>\n\n<p>If the class is ever going to be <u>stored in a collection</u>, it should override hashCode and equals method in a proper/correct way.</p>\n\n<h2><span style=\"\">Is There A Possibility Of Security Attack?</span></h2>\n\n<p>Is the input <em>validated</em>? Is it possible to perform <strong>denial of service</strong> attack?</p>\n\n<p>Are the&nbsp;<em>resources</em> allocated being released? How long are they living? Are they just lying around doing nothing?</p>\n\n<p>Try to minimize the lifecycle of the resources, objects.</p>\n\n<p>Avoid general sources of attacks: SQL Injection, Input Hijacking, Denial Of Service, Illegal Access to objects using serialization/ deserialization process.</p>\n\n<h2><span style=\"\">Will The Code Perform Well Given High Load?</span></h2>\n\n<p>If using multithreading, avoid a lot of <em>synchronized blocks</em>. Definitely avoid synchronized methods. Minimize the scope of synchronization needed.</p>\n\n<p>String concatenation has been the source of slow performance many times in history. Avoid string concatenation in loops.</p>\n\n<p>Minimize creation, lifecycle/scope, usage of objects. Try to pool whenever&nbsp;possible.</p>\n\n<p>Avoid finalizers. Help garbage collection in all possible ways (System.gc() is not a good way to do that).</p>\n\n<h2><span style=\"\">Are You Using Language Features?</span></h2>\n\n<p>Enums can make the code a lot <em>nice-to-see</em> and <em>less-error-prone</em>.&nbsp;</p>\n\n<p>Use interfaces. Use Checked Exceptions and Unchecked Exceptions in a clever way.</p>\n\n<h2><span style=\"\">Is Your Code Testable?</span></h2>\n\n<p><span style=\"\">How easy it is to test your code? Can I completely <em>isolate it and test it</em>? If not, there is a high possibility of improvement.</span></p>\n\n<p><span style=\"\">If the code is <em>highly coupled</em>, it would be hard to isolate and test. If the code is <em>not cohesive</em>, it would be hard to test.</span></p>\n\n<p><span style=\"\">If the code <em>complexity is high</em>, it would be hard to test.</span></p>\n\n<h2><span style=\"\">Is Your Code Maintainable, Extendible?</span></h2>\n\n<p>Check if there is a possibility of using some standard design pattern or some standard library. Your code should not be yet another liability, rather it should be a utility.</p>\n\n<p>&nbsp;</p>\n\n<hr />\n<h2>&nbsp;</h2>\n\n<h2>Common Critical Mistakes</h2>\n\n<p>(1) Eager Evaluation</p>\n\n<p>Example: some costly operation (resource loading for example) performed at the initiation of an object.&nbsp;</p>\n\n<p>(2) Not Caching Things Which Can Be Cached</p>\n\n<p>Example: Some costly computation&nbsp;being done on each invocation.</p>\n\n<p>The above two make an idiomatic case of &#39;<strong><em>Lazy Memoization</em></strong>&#39; which might be available in many languages by default (e.g. Memoization is available in Kotlin, Groovy).</p>\n\n<p>(3) Temporal Side Effects</p>\n\n<p>Detect if not calling a method unintentionally can modify the behaviour, or the order of calling might unintentionally modify the behaviour.</p>\n\n<p>(4) Unwanted Mutational Side Effects</p>\n\n<p>Example: Some mutable object is passed to another method, and then returned to the client.</p>\n\n<p>(5) A Mutable object being used in a multithreaded environment</p>\n\n<p><em>Just don&#39;t use mutable objects in multithreaded environment, it&#39;s too dangerour!</em></p>\n\n<p>(6) Object leaking</p>\n\n<p>A partially constructed mutable object being passed to another thread, check for this possibility.</p>\n\n<p>&nbsp;</p>\n\n<hr />\n<p>&nbsp;</p>\n\n<h2>SONAR Rules for Java</h2>\n\n<p>This rule raises an issue when the following O(n) methods are called outside of constructors on class fields:</p>\n\n<pre>\n<code class=\"language-java\">ArrayList\ncontains\nremove\nLinkedList\nget\ncontains\nConcurrentLinkedQueue\nsize\ncontains\nConcurrentLinkedDeque\nsize\ncontains\nCopyOnWriteArrayList\nadd\ncontains\nremove\nCopyOnWriteArraySet\nadd\ncontains\nremove</code></pre>\n\n<p><br />\nUsage of instanceof in equals() mthod implementation; it breaks for subclasses;</p>\n\n<p>Mutable members should not be returned or stored directly e.g. an array of something.</p>\n\n<p>Public methods should throw at most one checked exception</p>\n\n<p>The purpose of checked exceptions is to ensure that errors will be dealt with, either by propagating them or by handling them, but some believe that checked exceptions negatively impact the readability of source code, by spreading this error handling/propagation logic everywhere.</p>\n\n<p>java.lang.Error and its subclasses represent abnormal conditions, such as OutOfMemoryError, which should only be encountered by the Java Virtual Machine.</p>\n\n<p>Noncompliant Code Example (as per Single Responsibility Principle)<br />\nWith a threshold of 5:</p>\n\n<pre>\n<code class=\"language-java\">class Foo {                        // Noncompliant - Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n  T1 a1;                           // Foo is coupled to T1\n  T2 a2;                           // Foo is coupled to T2\n  T3 a3;                           // Foo is coupled to T3\n\n  public T4 compute(T5 a, T6 b) {  // Foo is coupled to T4, T5 and T6\n    T7 result = a.getResult(b);    // Foo is coupled to T7\n    return result;\n  }\n\n  public static class Bar {        // Compliant - Bar depends on 2 classes: T8 and T9\n    T8 a8;\n    T9 a9;\n  }\n}</code></pre>\n\n<p>A method that grows too large tends to aggregate too many responsibilities. Such method inevitably become harder to understand and therefore harder to maintain.</p>\n\n<p>A selector argument is a boolean argument that&#39;s used to determine which of two paths to take through a method. Specifying such a parameter may seem innocuous, particularly if it&#39;s well named.</p>\n\n<p>Unfortunately, the maintainers of the code calling the method won&#39;t see the parameter name, only its value. They&#39;ll be forced either to guess at the meaning or to take extra time to look the method up.</p>\n\n<p>Instead, separate methods should be written.</p>\n\n<p>This rule finds methods with a boolean that&#39;s used to determine which path to take through the method.</p>\n\n<p><br />\n--------------------------<br />\nIf the reference to the outer class isn&#39;t used, it is more efficient to make the inner class static (also called nested). If the reference is used only in the class constructor, then explicitly pass a class reference to the constructor. If the inner class is anonymous, it will also be necessary to name it.</p>\n\n<p>However, while a nested/static class would be more efficient, it&#39;s worth noting that there are semantic differences between an inner class and a nested one:</p>\n\n<p>an inner class can only be instantiated within the context of an instance of the outer class.<br />\na nested (static) class can be instantiated independently of the outer class.<br />\n-------------------------------</p>\n\n<p>Do not leak this from constructor; it could be disastrous in multi-threaded environment.</p>\n\n<p>-------------------------------</p>\n\n<p>For return types, it&#39;s valuable but using Optional on the input side increases the work you have to do in the method without really increasing the value. With an Optional parameter, you go from having 2 possible inputs: null and not-null, to three: null, non-null-without-value, and non-null-with-value. Add to that the fact that overloading has long been available to convey that some parameters are optional, and there&#39;s really no reason to have Optional parameters.</p>\n\n<p>-------------------------------</p>\n\n<p>The java.util.regex.Pattern.compile() methods have a significant performance cost, and therefore should be used sensibly.</p>\n\n<p>Moreover they are the only mechanism available to create instances of the Pattern class, which are necessary to do any pattern matching using regular expressions. Unfortunately that can be hidden behind convenience methods like String.matches() or String.split().</p>\n\n<p>---------------------</p>\n\n<p>Check enums using == rather than using equals; For Strings it is opposite;</p>\n\n<p>----------------------</p>\n\n<p>@ComponentScan is used to find which Spring @Component beans (@Service or @Repository or Controller) are available in the classpath so they can be used in the application context. This is a convenient feature especially when you begin a new project but it comes with the drawback of slowing down the application start-up time especially when the application becomes bigger (ie: it references a large JAR file, or it references a significant number of JAR files, or the base-package refers to a large amount of .class files).</p>\n\n<p>@ComponentScan should be replaced by an explicit list of Spring beans loaded by @Import.</p>\n\n<p>The interface @SpringBootApplication is also considered by this rule because it is annotated with @ComponentScan.</p>\n\n<p>---------------------</p>\n\n<p>&quot;@EnableAutoConfiguration&quot; is a convenient feature to configure the Spring Application Context by attempting to guess the beans that you are likely to need. The drawback is that it may load and configure beans the application will never use and therefore consume more CPU and RAM than really required. @EnableAutoConfiguration should be configured to exclude all the beans not required by the application. Alternatively, use the @Import annotation instead of @EnableAutoConfiguration, to explicitly import the useful AutoConfiguration classes.</p>\n\n<p>This rule applies for @SpringBootApplication as well.</p>\n\n<p>---------------------</p>\n\n<p>Code having side effects should be avoided</p>\n\n<p>e.g. if(++count){} //incremneting count while checking</p>\n\n<p>----------------------------<br />\nAccording to the official javadoc documentation, this Object.finalize() is called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Calling this method explicitly breaks this contract and so is misleading.</p>\n\n<p>The Object.finalize() method is called on an object by the garbage collector when it determines that there are no more references to the object. But there is absolutely no warranty that this method will be called AS SOON AS the last references to the object are removed. It can be few microseconds to few minutes later. So when system resources need to be disposed by an object, it&#39;s better to not rely on this asynchronous mechanism to dispose them.</p>\n\n<p>Overriding the Object.finalize() method must be done with caution to dispose some system resources.</p>\n\n<p>Calling the super.finalize() at the end of this method implementation is highly recommended in case parent implementations must also dispose some system resources.</p>\n\n<p>-------------------------</p>\n\n<p>Take care of hashCode and equals method when your classes are going to be used in collections directly or indirectly.</p>\n\n<p>-----------------------------</p>\n\n<p>Field injection seems like a tidy way to get your classes what they need to do their jobs, but it&#39;s really a NullPointerException waiting to happen unless all your class constructors are private. That&#39;s because any class instances that are constructed by callers, rather than instantiated by a Dependency Injection framework compliant with the JSR-330 (Spring, Guice, ...), won&#39;t have the ability to perform the field injection.</p>\n\n<p>Instead @Inject should be moved to the constructor and the fields required as constructor parameters.</p>\n\n<p>This rule raises an issue when classes with non-private constructors (including the default constructor) use field injection.</p>\n\n<p>---------------------------</p>\n\n<p>Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.</p>\n\n<p>For example:</p>\n\n<p>The subclass class constructor starts by contract by calling the parent class constructor.<br />\nThe parent class constructor calls the method, which has been overridden in the child class.<br />\nIf the behavior of the child class method depends on fields that are initialized in the child class constructor, unexpected behavior (like a NullPointerException) can result, because the fields aren&#39;t initialized yet.</p>\n\n<p>----------------------------</p>\n\n<p>A serialVersionUID field is strongly recommended in all Serializable classes. If you do not provide one, one will be calculated for you by the compiler. The danger in not explicitly choosing the value is that when the class changes, the compiler will generate an entirely new id, and you will be suddenly unable to deserialize (read from file) objects that were serialized with the previous version of the class.</p>\n\n<p>serialVersionUID&#39;s should be declared with all of these modifiers: static final long.</p>\n\n<p>But it should be used with caution; as when you forget to change this when class is refactored, then your old serialized objects would be considered valid, which should not happen.</p>\n\n<p>------------------------------</p>\n\n<p>A non-serializable Comparator can prevent an otherwise-Serializable ordered collection from being serializable. Since the overhead to make a Comparator serializable is usually low, doing so can be considered good defensive programming.</p>\n\n<p>-----------------------------</p>\n\n<p>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results.</p>\n\n<pre>\n<code class=\"language-java\">Noncompliant Code Example\npublic boolean isOdd(int x) {\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\n}\n//Compliant Solution\npublic boolean isOdd(int x) {\n  return x % 2 != 0;\n}</code></pre>\n\n<p>------------------------------</p>\n\n<p>Bean Validation as per defined by JSR 380 can be triggered programmatically or also executed by the Bean Validation providers. However something should tell the Bean Validation provider that a variable must be validated otherwise no validation will happen. This can be achieved by annotating a variable with javax.validation.Valid and unfortunally it&#39;s easy to forget to add this annotation on complex Beans.</p>\n\n<p>Not annotating a variable with @Valid means Bean Validation will not be triggered for this variable, but readers may overlook this omission and assume the variable will be validated.</p>\n\n<pre>\n<code class=\"language-java\"> @NotNull\n  // preferred style as of Bean Validation 2.0\n  private List&lt;@Valid User&gt; users2; // Compliant</code></pre>\n\n<p>------------------------------------</p>\n\n<p>The problem with invoking Thread.start() in a constructor is that you&#39;ll have a confusing mess on your hands if the class is ever extended because the superclass&#39; constructor will start the thread before the child class has truly been initialized.</p>\n\n<p>-------------------------------------</p>\n\n<p>Cloneable is the marker Interface that indicates that clone() may be called on an object. Overriding clone() without implementing Cloneable can be useful if you want to control how subclasses clone themselves, but otherwise, it&#39;s probably a mistake.</p>\n\n<p>The usual convention for Object.clone() according to Oracle&#39;s Javadoc is:</p>\n\n<pre>\n<code class=\"language-java\">x.clone() != x\nx.clone().getClass() == x.getClass()\nx.clone().equals\\(x\\)</code></pre>\n\n<p><br />\nObtaining the object that will be returned by calling super.clone() helps to satisfy those invariants:</p>\n\n<p>super.clone() returns a new object instance<br />\nsuper.clone() returns an object of the same type as the one clone() was called on<br />\nObject.clone() performs a shallow copy of the object&#39;s state</p>\n\n<p>-------------------------------------</p>\n\n<p>According to the Java Comparable.compareTo(T o) documentation:</p>\n\n<p>It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)).</p>\n\n<p>Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.</p>\n\n<p>The recommended language is &quot;Note: this class has a natural ordering that is inconsistent with equals.&quot;</p>\n\n<p>If this rule is violated, weird and unpredictable failures can occur.</p>\n\n<p>For example, in Java 5 the PriorityQueue.remove() method relied on compareTo(), but since Java 6 it has relied on equals().</p>\n\n<p>------------------------------------------</p>\n\n<p>Code by interfaces rather than implementations</p>\n\n<p>------------------------------------</p>\n\n<p>With Java 8&#39;s &quot;default method&quot; feature, any abstract class without direct or inherited field should be converted into an interface. However, this change may not be appropriate in libraries or other applications where the class is intended to be used as an API.</p>\n\n<p>------------------------------------</p>\n\n<p>When all the keys of a Map are values from the same enum, the Map can be replaced with an EnumMap, which can be much more efficient than other sets because the underlying data structure is a simple array.</p>\n\n<p>--------------------------------------</p>\n\n<p>Strings are immutable objects, so concatenation doesn&#39;t simply add the new String to the end of the existing string. Instead, in each loop iteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted back to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is preferred.</p>\n\n<p>------------------------------------</p>\n\n<p>If you are extending a class, and equals and hashCode has been overridden in superclass, then you need to override them&nbsp;</p>\n\n<p>-----------------------------------</p>\n\n<p>One thing that makes good code good is the clarity with which it conveys the intent of the original programmer to maintainers, and the proper choice of indexOf methods can help move code from confusing to clear.</p>\n\n<p>If you need to see whether a substring is located beyond a certain point in a string, you can test the indexOf the substring versus the target point, or you can use the version of indexOf which takes a starting point argument. The latter is arguably clearer because the result is tested against -1, which is an easily recognizable &quot;not found&quot; indicator.</p>\n\n<pre>\n<code class=\"language-java\">if (name.indexOf(\"ae\", 2) &gt; -1) {\n  // ...\n}</code></pre>\n\n<p>---------------------------------------</p>\n\n<p>Enabling Cross-Origin Resource Sharing (CORS) is security-sensitive. For example, it has led in the past to the following vulnerabilities:</p>\n\n<p>CVE-2018-0269<br />\nCVE-2017-14460<br />\nApplications that enable CORS will effectively relax the same-origin policy in browsers, which is in place to prevent AJAX requests to hosts other than the one showing in the browser address bar. Being too permissive, CORS can potentially allow an attacker to gain access to sensitive information.</p>\n\n<p>This rule flags code that enables CORS or specifies any HTTP response headers associated with CORS. The goal is to guide security code reviews.</p>\n\n<p>Ask Yourself Whether<br />\nAny URLs responding with Access-Control-Allow-Origin: * include sensitive content.<br />\nAny domains specified in Access-Control-Allow-Origin headers are checked against a whitelist.<br />\nRecommended Secure Coding Practices<br />\nThe Access-Control-Allow-Origin header should be set only on specific URLs that require access from other domains. Don&#39;t enable the header on the entire domain.<br />\nDon&#39;t rely on the Origin header blindly without validation as it could be spoofed by an attacker. Use a whitelist to check that the Origin domain (including protocol) is allowed before returning it back in the Access-Control-Allow-Origin header.<br />\nUse Access-Control-Allow-Origin: * only if your application absolutely requires it, for example in the case of an open/public API. For such endpoints, make sure that there is no sensitive content or information included in the response.</p>\n\n<p>-----------------------------------------</p>\n\n<p>Equals and hashCode should be used in pairs</p>\n\n<p>------------------------------------------</p>\n\n<p>When a Serializable object has a non-serializable ancestor in its inheritance chain, object deserialization (re-instantiating the object from file) starts at the first non-serializable class, and proceeds down the chain, adding the properties of each subsequent child class, until the final object has been instantiated.</p>\n\n<p>In order to create the non-serializable ancestor, its no-argument constructor is called. Therefore the non-serializable ancestor of a Serializable class must have a no-arg constructor. Otherwise the class is Serializable but not deserializable.</p>\n\n<p>-----------------------------------------</p>\n\n<p>Early classes of the Java API, such as Vector, Hashtable and StringBuffer, were synchronized to make them thread-safe. Unfortunately, synchronization has a big negative impact on performance, even when using these collections from a single thread.</p>\n\n<p>It is better to use their new unsynchronized replacements:</p>\n\n<p>ArrayList or LinkedList instead of Vector<br />\nDeque instead of Stack<br />\nHashMap instead of Hashtable<br />\nStringBuilder instead of StringBuffer</p>\n\n<p>----------------------------------------</p>\n\n<p>From the Java API documentation:</p>\n\n<p>Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.</p>\n\n<p>The purpose of implementing the Condition interface is to gain access to its more nuanced await methods. Therefore, calling the method Object.wait(...) on a class implementing the Condition interface is silly and confusing.</p>\n\n<p>----------------------------------------</p>\n\n<p>In applications where the accepted practice is to log an Exception and then rethrow it, you end up with miles-long logs that contain multiple instances of the same exception. In multi-threaded applications debugging this type of log can be particularly hellish because messages from other threads will be interwoven with the repetitions of the logged-and-thrown Exception. Instead, exceptions should be either logged or rethrown, not both.</p>\n\n<p>---------------------------------------</p>\n\n<p>A readObject method is written when a Serializable object needs special handling to be rehydrated from file. It should be the case that the object being created by readObject is only visible to the thread that invoked the method, and the synchronized keyword is not needed, and using synchronized anyway is just confusing. If this is not the case, the method should be refactored to make it the case.</p>\n\n<p>--------------------------------------</p>\n\n<p>Using Thread.sleep in a test is just generally a bad idea. It creates brittle tests that can fail unpredictably depending on environment (&quot;Passes on my machine!&quot;) or load. Don&#39;t rely on timing (use mocks) or use libraries such as Awaitility for asynchroneous testing.</p>\n\n<p>----------------------------------------</p>\n\n<pre>\n<code class=\"language-java\">@javax.annotation.ParametersAreNonnullByDefault\nclass A {\n\n  void foo() {\n    bar(getValue()); // Noncompliant - method 'bar' do not expect 'null' values as parameter\n                     // Either check for null or mark bar parameter as @Nullable\n  }\n\n  void bar(Object o) { // 'o' is by contract expected never to be null\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}</code></pre>\n\n<p>-------------------------------------------</p>\n\n<p>equals(MyClass ob){..} doesn&#39;t actually override the equals method.</p>\n\n<p>--------------------------------------------</p>\n\n<p>Objects which are pooled and potentially reused should not be used for synchronization. If they are, it can cause unrelated threads to deadlock with unhelpful stacktraces. Specifically, String literals, and boxed primitives such as Integers should not be used as lock objects because they are pooled and reused. The story is even worse for Boolean objects, because there are only two instances of Boolean, Boolean.TRUE and Boolean.FALSE and every class that uses a Boolean will be referring to one of the two.</p>\n\n<p>---------------------------------------------</p>\n\n<p>An Externalizable class is one which handles its own Serialization and deserialization. During deserialization, the first step in the process is a default instantiation using the class&#39; no-argument constructor. Therefore an Externalizable class without a no-arg constructor cannot be deserialized.</p>\n\n<p>----------------------------------------------</p>\n\n<p><br />\nWhen two locks are held simultaneously, a wait call only releases one of them. The other will be held until some other thread requests a lock on the awaited object. If no unrelated code tries to lock on that object, then all other threads will be locked out, resulting in a deadlock.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nsynchronized (this.mon1) {  // threadB can't enter this block to request this.mon2 lock &amp; release threadA\n    synchronized (this.mon2) {\n        this.mon2.wait();  // Noncompliant; threadA is stuck here holding lock on this.mon1\n    }\n}</code></pre>\n\n<p>-------------------------------------</p>\n\n<p>If Thread.sleep(...) is called when the current thread holds a lock, it could lead to performance and scalability issues, or even worse to deadlocks because the execution of the thread holding the lock is frozen. It&#39;s better to call wait(...) on the monitor object to temporarily release the lock and allow other threads to run.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      Thread.sleep(200);\n    }\n    process();\n  }\n  ...\n}\n//Compliant Solution\npublic void doSomething(){\n  synchronized(monitor) {\n    while(notReady()){\n      monitor.wait(200);\n    }\n    process();\n  }\n  ...\n}</code></pre>\n\n<p>-----------------------------------------</p>\n\n<p>The methods wait(...), notify() and notifyAll() are available on a Thread instance, but only because all classes in Java extend Object and therefore automatically inherit those methods. But there are two very good reasons for not calling them on a Thread:</p>\n\n<p>Internally, the JVM relies on these methods to change the state of the Thread (BLOCKED, WAITING, ...), so calling them will corrupt the behavior of the JVM.<br />\nIt is not clear (perhaps even to the original coder) what is really expected. For instance, it is waiting for the execution of the Thread to suspended, or is it the acquisition of the object monitor that is waited for?</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nThread myThread = new Thread(new RunnableJob());\n...\nmyThread.wait(2000);</code></pre>\n\n<p>-------------------------------------------</p>\n\n<p>According to the documentation of the Java Condition interface:</p>\n\n<p>When waiting upon a Condition, a &quot;spurious wakeup&quot; is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.</p>\n\n<p>The same advice is also found for the Object.wait(...) method:</p>\n\n<p>waits should always occur in loops, like this one:</p>\n\n<pre>\n<code class=\"language-java\">synchronized (obj) {\n  while (&lt;condition does not hold&gt;){\n    obj.wait(timeout);\n  }\n   ... // Perform action appropriate to condition\n}\n//Noncompliant Code Example\nsynchronized (obj) {\n  if (!suitableCondition()){\n    obj.wait(timeout);   //the thread can wake up even if the condition is still false\n  }\n   ... // Perform action appropriate to condition\n}\n//Compliant Solution\nsynchronized (obj) {\n  while (!suitableCondition()){\n    obj.wait(timeout);\n  }\n   ... // Perform action appropriate to condition\n}</code></pre>\n\n<p>---------------------------------------------</p>\n\n<p>According to Oracle Javadoc:</p>\n\n<p>IllegalMonitorStateException is thrown when a thread has attempted to wait on an object&#39;s monitor or to notify other threads waiting on an object&#39;s monitor without owning the specified monitor.</p>\n\n<p>In other words, this exception can be thrown only in case of bad design because Object.wait(...), Object.notify() and Object.notifyAll() methods should never be called on an object whose monitor is not held.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic void doSomething(){\n  ...\n  try {\n    ...\n    anObject.notify();\n    ...\n  } catch(IllegalMonitorStateException e) {\n    ...\n  }\n}\n\n//Compliant Solution\npublic void doSomething(){\n  ...\n  synchronized(anObject) {\n    ...\n    anObject.notify();\n    ...\n  }\n}</code></pre>\n\n<p>--------------------------------------------------</p>\n\n<p>When @Overrides of synchronized methods are not themselves synchronized, the result can be improper synchronization as callers rely on the thread-safety promised by the parent class.</p>\n\n<p>--------------------------------------------------</p>\n\n<p>According to the documentation,</p>\n\n<p>A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization...<br />\nThis is because value-based classes are intended to be wrappers for value types, which will be primitive-like collections of data (similar to structs in other languages) that will come in future versions of Java.</p>\n\n<p>Instances of a value-based class ...</p>\n\n<p>do not have accessible constructors, but are instead instantiated through factory methods which make no committment as to the identity of returned instances;<br />\nWhich means that you can&#39;t be sure you&#39;re the only one trying to lock on any given instance of a value-based class, opening your code up to contention and deadlock issues.</p>\n\n<p>Under Java 8 breaking this rule may not actually break your code, but there are no guarantees of the behavior beyond that.</p>\n\n<p>This rule raises an issue when a known value-based class is used for synchronization. That includes all the classes in the java.time package except Clock; the date classes for alternate calendars, HijrahDate, JapaneseDate, MinguoDate, ThaiBuddhistDate; and the optional classes: Optional, OptionalDouble, OptionalLong, OptionalInt.</p>\n\n<p>---------------------------------------------------</p>\n\n<p>Using compound operators as well as increments and decrements (and toggling, in the case of booleans) on primitive fields are not atomic operations. That is, they don&#39;t happen in a single step. For instance, when a volatile primitive field is incremented or decremented you run the risk of data loss if threads interleave in the steps of the update. Instead, use a guaranteed-atomic class such as AtomicInteger, or synchronize the access.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nprivate volatile int count = 0;\nprivate volatile boolean boo = false;\n\npublic void incrementCount() {\n  count++;  // Noncompliant\n}\n\npublic void toggleBoo(){\n  boo = !boo;  // Noncompliant\n}\n\n//Compliant Solution\nprivate AtomicInteger count = 0;\nprivate boolean boo = false;\n\npublic void incrementCount() {\n  count.incrementAndGet();\n}\n\npublic synchronized void toggleBoo() {\n  boo = !boo;\n}</code></pre>\n\n<p>------------------------------------------------------</p>\n\n<p>getClass should not be used for synchronization in non-final classes because child classes will synchronize on a different object than the parent or each other, allowing multiple threads into the code block at once, despite the synchronized keyword.</p>\n\n<p>Instead, hard code the name of the class on which to synchronize or make the class final.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (this.getClass()) {  // Noncompliant\n      // ...\n    }\n  }\n//Compliant Solution\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (MyClass.class) {\n      // ...\n    }\n  }</code></pre>\n\n<p><br />\n&nbsp;&nbsp;<br />\n---------------------------------------------------------</p>\n\n<p>When one part of a getter/setter pair is synchronized the other part should be too. Failure to synchronize both sides of a pair may result in inconsistent behavior at runtime as callers access an inconsistent method state.</p>\n\n<p>This rule raises an issue when either the method or the contents of one method in a getter/setter pair are synchrnoized but the other is not.</p>\n\n<p>---------------------------------------------------------</p>\n\n<p>Not all classes in the standard Java library were written to be thread-safe. Using them in a multi-threaded manner is highly likely to cause data problems or exceptions at runtime.</p>\n\n<p>This rule raises an issue when an instance of Calendar, DateFormat, javax.xml.xpath.XPath, or javax.xml.validation.SchemaFactory is marked static.</p>\n\n<p>---------------------------------------------------------</p>\n\n<p>notify and notifyAll both wake up sleeping threads, but notify only rouses one, while notifyAll rouses all of them. Since notify might not wake up the right thread, notifyAll should be used instead.</p>\n\n<p>--------------------------------------------------------</p>\n\n<p>Synchronizing on a class field synchronizes not on the field itself, but on the object assigned to it. So synchronizing on a non-final field makes it possible for the field&#39;s value to change while a thread is in a block synchronized on the old value. That would allow a second thread, synchronized on the new value, to enter the block at the same time.</p>\n\n<p>The story is very similar for synchronizing on parameters; two different threads running the method in parallel could pass two different object instances in to the method as parameters, completely undermining the synchronization.</p>\n\n<p>-------------------------------------------------------</p>\n\n<p>By contract, the method Object.wait(...), Object.notify() and Object.notifyAll() should be called by a thread that is the owner of the object&#39;s monitor. If this is not the case an IllegalMonitorStateException exception is thrown. This rule reinforces this constraint by making it mandatory to call one of these methods only inside a synchronized method or statement.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nprivate void removeElement() {\n  while (!suitableCondition()){\n    obj.wait();\n  }\n  ... // Perform removal\n}\nor\n\nprivate void removeElement() {\n  while (!suitableCondition()){\n    wait();\n  }\n  ... // Perform removal\n}\n\n//Compliant Solution\nprivate void removeElement() {\n  synchronized(obj) {\n    while (!suitableCondition()){\n      obj.wait();\n    }\n    ... // Perform removal\n  }\n}\nor\n\nprivate synchronized void removeElement() {\n  while (!suitableCondition()){\n    wait();\n  }\n  ... // Perform removal\n}</code></pre>\n\n<p>--------------------------------------------------<br />\nAtomicInteger, and AtomicLong extend Number, but they&#39;re distinct from Integer and Long and should be handled differently. AtomicInteger and AtomicLong are designed to support lock-free, thread-safe programming on single variables. As such, an AtomicInteger will only ever be &quot;equal&quot; to itself. Instead, you should .get() the value and make comparisons on it.</p>\n\n<p>This applies to all the atomic, seeming-primitive wrapper classes: AtomicInteger, AtomicLong, and AtomicBoolean.</p>\n\n<p>--------------------------------------------------</p>\n\n<p>InterruptedExceptions should never be ignored in the code, and simply logging the exception counts in this case as &quot;ignoring&quot;. The throwing of the InterruptedException clears the interrupted state of the Thread, so if the exception is not handled properly the fact that the thread was interrupted will be lost. Instead, InterruptedExceptions should either be rethrown - immediately or after cleaning up the method&#39;s state - or the thread should be re-interrupted by calling Thread.interrupt() even if this is supposed to be a single-threaded application. Any other course of action risks delaying thread shutdown and loses the information that the thread was interrupted - probably without finishing its task.</p>\n\n<p>Similarly, the ThreadDeath exception should also be propagated. According to its JavaDoc:</p>\n\n<p>If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic void run () {\n  try {\n    while (true) {\n      // do stuff\n    }\n  }catch (InterruptedException e) { // Noncompliant; logging is not enough\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n  }\n}\n\n//Compliant Solution\npublic void run () {\n  try {\n    while (true) {\n      // do stuff\n    }\n  }catch (InterruptedException e) {\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    // Restore interrupted state...\n    Thread.currentThread().interrupt();\n  }\n}</code></pre>\n\n<p>--------------------------------------------------------</p>\n\n<p>According to the Java API documentation:</p>\n\n<p>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started...</p>\n\n<p>The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.</p>\n\n<p>By definition, extending the Thread class without overriding the run method doesn&#39;t make sense, and implies that the contract of the Thread class is not well understood.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic class MyRunner extends Thread { // Noncompliant; run method not overridden\n\n  public void doSometing() {...}\n}</code></pre>\n\n<p><br />\nExceptions<br />\nIf run() is not overridden in a class extending Thread, it means that starting the thread will actually call Thread.run(). However, Thread.run() does nothing if it has not been fed with a target Runnable. The rule consequently ignore classes extending Thread if they are calling, in their constructors, the super(...) constructor with a proper Runnable target.</p>\n\n<pre>\n<code class=\"language-java\">class MyThread extends Thread { // Compliant - calling super constructor with a Runnable\n  MyThread(Runnable target) {\n    super(target); // calling super constructor with a Runnable, which will be used for when Thread.run() is executed\n    // ...\n  }\n}</code></pre>\n\n<p>---------------------------------------------------------</p>\n\n<p>The purpose of the Thread.run() method is to execute code in a separate, dedicated thread. Calling this method directly doesn&#39;t make sense because it causes its code to be executed in the current thread.</p>\n\n<p>To get the expected behavior, call the Thread.start() method instead.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nThread myThread = new Thread(runnable);\nmyThread.run(); // Noncompliant\n//Compliant Solution\nThread myThread = new Thread(runnable);\nmyThread.start(); // Compliant</code></pre>\n\n<p>------------------------------------------------------------</p>\n\n<p>java.util.concurrent.locks.Lock offers far more powerful and flexible locking operations than are available with synchronized blocks. So synchronizing on a Lock throws away the power of the object, and is just silly. Instead, such objects should be locked and unlocked using tryLock() and unlock().</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nLock lock = new MyLockImpl();\nsynchronized(lock) {  // Noncompliant\n  //...\n}\nCompliant Solution\nLock lock = new MyLockImpl();\nlock.tryLock();\n//...</code></pre>\n\n<p>------------------------------------------------------------</p>\n\n<p>The problem with invoking Thread.start() in a constructor is that you&#39;ll have a confusing mess on your hands if the class is ever extended because the superclass&#39; constructor will start the thread before the child class has truly been initialized.</p>\n\n<p>This rule raises an issue any time start is invoked in the constructor of a non-final class.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic class MyClass {\n\n  Thread thread = null;\n\n  public MyClass(Runnable runnable) {\n    thread = new Thread(runnable);\n    thread.start(); // Noncompliant\n  }\n}</code></pre>\n\n<p>---------------------------------------------------------</p>\n\n<p>----------------------------------------------</p>\n\n<p>When using Spring proxies, calling a method in the same class (e.g. this.aMethod()) with an incompatible @Transactional requirement will result in runtime exceptions because Spring only &quot;sees&quot; the caller and makes no provisions for properly invoking the callee.</p>\n\n<p>Therefore, certain calls should never be made within the same class:From&nbsp;&nbsp; &nbsp;To<br />\nnon-@Transactional&nbsp;&nbsp; &nbsp;MANDATORY, NESTED, REQUIRED, REQUIRES_NEW<br />\nMANDATORY&nbsp;&nbsp; &nbsp;NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW<br />\nNESTED&nbsp;&nbsp; &nbsp;NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW<br />\nNEVER&nbsp;&nbsp; &nbsp;MANDATORY, NESTED, REQUIRED, REQUIRES_NEW<br />\nNOT_SUPPORTED&nbsp;&nbsp; &nbsp;MANDATORY, NESTED, REQUIRED, REQUIRES_NEW<br />\nREQUIRED or @Transactional&nbsp;&nbsp; &nbsp;NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW<br />\nREQUIRES_NEW&nbsp;&nbsp; &nbsp;NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW<br />\nSUPPORTS&nbsp;&nbsp; &nbsp;MANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\n\n@Override\npublic void doTheThing() {\n  // ...\n  actuallyDoTheThing();  // Noncompliant\n}\n\n@Override\n@Transactional\npublic void actuallyDoTheThing() {\n  // ...\n}</code></pre>\n\n<p>--------------------------------------------------</p>\n\n<p>Double-checked locking is the practice of checking a lazy-initialized object&#39;s state both before and after a synchronized block is entered to determine whether or not to initialize the object.</p>\n\n<p>It does not work reliably in a platform-independent manner without additional synchronization for mutable instances of anything other than float or int. Using double-checked locking for the lazy initialization of any other type of primitive or mutable object risks a second thread using an uninitialized or partially initialized member while the first thread is still creating it, and crashing the program.</p>\n\n<p>There are multiple ways to fix this. The simplest one is to simply not use double checked locking at all, and synchronize the whole method instead. With early versions of the JVM, synchronizing the whole method was generally advised against for performance reasons. But synchronized performance has improved a lot in newer JVMs, so this is now a preferred solution. If you prefer to avoid using synchronized altogether, you can use an inner static class to hold the reference instead. Inner static classes are guaranteed to load lazily.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\n@NotThreadSafe\npublic class DoubleCheckedLocking {\n    private static Resource resource;\n\n    public static Resource getInstance() {\n        if (resource == null) {\n            synchronized (DoubleCheckedLocking.class) {\n                if (resource == null)\n                    resource = new Resource();\n            }\n        }\n        return resource;\n    }\n\n    static class Resource {\n\n    }\n}\n\n//Compliant Solution\n@ThreadSafe\npublic class SafeLazyInitialization {\n    private static Resource resource;\n\n    public synchronized static Resource getInstance() {\n        if (resource == null)\n            resource = new Resource();\n        return resource;\n    }\n\n    static class Resource {\n    }\n}</code></pre>\n\n<p>-----------------------------------------------</p>\n\n<p>Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, AutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise an exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using &quot;try-with-resources&quot; pattern and will be closed automatically.</p>\n\n<p>Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box it&#39;s on to their knees.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nprivate void readTheFile() throws IOException {\n  Path path = Paths.get(this.fileName);\n  BufferedReader reader = Files.newBufferedReader(path, this.charset);\n  // ...\n  reader.close();  // Noncompliant\n  // ...\n  Files.lines(\"input.txt\").forEach(System.out::println); // Noncompliant: The stream needs to be closed\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    for (String property : propertyList) {\n      stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();  // Multiple streams were opened. Only the last is closed.\n  }\n}\n\n//Compliant Solution\nprivate void readTheFile(String fileName) throws IOException {\n    Path path = Paths.get(fileName);\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n      reader.readLine();\n      // ...\n    }\n    // ..\n    try (Stream&lt;String&gt; input = Files.lines(\"input.txt\"))  {\n      input.forEach(System.out::println);\n    }\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    stream = new FileOutputStream(\"myfile.txt\");\n    for (String property : propertyList) {\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();\n  }\n}</code></pre>\n\n<p><br />\nExceptions<br />\nInstances of the following classes are ignored by this rule because close has no effect:</p>\n\n<pre>\n<code class=\"language-java\">java.io.ByteArrayOutputStream\njava.io.ByteArrayInputStream\njava.io.CharArrayReader\njava.io.CharArrayWriter\njava.io.StringReader\njava.io.StringWriter\nJava 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources statement are ignored by this rule.\n\ntry (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n  //...\n}\ncatch ( ... ) {\n  //...\n}</code></pre>\n\n<p>-----------------------------------------------</p>\n\n<p>If a lock is acquired and released within a method, then it must be released along all execution paths of that method.</p>\n\n<p>Failing to do so will expose the conditional locking logic to the method&#39;s callers and hence be deadlock-prone.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\npublic class MyClass {\n  private Lock lock = new Lock();\n\n  public void doSomething() {\n    lock.lock(); // Noncompliant\n    if (isInitialized()) {\n      // ...\n      lock.unlock();\n    }\n  }\n}\n\n//Compliant Solution\npublic class MyClass {\n  private Lock lock = new Lock();\n\n  public void doSomething() {\n    if (isInitialized()) {\n      lock.lock();\n      // ...\n      lock.unlock();\n    }\n  }\n}</code></pre>\n\n<p>----------------------------------------------</p>\n\n<p>Constructors for String, BigInteger, BigDecimal and the objects used to wrap primitives should never be used. Doing so is less clear and uses more memory than simply using the desired value in the case of strings, and using valueOf for everything else.</p>\n\n<p>------------------------------------------------</p>\n\n<p>The equals and hashCode methods of java.net.URL both may trigger a name service (usually DNS) lookup to resolve the host name or IP address. Depending on the configuration, and network status, that can take a long time. URI on the other hand makes no such calls and should be used instead unless the specific URL functionality is required.</p>\n\n<p>In general it is better to use the URI class until access to the resource is actually needed, at which point you can just convert the URI to a URL using URI.toURL().</p>\n\n<p>-----------------------------------------------</p>\n\n<p>Public class variable fields do not respect the encapsulation principle and has three main disadvantages:</p>\n\n<p>Additional behavior such as validation cannot be added.<br />\nThe internal representation is exposed, and cannot be changed afterwards.<br />\nMember values are subject to change from anywhere in the code and may not meet the programmer&#39;s assumptions.<br />\nBy using private attributes and accessor methods (set and get), unauthorized modifications are prevented.</p>\n\n<p>-----------------------------------------------</p>\n\n<p>The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to create hash collisions with them. That is, it takes too little computational effort to come up with a different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an attacker the same access as if he had the originally-hashed value. This applies as well to the other Message-Digest algorithms: MD2, MD4, MD6, HAVAL-128, HMAC-MD5, DSA (which uses SHA-1), RIPEMD, RIPEMD-128, RIPEMD-160, HMACRIPEMD160.</p>\n\n<p>The following APIs are tracked for use of obsolete crypto algorithms:</p>\n\n<p>* java.security.AlgorithmParameters (JDK)</p>\n\n<p>* java.security.AlgorithmParameterGenerator (JDK)</p>\n\n<p>* java.security.MessageDigest (JDK)</p>\n\n<p>* java.security.KeyFactory (JDK)</p>\n\n<p>* java.security.KeyPairGenerator (JDK)</p>\n\n<p>* java.security.Signature (JDK)</p>\n\n<p>* javax.crypto.Mac (JDK)</p>\n\n<p>* javax.crypto.KeyGenerator (JDK)</p>\n\n<p>* org.apache.commons.codec.digest.DigestUtils (Apache Commons Codec)</p>\n\n<p>* com.google.common.hash.Hashing (Guava)</p>\n\n<p>* org.springframework.security.authentication.encoding.ShaPasswordEncoder (Spring Security 4.2.x)</p>\n\n<p>* org.springframework.security.authentication.encoding.Md5PasswordEncoder (Spring Security 4.2.x)</p>\n\n<p>* org.springframework.security.crypto.password.LdapShaPasswordEncoder (Spring Security 5.0.x)</p>\n\n<p>* org.springframework.security.crypto.password.Md4PasswordEncoder (Spring Security 5.0.x)</p>\n\n<p>* org.springframework.security.crypto.password.MessageDigestPasswordEncoder (Spring Security 5.0.x)</p>\n\n<p>* org.springframework.security.crypto.password.NoOpPasswordEncoder (Spring Security 5.0.x)</p>\n\n<p>* org.springframework.security.crypto.password.StandardPasswordEncoder (Spring Security 5.0.x)</p>\n\n<p>Consider using safer alternatives, such as SHA-256, SHA-3 or adaptive one way functions like bcrypt or PBKDF2.</p>\n\n<p>----------------------------------------------------</p>\n\n<p>javax.net.ssl.SSLContext.getInstance returns a SSLContext object that implements the specified secure socket protocol. However, not all protocols are created equal and some legacy ones like &quot;SSL&quot;, have been proven to be insecure.</p>\n\n<p>This rule raises an issue when an SSLContext is created with an insecure protocol (ie: a protocol different from &quot;TLS&quot;, &quot;DTLS&quot;, &quot;TLSv1.2&quot;, &quot;DTLSv1.2&quot;, &quot;TLSv1.3&quot;, &quot;DTLSv1.3&quot;).</p>\n\n<p>The recommended value is &quot;TLS&quot; or &quot;DTLS&quot; as it will always use the latest version of the protocol. However an issue will be raised if the bytecode was compiled with JDK7 or an even older version of JDK because they are not alias for TLSv1.2 and DTLSv1.2 but for weaker protocols.</p>\n\n<p>Note that calling SSLContext.getInstance(...) with &quot;TLSv1.2&quot; or &quot;DTLSv1.2&quot; doesn&#39;t prevent protocol version negotiation. For example, if a client connects with &quot;TLSv1.1&quot; and the server used SSLContext.getInstance(&quot;TLSv1.2&quot;), the connection will use &quot;TLSv1.1&quot;. It is possible to enable only specific protocol versions by calling setEnabledProtocols on SSLSocket, SSLServerSocket or SSLEngine. However this should be rarely needed as clients usually ask for the most secure protocol supported.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\ncontext = SSLContext.getInstance(\"SSL\"); // Noncompliant\nCompliant Solution\ncontext = SSLContext.getInstance(\"TLSv1.2\");</code></pre>\n\n<p>-------------------------------------------------------</p>\n\n<p>Empty implementations of the X509TrustManager interface are often created to allow connection to a host that is not signed by a root certificate authority. Such an implementation will accept any certificate, which leaves the application vulnerable to Man-in-the-middle attacks. The correct solution is to provide an appropriate trust store.</p>\n\n<p>This rule raises an issue when an implementation of X509TrustManager never throws exception.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nclass TrustAllManager implements X509TrustManager {\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {  // Noncompliant, nothing means trust any client\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { \n    // Noncompliant, this method never throws exception, it means trust any client\n        LOG.log(Level.SEVERE, ERROR_MESSAGE);\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return null;\n    }\n}</code></pre>\n\n<p>---------------------------------------------------------</p>\n\n<p>User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. A remote server making requests to URLs based on tainted data could enable attackers to make arbitrary requests to the internal network or to the local file system.</p>\n\n<p>The problem could be mitigated in any of the following ways:</p>\n\n<p>Validate the user provided data based on a whitelist and reject input not matching.<br />\nRedesign the application to not send requests based on user provided data.</p>\n\n<p>-----------------------------------------------------------</p>\n\n<p>According to the Oracle Java API, the HttpServletRequest.getRequestedSessionId() method:</p>\n\n<p>Returns the session ID specified by the client. This may not be the same as the ID of the current valid session for this request. If the client did not specify a session ID, this method returns null.</p>\n\n<p>The session ID it returns is either transmitted in a cookie or a URL parameter so by definition, nothing prevents the end-user from manually updating the value of this session ID in the HTTP request.</p>\n\n<p>Here is an example of a updated HTTP header:</p>\n\n<pre>\n<code class=\"language-bash\">GET /pageSomeWhere HTTP/1.1\nHost: webSite.com\nUser-Agent: Mozilla/5.0\nCookie: JSESSIONID=Hacked_Session_Value'''\"&gt;</code></pre>\n\n<p><br />\nDue to the ability of the end-user to manually change the value, the session ID in the request should only be used by a servlet container (E.G. Tomcat or Jetty) to see if the value matches the ID of an an existing session. If it does not, the user should be considered unauthenticated. Moreover, this session ID should never be logged to prevent hijacking of active sessions.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nif(isActiveSession(request.getRequestedSessionId()) ){\n  ...\n}</code></pre>\n\n<p>------------------------------------------------------------</p>\n\n<p>An un-authenticated LDAP connection can lead to transactions without access control. Authentication, and with it, access control, are the last line of defense against LDAP injections and should not be disabled.</p>\n\n<p>This rule raises an issue when an LDAP connection is created with Context.SECURITY_AUTHENTICATION set to &quot;none&quot;.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\n// Set up the environment for creating the initial context\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=JNDITutorial\");\n\n// Use anonymous authentication\nenv.put(Context.SECURITY_AUTHENTICATION, \"none\"); // Noncompliant\n\n// Create the initial context\nDirContext ctx = new InitialDirContext(env);\n\n//Compliant Solution\n// Set up the environment for creating the initial context\nHashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\nenv.put(Context.PROVIDER_URL, \"ldap://localhost:389/o=JNDITutorial\");\n\n// Use simple authentication\nenv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\nenv.put(Context.SECURITY_PRINCIPAL, \"cn=S. User, ou=NewHires, o=JNDITutorial\");\nenv.put(Context.SECURITY_CREDENTIALS, getLDAPPassword());\n\n// Create the initial context\nDirContext ctx = new InitialDirContext(env);</code></pre>\n\n<p>----------------------------------------------------------</p>\n\n<p>An XML External Entity or XSLT External Entity (XXE) vulnerability can occur when a javax.xml.transform.Transformer is created without enabling &quot;Secure Processing&quot; or when one is created without disabling external DTDs. If that external entity is hijacked by an attacker it may lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.</p>\n\n<p>This rule raises an issue when a Transformer is created without either of these settings.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nTransformer transformer = TransformerFactory.newInstance().newTransformer();\ntransformer.transform(input, result);\n\n//Compliant Solution\nTransformerFactory factory = TransformerFactory.newInstance();\nfactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\nTransformer transformer = factory.newTransformer();\ntransformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\ntransformer.transform(input, result);\nor\n\nTransformerFactory factory = TransformerFactory.newInstance();\nfactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\nfactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n\nTransformer transformer = factory.newTransformer();\ntransformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\ntransformer.transform(input, result);</code></pre>\n\n<p>--------------------------------------------------</p>\n\n<p>URL patterns configured on a HttpSecurity.authorizeRequests() method are considered in the order they were declared. It&#39;s easy to do a mistake and to declare a less restrictive configuration before a more restrictive one. Therefore, it&#39;s required to review the order of the &quot;antMatchers&quot; declarations. The /** one should be the last one if it is declared.</p>\n\n<p>This rule raises an issue when:</p>\n\n<p>- A pattern is preceded by another that ends with ** and has the same beginning. E.g.: /page*-admin/db/** is after /page*-admin/**</p>\n\n<p>- A pattern without wildcard characters is preceded by another that matches. E.g.: /page-index/db is after /page*/**</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll() // Compliant\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n      .antMatchers(\"/admin/login\").permitAll() // Noncompliant; the pattern \"/admin/login\" should occurs before \"/admin/**\"\n      .antMatchers(\"/**\", \"/home\").permitAll()\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\") // Noncompliant; the pattern \"/db/**\" should occurs before \"/**\"\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }\n\n//Compliant Solution\n  protected void configure(HttpSecurity http) throws Exception {\n    http.authorizeRequests()\n      .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll() // Compliant\n      .antMatchers(\"/admin/login\").permitAll()\n      .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") // Compliant\n      .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\")\n      .antMatchers(\"/**\", \"/home\").permitAll() // Compliant; \"/**\" is the last one\n      .and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n  }</code></pre>\n\n<p><br />\n&nbsp;&nbsp;<br />\n---------------------------------------------------------</p>\n\n<p>&nbsp; On one side, Spring MVC automatically bind request parameters to beans declared as arguments of methods annotated with @RequestMapping. Because of this automatic binding feature, it&#39;s possible to feed some unexpected fields on the arguments of the @RequestMapping annotated methods.</p>\n\n<p>On the other end, persistent objects (@Entity or @Document) are linked to the underlying database and updated automatically by a persistence framework, such as Hibernate, JPA or Spring Data MongoDB.</p>\n\n<p>These two facts combined together can lead to malicious attack: if a persistent object is used as an argument of a method annotated with @RequestMapping, it&#39;s possible from a specially crafted user input, to change the content of unexpected fields into the database.</p>\n\n<p>For this reason, using @Entity or @Document objects as arguments of methods annotated with @RequestMapping should be avoided.</p>\n\n<p>In addition to @RequestMapping, this rule also considers the annotations introduced in Spring Framework 4.3: @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping.</p>\n\n<p>----------------------------------------------------------</p>\n\n<p>Evaluating regular expressions against input strings can be an extremely CPU-intensive task. For example, a specially crafted regular expression such as (a+)++ will take several seconds to evaluate the input string, aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!. The problem is that every additional &quot;a&quot; added to the input doubles the time required to evaluate the regex. However, the equivalent regular expression, a (without grouping), is efficiently evaluated in milliseconds and scales linearly with the input size.</p>\n\n<p>Evaluating user-provided strings as regular expressions opens the door for Denial Of Service attacks. In the context of a web application, attackers can force the web server to spend all of its resources evaluating regular expressions thereby making the service inaccessible to genuine users.</p>\n\n<p>----------------------------------------------------------</p>\n\n<p>Allowing external entities in untrusted documents to be processed could lay your systems bare to attackers. Imagine if these entities were parsed:</p>\n\n<pre>\n<code class=\"language-xml\">&lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n&lt;!ENTITY xxe SYSTEM \"http://www.attacker.com/text.txt\" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre>\n\n<p><br />\nIf you must parse untrusted XML, the best way to protect yourself is to use a local, static DTD during parsing and igore any DTD&#39;s included in included in the document.</p>\n\n<p>This rule raises an issue when any of the following are used without first disabling external entity processing: javax.xml.validation.Validator, JAXP&#39;s DocumentBuilderFactory, SAXParserFactory, Xerces 1 and Xerces 2 StAX&#39;s XMLInputFactory and XMLReaderFactory.</p>\n\n<p>To disable external entity processing for XMLInputFactory, configure one of the properties XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES or XMLInputFactory.SUPPORT_DTD to false.</p>\n\n<p>To disable external entity processing for SAXParserFactory, XMLReader or DocumentBuilderFactory configure one of the features XMLConstants.FEATURE_SECURE_PROCESSING or &quot;http://apache.org/xml/features/disallow-doctype-decl&quot; to true.</p>\n\n<p>To disable external entity processing for Validator, configure both properties XMLConstants.ACCESS_EXTERNAL_DTD, XMLConstants.ACCESS_EXTERNAL_SCHEMA to the empty string &quot;&quot;.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\n/* Load XML stream and display content */\nString maliciousSample = \"xxe.xml\";\nXMLInputFactory factory = XMLInputFactory.newInstance();\n\ntry (FileInputStream fis = new FileInputStream(malicousSample)) {\n  // Load XML stream\n  XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(fis);  // Noncompliant; reader is vulnerable\n\n  \n//Compliant Solution\n/* Load XML stream and display content */\nString maliciousSample = \"xxe.xml\";\nXMLInputFactory factory = XMLInputFactory.newInstance();\n\n// disable external entities\nfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\nfactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n\ntry (FileInputStream fis = new FileInputStream(malicousSample)) {\n    // Load XML stream\n    XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(fis);</code></pre>\n\n<p><br />\n----------------------------------------------------------</p>\n\n<p>User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Endpoints reflecting back tainted data could allow attackers to inject code that would eventually be executed in the user&#39;s browser. This could enable a wide range of serious attacks like accessing/modifying sensitive information or impersonating other users.</p>\n\n<p>Typically, the solution is one of the following:</p>\n\n<p>Validate user provided data based on a whitelist and reject input that&#39;s not whitelisted.<br />\nSanitize user provided data from any characters that can be used for malicious purposes.<br />\nEncode user provided data being reflected as output. Adjust the encoding to the output context so that, for example, HTML encoding is used for HTML content, HTML attribute encoding is used for attribute values, and JavaScript encoding is used for server-generated JavaScript.<br />\nWhen sanitizing or encoding data, it is recommended to only use libraries specifically designed for security purposes. Also, make sure that the library you are using is being actively maintained and is kept up-to-date with the latest discovered vulnerabilities.</p>\n\n<pre>\n<code class=\"language-java\">//Noncompliant Code Example\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n  String name = req.getParameter(\"name\");\n  PrintWriter out = resp.getWriter();\n  out.write(\"Hello \" + name); // Noncompliant\n}\n//Compliant Solution\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n  String name = req.getParameter(\"name\");\n  String encodedName = org.owasp.encoder.Encode.forHtml(name);\n  PrintWriter out = resp.getWriter();\n  out.write(\"Hello \" + encodedName);\n}</code></pre>\n\n<p>---------------------------------------------------------------</p>\n\n<p>User provided data, such as URL parameters, POST data payloads or cookies, should always be considered untrusted and tainted. Applications logging tainted data could enable an attacker to inject characters that would break the log file pattern. This could be used to block monitors and SIEM (Security Information and Event Management) systems from detecting other malicious events.</p>\n\n<p>This problem could be mitigated by sanitizing the user provided data before logging it.</p>\n\n<p>--------------------------------------------------------------</p>\n","authorId":null,"subject":"linked-to-143","tags":null,"img":null,"summary":"Writing clean, readable and maintainable should be your priority along with getting things done, otherwise you will regret later.","lastUpdated":"2020-08-19T11:59:47.550+0000"}