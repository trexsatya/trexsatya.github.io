{"name": "Design Patterns", "id": 69, "content": "<p>Design Patterns are proven solutions to common problems in Software Designing. But Remember: You can not and you should not always use the design patterns the way you read somewhere, <strong>without thinking about it.</strong></p>\n\n<p>First coined in a book named Design Patterns written by 4 authors. The book presented 23 Design patterns. That is 23 types of problems that you are likely to face if you are designing a software system. But what&#39;s interesting is that this book was also criticised much as it was praised. 16 out 23 of these patterns are no longer needed (or at least don&#39;t have to do much work to implement them) if you use language like Lisp or Dylan.</p>\n\n<p>So the thing is that these could/should have been part of the Java language itself, but they are not.</p>\n\n<p>This article is a summary of Design Patterns in more of a practical approach. For detailed theoretical explanations about each of the design pattern presented here, refer:&nbsp;<a href=\"https://github.com/iluwatar/java-design-patterns\" target=\"_blank\">this github link</a></p>\n\n<p>Note: Examples here are in Java language.</p>\n\n<h2>Types of Design Patterns</h2>\n\n<p>Based on the purpose and problem areas, 3 major types of design patterns are there:&nbsp;</p>\n\n<ol>\n\t<li>&nbsp;Creational: useful when you are creating objects</li>\n\t<li>&nbsp;Structural: When you are accessing objects, connecting them.</li>\n\t<li>&nbsp;Behavioural: When you are making decisions in your program</li>\n</ol>\n\n<p><u><a href=\"https://en.wikipedia.org/wiki/Design_Patterns#cite_note-Hannemann_2002-6\" target=\"_blank\">List Of Types on Wikipedia</a></u></p>\n\n<h2>Factory method, Factory and Abstract Factory Patterns</h2>\n\n<p>When you need an object of some type, you have the following options to get&nbsp;it:</p>\n\n<ol>\n\t<li>Create by yourself. (Using new operator, but then you are kind of hardcoding the creational logic)</li>\n\t<li>Ask some other object for it. ==&gt; <span style=\"color:#330099;\">Factory method pattern</span></li>\n\t<li>Ask yourself to create, or your child to create it. ==&gt; <span style=\"color:#330099;\">Factory&nbsp;pattern</span></li>\n\t<li>Ask some factory to create it. ==&gt; <span style=\"color:#330099;\">Abstract Factory pattern</span>.<br />\n\tRemember, there are very few examples of Abstract Factory pattern in standard libraries, probably because most situations can be easily handled with Factory pattern in combination with other design approaches.</li>\n</ol>\n\n<pre>\n<code class=\"language-java\">\npublic class Example {\n    interface OneWhoCanCreateSomething {\n       Something createSomething();\n    }\n\n    interface OneWhoCanCreateCreatorsOfSomething {\n       OneWhoCanCreateSomething getCreator();\n    }\n\n    //This can be overridden by child class to return maybe different flavor of \"something\".\n    protected Something createSomething(){\n       return Something(){..};\n    }\n\n    public optionsForGettingSomething() {\n        //You need \"something\"\n        //Just create one\n        Something something = new Something() {};\n\n        //You can use factory pattern\n        something = createSomething();\n\n        //Or, you can use factory method pattern\n        OneWhoCanCreateSomething oneWhoCanCreateSomethingOfTypeA = () -&gt; newA;\n        something = oneWhoCanCreateSomethingOfTypeA.createSomething();\n\n        OneWhoCanCreateSomething oneWhoCanCreateSomethingOfTypeB = () -&gt; newB;\n\n        //Or, you could use abstract factory pattern\n        OneWhoCanCreateCreatorsOfSomething oneWhoCanCreateCreatorsOfSomething = () -&gt; null;\n        something = oneWhoCanCreateCreatorsOfSomething.createCreator().createSomething();\n\n        //Factory method in Java8 functional interfaces\n        Supplier&lt;Something&gt; supplierOfSomething = () -&gt; null;\n        //Abstract Factory in Java 8\n        Supplier&lt;Supplier&lt;Something&gt;&gt; supplierOfSupplier = () -&gt; null;\n    }\n\n}</code></pre>\n\n<p><br />\nExample of advantage that Factory method provides -</p>\n\n<p>DriverManager is a class in sql package of standard Java. It&#39;s like a service used to manage JDBC drivers. This class loads drivers specified in file &quot;META-INF/services/java.sql.Driver&quot;. When you want a connection, you call getConnection(String url) and DriverManager parses the URL and uses the suitable driver (whichever can understand the given URL).</p>\n\n<p>DriverManager.getConnection() determines which implementation of java.sql.Connection to use on its own discretion without breaking client code. This factory method can also get the connection from the pool instead of creating a new one.</p>\n\n<p>Examples of AbstractFactory in standard libraries:</p>\n\n<pre>\n<code class=\"language-java\"> abstract class javax.xml.transform.TransformerFactory {\n       TransformerFactory newInstance();\n       Transformer newTransformer();\n } // A System property determines the which concrete implementation to return\n\nabstract class javax.xml.parsers.DocumentBuilderFactory {\n       DocumentBuilderFactory newInstance();\n       DocumentBuilder newDocumentBuilder();\n }\n\n//Here one interface is acting as both OneWhoCanProvideCreatorsOfSomething, and OneWhoCanProvideSomething</code></pre>\n\n<p>Spring provides a pattern for creating beans, which resembles Factory pattern</p>\n\n<pre>\n<code class=\"language-java\">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;{\n   private String make; \n   private int year ;\n   public Car getObject(){ \n     //Create, configure, inject dependencies, and return created object\n     \n   }\n   public Class&lt;Car&gt; getObjectType() { return Car.class ; } \n\n   public boolean isSingleton() { return false; }\n}\n//Note: Spring will not manage the created object, just the MyCarFactoryBean instance\n//What's the benefit you may ask?\n  //It is that you can hide the complexity of object creation based on the configuration, environment etc.</code></pre>\n\n<h2><br />\nBuilder Pattern</h2>\n\n<p>This pattern too is an alternative to messy constructor calls. When you want to specify the parts and then assemble them to create the object. The benefits of doing this is that you can construct and return different variants of the required object type (different subclasses) based on the specified parts (bits).<br />\nThis also makes it easier to perform validation before the creation of the object. This pattern is increasingly used in standard libraries and modern application codebases.&nbsp;</p>\n\n<p>An example from Java SE 9. Here DataSource (an interface) acts as a builder, which creates appropriate Connection (interface) object.</p>\n\n<pre>\n<code class=\"language-java\"> java.sql.DataSource ds = new MyDataSource();\n ShardingKey superShardingKey = ds.createShardingKeyBuilder()\n\t\t\t\t\t   .subkey(\"EASTERN_REGION\", JDBCType.VARCHAR)\n\t\t\t\t\t   .build();\n ShardingKey shardingKey = ds.createShardingKeyBuilder()\n\t\t\t\t\t   .subkey(\"PITTSBURGH_BRANCH\", JDBCType.VARCHAR)\n\t\t\t\t\t   .build();\n Connection con = ds.createConnectionBuilder()\n\t\t\t\t   .user(\"rafa\")\n\t\t\t\t   .password(\"tennis\")\n\t\t\t\t   .setShardingKey(shardingKey)\n\t\t\t\t   .setSuperShardingKey(superShardingKey)\n\t\t\t\t   .build();</code></pre>\n\n<p><br />\nAnother example from JavaSE 9. Till Java 8, JavaSE Calendar had only factory methods to get Calendar instances.</p>\n\n<pre>\n<code class=\"language-java\">//The following code produces a Calendar with date 2012-12-31 (Gregorian) because Monday is the //first day of a week with the ISO 8601 compatible week parameters.\n\n   Calendar cal = new Calendar.Builder().setCalendarType(\"iso8601\")\n                        .setWeekDate(2013, 1, MONDAY).build();\n//The following code produces a Japanese Calendar with date 1989-01-08 (Gregorian), assuming that //the default ERA is Heisei that started on that day.\n\n   Calendar cal = new Calendar.Builder().setCalendarType(\"japanese\")\n                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();</code></pre>\n\n<h2><br />\nAdapter, Bridge, Facade, Proxy Patterns</h2>\n\n<p>Adapter pattern:</p>\n\n<p>When there is a gap in communication, and you fill the gaps by adapting to a different form, or when you want to present a view with which the client is familiar with.<br />\n&nbsp; &nbsp;Mechanism: <span style=\"color:#336600;\"><em>I won&#39;t call you directly, I will call someone who understands you and call you</em>. Or I want you to be in the&nbsp;shape and format that I like and understand.</span></p>\n\n<pre>\n<code class=\"language-java\">//I have an array, but I don't want to deal with arrays\nList list = java.util.Arrays.asList(array);\n//Now array has been adapted to a list format or you can say array has been wrapped around by a list which I can understand and use.\n\n//Now when I want to do something with the array, I won't call array directly, I will call the list which internally understands arrays and will get the job done for me.\n\n//There are other examples of Adapter pattern in JavaSE\norg.xml.sax.helpers.XMLReaderAdapter\n//This class wraps a SAX2 XMLReader and makes it act as a SAX1 Parser. \n</code></pre>\n\n<p><br />\nWhen there is no gap yet, but still we like to fill gaps by the delegation of responsibility.<br />\n&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Mechanism: <span style=\"color:#336600;\"><em>I won&#39;t call you directly, I would call someone, who will call you.</em></span> (Bridge)</p>\n\n<p>&nbsp;</p>\n\n<p>When there is no gap in communication, but a lot of complicacy.<br />\n&nbsp; &nbsp; &nbsp; &nbsp;Mechanism: <span style=\"color:#336600;\"><em>I won&#39;t call you directly, i would call someone who simplifies things for me.</em></span> (Facade)</p>\n\n<p>&nbsp;</p>\n\n<p>When you want to intercept every call to an object (PROXY), or you want to put a substitute/envoy in place of real object.<br />\n&nbsp; &nbsp; &nbsp; For security/access-control<br />\n&nbsp; &nbsp; &nbsp; For logging<br />\n&nbsp; &nbsp; &nbsp; For presenting the local view of a remote object (e.g. in EJB)<br />\n&nbsp; &nbsp; &nbsp; For presenting stub (in Mockito)<br />\n&nbsp; &nbsp; &nbsp; For lazy-loading and transaction handling (in Hibernate)</p>\n\n<p>Real life usage: Use apache&#39;s <a href=\"https://commons.apache.org/proper/commons-proxy/\" target=\"_blank\">commons-proxy library</a>, guava library.</p>\n\n<h2><span style=\"font-family:Tahoma,Geneva,sans-serif;\">Inheritance or&nbsp;Composition: Which One Would You Use</span></h2>\n\n<p>If you have an understanding of fundamental OOPs Principles: Encapsulation, Abstraction, Inheritance, Polymorphism, you could notice that Inheritance kind of breaks Encapsulation, as it allows subclasses to be able to see internal details of the parent class. So instead of inheritance, you could use Composition.See if the scenario is A-is-a-B(-and-maybe-something-more) A-is-a-B-with-some-modifications &nbsp;then go for Inheritance</p>\n\n<p>If the scenario is A-has-some-features-of-B-(and-something-more) then go for Composition.</p>\n\n<p>The composition is favoured by frameworks supporting Dependency Injection.</p>\n\n<p>&nbsp;</p>\n\n<h2>Visiter Pattern</h2>\n\n<p>You can replace this form of conditional processing</p>\n\n<pre>\n<code class=\"language-java\">    public Something process(Something thing){\n\n        if (thing instanceof SomethingOfType1)\n            return process((SomethingOfType1) thing);\n        else if (thing instanceof SomethingOfType2)\n            return process((SomethingOfType2) thing);\n\n        throw new IllegalArgumentException(thing);\n    }\n\n    public SomethingOfType1 process(SomethingOfType1 record){\n        // Specific processing for Type 1\n    }\n\n    public SomethingOfType2 process(SomethingOfType2 record){\n        // Specific processing for Type 2\n    }\n</code></pre>\n\n<p>with this</p>\n\n<pre>\n<code class=\"language-java\">public abstract class Something {\n    public abstract &lt;T&gt; T accept(SomethingTypeVisitor&lt;T&gt; visitor);\n}\n\npublic interface SomethingTypeVisitor&lt;T&gt; {\n        T visit(SomethingOfType1 recordType);\n        T visit(SomethingOfType2 recordType);\n}\n\npublic class SomethingOfType1 extends Something{\n    @Override\n    public &lt;T&gt; T accept(SomethingTypeVisitor&lt;T&gt; visitor) {\n        return visitor.visitOne();\n    }\n}\n\nString result = something.accept(new SomethingTypeVisitor&lt;String&gt;() {\n\n    String visit(SomethingOfType1 recordType) {\n        return \"...\";\n    }\n\n    String visit(SomethingOfType2 recordType) {\n        return \"....\";\n    }\n\n});\n</code></pre>\n\n<p>What&#39;s the benefit?</p>\n\n<p>This pattern enforces you to implement subclass-specific logic at compile time.</p>\n\n<p>Also, the visitor object can have state, so if the processing of one type of object requires the processing of another type of object, it comes handy.</p>\n\n<p>The visitor pattern is often used in parsing e.g. XML parsing.</p>\n\n<p>SONAR allows you to write custom rules using the visitor pattern. <a href=\"https://docs.sonarqube.org/display/PLUG/Writing+Custom+Java+Rules+101\" target=\"_blank\">See here</a>.</p>\n\n<p>&nbsp;</p>\n\n<h2>Command Pattern</h2>\n\n<p>You request someone for something, what if you want to replay it, what if you want to do something when the request fails.</p>\n\n<p>Commands are basically behavior(s) wrapped in an object (possibly along with the target which we want to eventually request).</p>\n\n<p>There are a lot of variants of the command pattern. An important thing to remember is that&nbsp;there is an <strong><em>Invoker</em></strong> involved which will just trigger the execution of the command (and maybe keep a record of it), the command itself will decide who (<strong><em>Receiver</em></strong>) will actually do the thing that command is created for.&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">interface Command{ void run(); }\n\n//implementations of Command\n//...\n\n//Executor of commands\nclass Executor{\n  Map&lt;String, Command&gt; commands;\n  public class addCommand(String id, Command comm){\n     commands.put(id, comm);\n\n  }\n  public static void execute(String id){ \n    commands.get(id).run();\n  }\n\n}\n\n</code></pre>\n\n<p><br />\nReal World Examples:&nbsp;<br />\n&nbsp; <a reactlink=\"/article/108\">Using Hystrix library</a>: Instead of directly calling a web service you can wrap the call around a HystrixCommand</p>\n\n<h2>Chain Of Responsibility</h2>\n\n<p>When there are many components which can serve the request (maybe on a conditional basis), modify/enrich/validate&nbsp;the initial request object, but only one of these components will give output (<em>This is not something hard and fast rule, its generally what is seen, implementation and requirement may choose multiple components to handle request, and partially form the response/enrich the response etc</em>).&nbsp;</p>\n\n<p><br />\nFrom <a href=\"https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern\">Wikipedia</a>:</p>\n\n<p><q><cite>... the chain of responsibility is an object-oriented version of the&nbsp;<code>if ... else if ... else if ....... else ... endif</code>&nbsp;idiom, with the benefit that the condition&ndash;action blocks can be dynamically rearranged and reconfigured at runtime.</cite></q></p>\n\n<p>The mechanism: <span style=\"color:#27ae60;\"><em>&quot;I don&#39;t know and I do not want to know, which one of you will serve my request. I will just pass a request, and I want an output when each one of you is done&quot;</em></span>. Now only one will actually serve the request (get the output), serve the request if you can otherwise pass to the next one.&nbsp;<br />\nThis chain could be in the form of linked-list.&nbsp;<br />\nThese are examples from JavaSE:</p>\n\n<p>Try/catch blocks in Java act in a similar fashion as described by this pattern. Exception is passed along to next catch block in the&nbsp; caller stack.</p>\n\n<p><a href=\"https://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-\" target=\"_blank\">https://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-</a></p>\n\n<pre>\n<code class=\"language-java\">void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n//The doFilter method of the Filter is called by the container each time a request/response pair is passed through the chain due to a client request for a resource at the end of the chain. The FilterChain passed in to this method allows the Filter to pass on the request and response to the next entity in the chain.</code></pre>\n\n<h2><br />\nTemplate Pattern</h2>\n\n<p>The mechanism is that <span style=\"color:#27ae60;\"><em>&quot;I will leave this part to you, you can do it however you want, I will use your result and do the rest on my own&quot;</em></span>.</p>\n\n<pre>\n<code class=\"language-java\">//Following is a pretty cool example which can be and should used almost everywhere you are dealing with system resources (which need cleanup)\npublic static void execute(Consumer&lt;T&gt; consumer) {\n     T resource = createResource();\n     try {\n        consumer.accept(resource);\n     } finally {\n        resource.dispose();\n     }\n}\n\n//In this example, we have written a sort of algorithm in which resource creation is left for implementation/overriding, then the resource is passed to someone who needs it (consumer), and then the cleanup logic.\n//Here, we have left a hook for resource creation, this is what Template pattern signifies.</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>Decorator Pattern</h2>\n\n<p>Java SE code has many examples of this, mostly in java.io package.&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"file\"));\n//In this code FileInputStream is decorated with extra functionality (support for buffering). This is a fundamental example of decorator pattern.</code></pre>\n\n<pre>\n<code class=\"language-java\">//Essentially (in Java8)\ntransformers.stream().reduce(Function.identity(), Function::andThen).applyTo(objectX)\n  //Transformation being applied to object, and then another transformation being applied to result of the earlier transformation. At the end you have object of original type but with extra functionality added at runtime.\n\n//In verbose form\nclass X {\n   void method();\n}\nclass Decorator1 extends X { \n   private X x; \n   void method(){\n     //something extra\n     x.method();\n     //something extra\n   }\n}\n//Note that Decorator(s) and original class offer same interface (methods).\n//So I can have code like this:\nX xWithManyPowers = new Decorator2( new Decorator2(new X()));\n//In this way I can add as many functionalities to x object as I want, on runtime.</code></pre>\n\n<h2><br />\nObserver Pattern</h2>\n\n<p>Mechanism is <span style=\"color:#009933;\"><em>&quot;If you are interested in someone&#39;s events, tell them they wil remember it and notify you about whenever something new happens&quot;</em></span>.&nbsp;</p>\n\n<p>There are many setups possible for this :<br />\nAttach/Register yourself to someone you want to listen to. Deattach/Deregister when you think you are done.<br />\nAttach/Register yourself to someplace where everyone comes and tells their state. (This is more flexible, you get benefit of everyone&#39;s info without getting in contact with them).</p>\n\n<p>Real Life Usage: Reactive Programming, Guava&#39;s EventBus</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "programming", "tags": [], "img": "", "summary": "Design Patterns act as your guide in solving some problems which people have already faced while developing systems.", "lastUpdated": "2021-02-05 08:32:52.783952"}