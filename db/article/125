{"name":"Binary Indexed Trees","id":125,"content":"<p><strong>Binary Indexed Tree </strong>or <strong>Fenwick Tree </strong>is not actually a tree.</p>\n\n<p>It is just an array, which stores partial sums of elements in given array, in such a way that reduces the amount of updates/changes we need to make when some element is changed.</p>\n\n<p>Basically it provides you runtime of O(logN) for finding the range sum, and updating the element.</p>\n\n<p>This data-structure is useful when you want to find range-sum frequently in an environment where the updates are also possibly frequent.</p>\n\n<p><iframe allow=\"encrypted-media\" allowfullscreen=\"\" frameborder=\"0\" gesture=\"media\" height=\"315\" src=\"https://www.youtube.com/embed/1wtpN2jKBf4\" style=\"width:80%\"></iframe></p>\n\n<h2><span style=\"color:#8e44ad;\">Find the Number of Inversions</span></h2>\n\n<p>&nbsp; Problem: Find out the number of inversions in given array A =&nbsp;{ 8, 4, 2, 1 }</p>\n\n<p>&nbsp; Solution: Create the BIT which represents the frequency of elements, we will udate those frequencies as we traverse the array one by one.&nbsp;Now walk the array, update the frequency of current element in BIT. Also for each element as we walk we find the sum of frequencies of elements greater than the current number. That we can easily lookup in BIT. Suppose while walking the array, we are currently at <strong>index = x</strong>, <strong>value = A[x]</strong>, we can easily find the Range-Sum(x+1,N). This will be number of inversion counts for A[x].</p>\n\n<p>If the max(A) is quite large, you should map the numbers to some different array which will keep the order, that will not change the number of inversion counts. E.g. {7, -90, 100, 1} can be mapped to {3, 1, 4 ,2 }.</p>\n\n<pre>\n<code class=\"language-html\">Number-of-inversion-pairs-with-A[x] = Sum-of-number-of-occurrences-of-elements-greater-than-A[x]-till-now\n\n//Since the array of frequencies is being updated here, and we need to find range-sum along, BIT is useful here.</code></pre>\n\n<h2><span style=\"color:#8e44ad;\">Find the k-th largest element</span></h2>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"color:#8e44ad;\">Range Minum Queries</span></h2>\n\n<p>You need to answer these kind of queries. min(Array[x..y]).&nbsp;</p>\n\n<p>We can use two BITs one constructed by starting from 1 where index 1 stores aggregative information corresponding to 1. Another BIT which stores aggregative information corresponding to 1 at index N.</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"algos","tags":null,"img":null,"summary":null,"lastUpdated":null}