{"name": "Garbage Collection", "id": 88, "content": "<p>Garbage means anything that is of no use anymore. In real-life people have taken it to another level, where even persons are considered garbage sometimes, but in programming languages this basically has to do with only the things that take computer resources like memory. In object-oriented language, this basically means &quot;Objects&quot; as they are the things take consume memory. Garbage Collection simply means getting rid of this garbage.</p>\n\n<h2><span style=\"font-family:Trebuchet MS,Helvetica,sans-serif;\">Why Garbage Collection is useful? Or Is it?</span></h2>\n\n<hr />\n<p>In Java, unlike languages like C++, when you create an object in your code, you don&#39;t have to destroy it. You don&#39;t even have to pass this responsibility to other API/code/library. But someone has to do this dirty work. So Java system does this for you.</p>\n\n<p>Java system runs a GC (Garbage Collector) Thread which automatically figures out which objects are no longer in use. It then destroys them and frees the memory consumed by them.</p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">How does a GC work?</span></h2>\n\n<p><span style=\"font-family:Arial,Helvetica,sans-serif;\">GC keeps track of what is <em>LIVE</em>&nbsp;(those objects which can be accessed and used), everything else is collected and destroyed (i.e. the memory they occupy is marked free/available).&nbsp;</span></p>\n\n<p>There are four kinds of GC roots in Java:</p>\n\n<ul>\n\t<li><strong>Local variables</strong>&nbsp;are kept alive by the stack of a thread. This is not a real object virtual reference and thus is not visible. For all intents and purposes, local variables are GC roots.</li>\n\t<li><strong>Active Java threads</strong>&nbsp;are always considered live objects and are therefore GC roots. This is especially important for thread local variables.</li>\n\t<li><strong>Static variables</strong>&nbsp;are referenced by their classes. This fact makes them de facto GC roots. Classes themselves can be garbage-collected, which would remove all referenced static variables. This is of special importance when we use application servers,&nbsp;<a href=\"http://www.wikipedia.com/osgi\">OSGi containers</a>&nbsp;or class loaders in general. We will discuss the related problems in the Problem Patterns section.</li>\n\t<li><strong>JNI References</strong>&nbsp;are Java objects that the native code has created as part of a JNI call. Objects thus created are treated specially because the JVM does not know if it is being referenced by the native code or not. Such objects represent a very special form of GC root, which we will examine in more detail in the Problem Patterns section below.</li>\n</ul>\n\n<p>Mark-Sweep-Compact is a&nbsp; general strategy for Garbage Collectors.</p>\n\n<p><strong>Mark</strong>: Mark every object you can reach starting from roots&nbsp;as &quot;live&quot;. More the live objects, the more time it takes in marking.</p>\n\n<p><strong>Sweep</strong>: Put &quot;non-live&quot; objects in some sort of free-list. The larger the heap, more time this operation will take.</p>\n\n<p><strong>Compact:</strong>&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Over the time heap is fragmented (this is similar to <a href=\"https://en.wikipedia.org/wiki/Defragmentation\" target=\"_blank\">disk fragmentation</a>). After a successful GC cycle, to defragment or compact, live objects are relocated (at the end of the heap) to make larger contiguous free memory, now since they have been relocated, you also have to correct their addresses wherever they are used.</p>\n\n<p><strong>Copy way:</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Instead of marking, copy every reachable object starting from roots, to some other place;&nbsp;also correct the addresses where it is referenced. This is a&nbsp;monolithic operation.</p>\n\n<p><strong>Generational Collection:</strong></p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; Based on philosophy (actually observation) that most objects die young, and few younger objects remain attached to older&nbsp;ones.&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Keep an area Young Gen, where only young objects live, when some object grows older (it has been in Young Gen for more than x number of GC cycles) it will be moved to Old Gen area.</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Old Gen area is cleaned only when it fills up. Use the&nbsp;copy method for Young Gen area (which will be smaller)</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;A Remembered Set tracks all the references from Old Gen into Young Gen, which can be used to find out which part of the&nbsp;heap is young.</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp;Every reference write is intercepted and tracked.</p>\n\n<p>The garbage collection algorithm chosen for a young generation typically puts a premium on speed, since young generation collections are frequent. On the other hand, the old generation is typically managed by an algorithm that is more space efficient, because the old generation takes up most of the heap and old generation algorithms have to work well with low garbage densities.</p>\n\n<p><strong>Concurrent Mark:</strong></p>\n\n<p>&nbsp; &nbsp; Race condition may arise here: collector marks some objects, your program moves&nbsp;a reference which the collector has not visited to the memory which collector has already visited. So, effectively collector will miss a live object, which is dangerous because it will then be recycled.</p>\n\n<p>&nbsp; &nbsp; To solve this&nbsp;Track object references and memory as they are written by your program, mark them &quot;live&quot;, then come back. And repeat this in multiple passes. (Multi-pass marking)</p>\n\n<p><a href=\"https://stackoverflow.com/questions/2254041/java-g1-garbage-collection-in-production\" target=\"_blank\">https://stackoverflow.com/questions/2254041/java-g1-garbage-collection-in-production</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/306862/does-using-final-for-variables-in-java-improve-garbage-collection\" target=\"_blank\">https://stackoverflow.com/questions/306862/does-using-final-for-variables-in-java-improve-garbage-collection</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/449409/does-assigning-objects-to-null-in-java-impact-garbage-collection\" target=\"_blank\">https://stackoverflow.com/questions/449409/does-assigning-objects-to-null-in-java-impact-garbage-collection</a></p>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">When does the GC do&nbsp;its work?</span></h2>\n\n<hr />\n<p><em>It depends on the type of GC:</em></p>\n\n<p>Concurrent GC will do it&#39;s work <em>concurrently&nbsp;</em>with your application running.</p>\n\n<p><strong>Concurrent Mark-Sweep (CMS) Collector</strong></p>\n\n<p>Mark (after pausing application shortly), then&nbsp;Remark and&nbsp;Sweep concurrently while application is running. Remark work overhead is a trade-off to reduce pause time. Some objects may escape during remark phase (Floating Garbage objects), and will be collected during next cycle.</p>\n\n<p>The CMS collector is the only collector that is non-compacting. That is, after it frees the space that was occupied by dead objects, it does not move the live objects to one end of the old generation. This saves time, but now allocatino operation becomes costly as it has to now search for free chunks and maintain a free-list.&nbsp;Finally, fragmentation may occur due to lack of compaction. To deal with fragmentation, the CMS collector tracks popular object sizes, estimates future demand, and may split or join free blocks to meet demand.&nbsp;</p>\n\n<p>Unlike the other collectors, the CMS collector does not start an old generation collection when the old generation becomes full. Instead, it attempts to start a collection early enough so that it can complete before that happens. Otherwise, the CMS collector reverts to the more time-consuming stop-the-world mark-sweep-compact algorithm used by the parallel and serial collectors. To avoid this, the CMS collector starts at a time based on statistics regarding previous collection times and how quickly the old generation becomes occupied. The CMS collector will also start a collection if the occupancy of the old generation exceeds something called the initiating occupancy. The value of the initiating occupancy is set by the command line option &ndash;XX:CMSInitiatingOccupancyFraction=n, where n is a percentage of the old generation size. The default is 68.</p>\n\n<p><strong>Parallel GC</strong> will also do its work <em>concurrently</em>, but using multiple CPUs.</p>\n\n<p>Stop-The-World GC will do its work in between after stopping your application.</p>\n\n<p>Stop-The-World GC may collect incrementally (in chunks) or monolithically (whole dead object graph).</p>\n\n<h2>Which GC Algorithm Should I use?</h2>\n\n<hr />\n<p>Use the <strong>CMS collector</strong> if your application needs shorter garbage collection pauses and can afford to share processor resources with the garbage collector when the application is running. (Due to its concurrency, the CMS collector takes CPU cycles away from the application during a collection cycle.) Typically, applications that have a relatively large set of long-lived data (a large old generation), and that run on machines with two or more processors, tend to benefit from the use of this collector. An example would be web servers. The CMS collector should be considered for any application with a low pause time requirement. It may also give good results for interactive applications with old generations of a modest size on a single processor.</p>\n\n<h2>Ergonomics</h2>\n\n<p>JVM automatically tunes GC configurations based on the type of the machine you are running it on. The types of machines can be Server Class, Client class.&nbsp;A server-class machine is defined to be one with &bull; 2 or more physical processors and &bull; 2 or more gigabytes of physical memory (except for 32-bit windows).</p>\n\n<p>On a server-class machine, the JVM is always the server JVM unless you explicitly specify the -client command line option to request the client JVM. On a server-class machine running the server JVM, the default garbage collector is the parallel collector.</p>\n\n<p>You can tell JVM the behavior desired and it will <em>try to</em>&nbsp;adjust configurations accordingly. E.g.&nbsp;</p>\n\n<ul>\n\t<li>-XX:MaxGCPauseMillis=n&nbsp;</li>\n\t<li>-XX:GCTimeRatio=n (The ratio of garbage collection time to application time is 1 / (1 + n))</li>\n</ul>\n\n<h2><span style=\"font-family:Arial,Helvetica,sans-serif;\">Does increasing Heap size solve all problems</span></h2>\n\n<hr />\n<p>&nbsp; Empty heap memory controls efficiency (amount of collector work needed in proportion to the&nbsp;amount of application work performed).</p>\n\n<p>&nbsp; Empty memory controls the frequency of pauses, but not the duration of pauses.</p>\n\n<p>So in short worst case scenario (pause time) does not improve.&nbsp;</p>\n\n<p><a href=\"https://stackoverflow.com/questions/1071631/tracking-down-a-memory-leak-garbage-collection-issue-in-java\" target=\"_blank\">https://stackoverflow.com/questions/1071631/tracking-down-a-memory-leak-garbage-collection-issue-in-java</a></p>\n\n<p>Unless you have problems with long pause times, try granting as much memory as possible to the heap. Throughput is proportional to the amount of memory available. Having sufficient available memory is the most important factor affecting garbage collection performance.&nbsp;The second most influential factor affecting garbage collection performance is the proportion of the heap dedicated to the young generation.&nbsp;Unless you find problems with excessive old generation collections or pause times, grant plenty of memory to the young generation.&nbsp;When you are using one of the parallel garbage collectors, it is preferable to specify desired behavior rather than exact heap size values. Let the JVM decide what&#39;s good.</p>\n\n<h2><br />\n<span style=\"font-family:Arial,Helvetica,sans-serif;\">Examples of GC Problem&nbsp;causes</span></h2>\n\n<hr />\n<p>A finalizer in a&nbsp;large number of classes which did nothing but set every reference to null, caused 18 seconds pause in concurrent GC.</p>\n\n<h2><br />\n<span style=\"\">Soft, Weak and Phantom References to help GC</span></h2>\n\n<hr />\n<p><span style=\"\"><strong>WeakHashMap</strong> -&gt; Keys are weak references. Values are strong references. Weak means that, just because the key-value pair is present in the&nbsp;map doesn&rsquo;t mean that the&nbsp;key cannot be garbage collected. Key can be garbage collected and then effectively the entry would be removed over time.<br />\n<code>WeakHashMap&lt;K,WeakReference&lt;V&gt;&gt;</code> &nbsp;is a common idiom.<br />\n<code>ReferenceQueue</code> can be passed while creating a weak reference, GC adds the reference after it is GC&rsquo;d, so that the stale entries can be removed.<br />\n&nbsp;<br />\nDifference between <code>SoftReference</code> and <code>WeakReference</code>: <code>SoftReference</code> is GC&rsquo;d only when there is a&nbsp;shortage of memory.<br />\nThese references can serve as poor man&rsquo;s caching solutions, but can not replace high-performing caching frameworks.<br />\n&nbsp;<br />\n<strong>PhantomReference</strong>: These are GC&rsquo;d after strong, weak and soft references. A reference queue is a must while creating these.<br />\n&nbsp;</span></p>\n\n<h2>Garbage Collectors in the J2SE 5.0 HotSpot JVM</h2>\n\n<hr />\n<p>Memory in the Java HotSpot virtual machine is organized into three generations: a young generation, an old generation, and a permanent generation.&nbsp;The permanent generation holds objects that the JVM finds convenient to have the garbage collector manage, such as objects describing classes and methods, as well as the classes and methods themselves.</p>\n\n<p>For multithreaded applications, allocation operations need to be multithread-safe. If global locks were used to ensure this, then allocation into a generation would become a bottleneck and degrade performance. Instead, the HotSpot JVM has adopted a technique called Thread-Local Allocation Buffers (TLABs). This improves multithreaded allocation throughput by giving each thread its own buffer (i.e., a small portion of the generation) from which to allocate. Since only one thread can be allocating into each TLAB, allocation can take place quickly by utilizing the bump-the-pointer technique, without requiring any locking. Only infrequently, when a thread fills up its TLAB and needs to get a new one, must synchronization be utilized. Several techniques to minimize space wastage due to the use of TLABs are employed. For example, TLABs are sized by the allocator to waste less than 1% of Eden, on average. The combination of the use of TLABs and linear allocations using the bump-the-pointer technique enables each allocation to be efficient, only requiring around 10 native instructions</p>\n\n<p>Read this <a href=\"https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf\" target=\"_blank\">oracle paper</a> for more details.</p>\n\n<h2>Can we force Garbage Collection?</h2>\n\n<hr />\n<p>No, however, you can give a hint to the JVM to do this if possible. Use&nbsp;<code><a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#gc()\" rel=\"noreferrer\">System.gc()</a>.</code></p>\n\n<p>However, some profilers may do this, using&nbsp;&nbsp;<a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/jvmti/\" target=\"_blank\"><em>Java&trade; Virtual Machine Tool Interface (JVM TI)</em></a></p>\n\n<p><a href=\"https://www.yourkit.com/docs/java/help/garbage_collection.jsp\" target=\"_blank\">https://www.yourkit.com/docs/java/help/garbage_collection.jsp</a></p>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references\" target=\"_blank\">https://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/13634766/eligible-variables-for-garbage-collection-in-java\" target=\"_blank\">https://stackoverflow.com/questions/13634766/eligible-variables-for-garbage-collection-in-java</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/18406703/when-will-a-string-be-garbage-collected-in-java\" target=\"_blank\">https://stackoverflow.com/questions/18406703/when-will-a-string-be-garbage-collected-in-java</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/924285/efficiency-of-java-double-brace-initialization\">https://stackoverflow.com/questions/924285/efficiency-of-java-double-brace-initialization</a></p>\n\n<h2>&nbsp;</h2>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "linked-to-38", "tags": ["medium"], "img": "/images/gc.jpg", "summary": "", "lastUpdated": "2021-01-19 06:00:16.827191"}