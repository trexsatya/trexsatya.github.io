{"name": "Scalability", "id": 199, "content": "<div class=\"box1\" style=\"\">Suddenly your&nbsp;website becomes popular. You had deployed your website application on one server which was good enough until now. But now your server is giving up due to heavy load. Is your application, deployment architecture prepared to handle this kind of scenario? This is the question of <strong><em>Scaling</em></strong>.<br />\n<span style=\"color:#27ae60;\"><strong><em>How&nbsp;does your system/application respond&nbsp;to increasing load?</em></strong></span></div>\n\n<p><span style=\"color:#27ae60;\"><strong><em>How does Google handle millions of users searching at the same time? See <a href=\"https://storage.googleapis.com/gweb-research2023-media/pubtools/pdf/9b0aa90de33d2a5f6a5575f71e772f74c0f4b945.pdf\">here</a>.</em></strong></span></p>\n\n<p>&nbsp;</p>\n\n<p><strong>What are the ideas used for handling heavy loads?</strong></p>\n\n<ol>\n\t<li>Distribute load to different machines/servers.</li>\n\t<li>Reduce the amount of network transfer - both in terms of time and space.</li>\n\t<li>Re-use the resources or results where possible. Don&#39;t do unnecessary work.</li>\n\t<li>Prevent the system from going down because of load - better to be slow than dead.</li>\n\t<li>Have backups. In case of failure or slowness&nbsp;there should be automatic redirection to faster available option.</li>\n\t<li>Optimise at the algorithmic level</li>\n\t<li>Use powerful machines where required, or hardware specially suited for specific purpose.</li>\n\t<li>Optimise at the hardware level, operating system level, network level.</li>\n</ol>\n\n<p>Questions to ask:</p>\n\n<ol>\n\t<li>What if some parts of the hardware fails? or the entire machine fails?</li>\n\t<li>Can you upgrade system or apply a patch without stopping the system?</li>\n\t<li>What if some parts of the software fail? A bug maybe?</li>\n\t<li>&nbsp;</li>\n</ol>\n\n<p>Scalability Ideas:</p>\n\n<p><strong>Read vs Write</strong>: There are two options</p>\n\n<ol>\n\t<li>Optimise for read operations - more work during write; less during read;</li>\n\t<li>Optimise for write operations - more work during read; less during write;</li>\n</ol>\n\n<p>You can add support for choosing different optimisations for different use-cases. Example: In Twitter, when a person makes a post, caches of all the followers of that person are updated. This is not performant for celebrities who have millions of followers - so in that it just writes to the datastore for the person who posts and the followers who are active their timeline is updated in the background by fetching updates from the celebrities that they follow.</p>\n\n<p><strong>Different goals/metrics:</strong></p>\n\n<ol>\n\t<li>Throughput - number of operations done in a time-unit</li>\n\t<li>Response Time, Latency - how much it takes for the response to complete, how much time request has to wait in order to be served.</li>\n</ol>\n\n<p>Median Response Time = 50th percentile = p50: If median is x seconds, half of the requests took less than x seconds to complete, and half of them took more than x seconds.</p>\n\n<p>If p95 is x seconds, 95% requests took less than x seconds, and 5% took more than x seconds.&nbsp;</p>\n\n<p>Like a traffic jam, slow requests in front can slow down requests waiting even though those waiting requests could be processed faster.</p>\n\n<p>Deciding on metrics, calculating metrics in efficient way itself is challenging.</p>\n\n<p><strong>What to think about apart from these?</strong></p>\n\n<p>Operability: Detect problems through monitoring, Keeping softwares/dependencies up to date, Apply security patches etc</p>\n\n<p>Simplicity:</p>\n\n<p>Evolvability: Anticipate different scenarios, allow flexibility in the design.</p>\n\n<h2>Network Transfer Time&nbsp;</h2>\n\n<p>Format of the encoded data can have huge impact.&nbsp; Apache Thrift, Google&#39;s Protocol Buffers, Apache Avro.&nbsp;</p>\n\n<p>Batching of data and Compression can have huge impact, Kafka used this to increase its performance.</p>\n\n<p>Web-services (SOAP or REST) are useful but RPC is more performant (ex. gRPC, Avro RPC, Finagle, Rest.li).&nbsp;The main focus of RPC frameworks is on requests between services owned by the same organization, typically within the same datacenter.&nbsp;</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "architecture", "tags": [], "img": "", "summary": "When the application gets bigger, number of clients/users increase, we have to either unleash the power of Hardware or come up with a clever solution", "lastUpdated": "2024-05-07 20:22:10.794957"}