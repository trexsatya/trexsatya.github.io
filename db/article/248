{"name": "Tech Learnings from Experience", "id": 248, "content": "<p>Write tests for each condition, write the extensive, property-based&nbsp;testcase, delete the test case if it is already covered by the logic implemented and you think that the test case doesn&#39;t introduce any new scenario.</p>\n\n<p>Can something break if we just renamed a method as part of refactoring? - Yes, one example is if you have mocked using qualified name of code-unit (e.g. done in Python by monkey-patching).</p>\n\n<p>Sometimes even seemingly minor things can cause bigger issues depending on what is the integration with other systems, what kind of data is exchanged and how (and which part of) the data it is utilised by different systems</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Learning from Klarna:</strong><br />\n--------------------</p>\n\n<p>Take care of fundamental things like <strong>Idempotency, ordering requirement</strong>&nbsp;in message consumption, transactions, possibilities of Deadlocks etc.</p>\n\n<p>Take care that when you make changes there might be requests/events being in-transit, you must accomodate for that. Either by a planned downtime or by having logic to handle it. Apart from code it applies to changes with DB as well such as adding indices to DB (takes time).</p>\n\n<p>1. Infrastructure Tooling - immutable deployable artefact.<br />\n2. Security Tooling<br />\n&nbsp;&nbsp; &nbsp;- Exchange secrets securely<br />\n&nbsp;&nbsp; &nbsp;- Don&#39;t store them on workstations<br />\n&nbsp;&nbsp; &nbsp;- Don&#39;t inject prod credentials in buildtime (or anywhere outside prod environment).<br />\n&nbsp;&nbsp; &nbsp;- Make sure to not log secrets<br />\n&nbsp;&nbsp; &nbsp;- Make it easy to rotate secrets<br />\n3. Security Footprint (divide into categories based on criteria such as data-governannce requirements, internet/public exposure, criticality of the system/business etc)<br />\n&nbsp; &nbsp; Perform regular pen-testing for high security systems.<br />\n4. Threat Modelling:<br />\n&nbsp;&nbsp; &nbsp;- Draw visual digram, and/or a formal specification.<br />\n&nbsp;&nbsp; &nbsp;- Find threats.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;S Spoofing = Someone impersonating an existing user in system.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;T Tampering = with the in-flight data and thus affecting the system<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;R Repudiation = We should be able to trace back to the perpertrator such that it can prove their malicious activity; and the malicious actor should not be able to manipulate the logs themselves.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;I Information Disclosure = Enough control over access to data (different categories, different levels, should be easy to revoke access when needed), encryption etc.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;D Denial of Service = Rate limiting etc, shouldn&#39;t block a genuine user if someone else is retrying on their behalf.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;E Elevation of Privilege = Multiple levels of access, IAM roles/policies, function-level, object-level authorisation, authorisation mechanism etc.<br />\n5. Security Principles:<br />\n&nbsp;&nbsp; &nbsp;- Trust cautiously, Start with No Trust First, then filter-in (on multiple levels e.g. connection, identity - auth, input, activities/actions)<br />\n&nbsp;&nbsp; &nbsp;- Separate responsibilities, 4-eyed reviews for each critical operation.<br />\n&nbsp;&nbsp; &nbsp;- Defence in depth, no single point of failure.<br />\n&nbsp;&nbsp; &nbsp;- Simple first approach: More complex, harder it is to secure. KISS principle.<br />\n&nbsp;&nbsp; &nbsp;- Record all security significant events in a tamper-resistant store. Monitor and notify suspicious activity (rate limiting in action, signature not matching, unauthorized access to sensitive resources, etc). Review firewall configs, SSL/TLS, HTTPS certificates etc regularly.<br />\n&nbsp;&nbsp; &nbsp;- Secure the weakest link first; Don&#39;t invent security tools, use the proven ones; don&#39;t rely on obsecurity for security; Fail securely;<br />\n6. Take care of well-known threats:<br />\n&nbsp;&nbsp; &nbsp;XSS<br />\n&nbsp;&nbsp; &nbsp;CSP<br />\n&nbsp;&nbsp; &nbsp;XXE<br />\n&nbsp;&nbsp; &nbsp;Domain Takeover Vulnerabilities: Ex. AWS Elastic IP no longer used, but the DNS records still have it. So attacker can use this IP address and all traffic from your domain will be redirected to attacker&#39;s server.<br />\n7. Analyse dependencies/libraries/artifacts for vulnerabilities in a centralised way.<br />\n8. Enforced Verifiable Change Control (some sort of tooling to verify that changes are reviewed, cannot be modified by a single person, an immutable record of what went through deployment)<br />\n9. API Naming convention, restful structure, versioning, pagination etc<br />\n10. Idempotency of operations<br />\n11. Disaster Recovery plans<br />\n12. Testing</p>\n\n<p>&nbsp;</p>\n\n<h1 dir=\"ltr\"><b id=\"docs-internal-guid-e49df892-7fff-d8d9-40d2-830f2ca706bb\">Questions to be asked continuously</b></h1>\n\n<p>These questions should be explored at multiple levels: unit level, module level, service level, system level, inter-system level. It&rsquo;s a repeated process, not a one-time thing.</p>\n\n<p><strong>Technical</strong>:&nbsp;</p>\n\n<p>About Readability, Testability, Maintainability, Extendibility. (Extra focus on readability of the tests)</p>\n\n<p><strong>Functional</strong>:</p>\n\n<p>What can go wrong? What if upstream/downstream messes up? And what are the implications?&nbsp;</p>\n\n<ul>\n\t<li>Loss of information, resources</li>\n\t<li>Loss of integrity</li>\n\t<li>Disfunctional/unexpected outcome</li>\n\t<li>etc</li>\n</ul>\n\n<p>How are we preventing the wrong thing? Is it a single point of error/failure, or is there a backup?&nbsp;</p>\n\n<p>How are we verifying the right thing?</p>\n\n<p>How to rectify when things go wrong? Is enough data available to make the rectification (this actually depends upon what things we have identified that can go wrong)?</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Testing</strong></p>\n\n<p><strong>Integration Tests:</strong></p>\n\n<p>Give you outside in perspective while doing development. Start with Integration Test in a TDD way, this way you are not tied to the implementation detail, so your refactoring wouldn&#39;t force changes in tests. Combine this with normal TDD steps, so that you get the benefit of design-evolution guided by tests.</p>\n\n<p>Another advantage of integration tests is that you can control any aspect of the system.</p>\n\n<pre>\n<code class=\"language-java\">@SpringBootTest(webEnvironment = DEFINED_PORT, classes = TestConfig.class)\n@EmbeddedKafka\n@ExtendWith({SpringExtension.class, UsePostgreSqlExtension.class})\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@ActiveProfiles(\"test\")\n@TestPropertySource(\n        properties = {\n            \"spring.kafka.enabled=true\",\n            \"spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}\"\n        })\n\npublic abstract class AbstractIntegrationTest {\n    @BeforeEach\n    void genericSetup() {\n        BDDMockito.reset(EnableSpyBeanPostProcessor.spies.toArray(new Object[] {}));\n    }\n}\n\npublic class UsePostgreSqlExtension implements BeforeAllCallback {\n    public UsePostgreSqlExtension() {\n    }\n\n    public void beforeAll(ExtensionContext context) {\n        PostgresTestContainer.getInstance().start();\n    }\n}\n\n//In the same/parent package where the tests lie\n@TestConfiguration\npublic class TestConfig {}\n\n@Component\npublic class EnableSpyBeanPostProcessor implements BeanPostProcessor {\n    private static final List&lt;Class&lt;?&gt;&gt; beansToSpy = List.of();\n\n    public static List&lt;Object&gt; spies = new ArrayList&lt;&gt;();\n\n    @Override\n    public Object postProcessAfterInitialization(@NotNull Object bean, @NotNull String beanName)\n            throws BeansException {\n        if (beansToSpy.stream().noneMatch(it -&gt; it.isAssignableFrom(bean.getClass()))) return bean;\n        Object b = BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n        Object spy = spy(b);\n        spies.add(spy);\n        return spy;\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<div class=\"accordion\">\n<h2>Coding and Review Guidelines</h2>\n</div>\n\n<p>Background<br />\nClean code (and hence a good maintainable system) requires a lot of continuous effort. The result of avoiding it becomes clear only after it becomes too late to fix it. So apart from typical generic guidelines/principles like KISS, SOLID etc, here are some custom principles we can adopt in order to achieve quality.</p>\n\n<p>Important: Keep evolving the document by discussing within the team.</p>\n\n<p>Classes:<br />\nMaximum 50 lines of code.</p>\n\n<p>Only one responsibility, connected to a maximum of 5 other classes.</p>\n\n<p>Except for facades, maximum one primary method (there can be variants of primary method/overloaded version)</p>\n\n<p>Primary method should contain all the overview of logic, just like plain English, this can be achieved with proper naming, and use of functional patterns. One should not have to navigate to many places to find all the logic and scenarios. (No guarantee, but this alone can force the good code structure with high readability and low complexity)</p>\n\n<p><br />\nMethods:<br />\nAvoid booleans as parameters, this creates cognitive complexity.</p>\n\n<p>Should &nbsp;have maximum 1 level of if-else.</p>\n\n<p>loop body should be maximum 2 lines. This requires extraction into methods.</p>\n\n<p><br />\nFormatting &amp; Conventions:<br />\nMaximum 3 levels of indentation. This requires extraction into variables, methods.<br />\nNaming should be such that it makes it easy to understand the requirements for implementation.&nbsp;</p>\n\n<p><br />\nTesting:<br />\nTests should have maximum readability, such that just by reading the test you should be able to figure out all the logic.</p>\n\n<p>Fundamentals of creating test cases:<br />\nTest that the piece of code (method/class/component/system) does what it is supposed to do.<br />\nTest that the piece of code does not do what it&rsquo;s not supposed to (i.e. it doesn&rsquo;t have side-effects). For example, if a piece of code is written to delete something, verify that it does not delete what it&rsquo;s not supposed to delete. However, there can be an infinite number of things to check here, use your own discretion to decide what should be verified. Think about verifying at least the data that is closely related to the functionality.</p>\n\n<p>There should be tests at different levels:&nbsp;<br />\non unit level (to test methods, classes),&nbsp;<br />\non an inter-module(to test that it works as expected when some object/class is used from one module into another module, e.g. when something is used from the repository layer into the service layer). These can result in one or more integration tests.<br />\nOn system level (to test that everything works when all the modules and dependencies are engaged)</p>\n\n<p>In integration tests, you want to mock as little as possible, and use upper-level operations as much as possible (i.e if the integration-test is in service layer, give priority to calling APIs over directly using service methods, and give priority to service methods instead of directly using repository methods).<br />\nBecause in integration tests you want to test the integration between components and not directly control the nuts and bolts of implementation.</p>\n\n<p>Tests involving lists (either as a parameter or return type or a field of a class) should cover scenarios with 0 items, 1 item and multiple items.</p>\n\n<p>There should be tests for both negative and positive scenarios. E.g. if a method returns an Optional there should be at least one assertion on empty and one on non-empty.</p>\n\n<p>Avoid using constructors, use the \\@InjectMocks&nbsp;</p>\n\n<p>There should be external/service layer test (either API, or event), domain layer test, persistence layer test.</p>\n\n<p>Be extra cautious when PR contains changes in test assertions/expectations.</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "hidden", "tags": [], "img": "", "summary": "", "lastUpdated": "2024-02-15 12:52:58.917360"}