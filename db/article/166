{"name":"Designing a Garbage Collector","id":166,"content":"<p>To design anything [system], we must first see what the system is about.&nbsp;</p>\n\n<h2>The purpose of the system:</h2>\n\n<pre>\n<code class=\"language-java\">public class Main {\n    public static void main(String[] args) {\n        Person p = new Person(\"Kabir\", new City(\"Banaras\"));\n        p = new Person(\"Rahim\", new City(\"Delhi\"));\n        p = new Person(\"Augustine\", new City(\"Hippo Regius\"));\n    }\n    private static class City {\n        private String city;\n\n        public City(String city) {\n            this.city = city;\n        }\n\n        public String getCity() {\n            return city;\n        }\n\n    }\n    private static class Person {\n        private String firstName;\n        private City city;\n\n        public Person(String firstName, City city) {\n            this.firstName = firstName;\n            this.city = city;\n        }\n\n        public String getFirstName() {\n            return firstName;\n        }\n\n        public City getCity() {\n            return city;\n        }\n    }\n}</code></pre>\n\n<p>The above main method&#39;s code from a Java program creates an object and assigns it to a variable, then creates another object. Now at this point, what happens to the first object that was created? There was only one way to access that object via reference variable <code><font face=\"monospace\">p</font></code>, but now the same reference variable is pointing to another object. So, the first object even though is in memory cannot be reached by the program. This object we call &mdash; <strong><em>garbage</em></strong>. And, not only the first <code>Person</code> object becomes garbage (<em>unreachable</em>) but&nbsp;<code>City</code> and <code>name</code>&nbsp;referenced by that&nbsp;<code>Person</code> object also become garbage.</p>\n\n<p>Our system needs to find out which objects have become garbage so far.</p>\n\n<p>Is that all? Just identify the garbage?&nbsp;</p>\n\n<p>No, if we keep creating objects in the above program in the same way, at some point of time there will be no memory left to create new objects. Because the system [memory allocator] will see that memory locations are consumed by [garbage] objects. So, we also need to tell the system that the memory locations consumed by the identified garbage objects are now &#39;<em>free</em>&#39; to use again.</p>\n\n<p>&nbsp;</p>\n\n<p>Now, to create any system/algorithm we have to see it in some abstract form and apply our existing knowledge to solve it.</p>\n\n<h2>Abstraction</h2>\n\n<p>We see that there are some references, which can move from one object to another. The objects themselves contain some other references. That&#39;s all we need to know to solve our purpose. We don&#39;t need the complete details of what&#39;s inside an object.</p>\n\n<p>So, we can see this in form of a <em>Directed Graph</em> of a fixed set of <em>Nodes </em>(objects). Fixed, because the memory is fixed in the system.</p>\n\n<p>However, the shape of the graph can change as the program creates more and more objects, and reassigns references.</p>\n\n<p>The nodes can have either zero, or one or two at max [for simplicity]&nbsp;<em>outgoing</em> <em>edges</em> from them.</p>\n\n<p>We have some special nodes which are starting points, called <em>Roots.</em>&nbsp;These represent local variables of the main method, static reference variables of the class etc. Because they are directly available to the program, hence the starting points, and will remain there as long as the main method is running.</p>\n\n<p>From these <em>Roots</em> every node that is reachable via edges is within the <em>Data-Structure</em> (as we call it), and every node outside (<em>unreachable</em>) is <em>Garbage</em>.</p>\n\n<p>Now, what sort of modifications to the <em>[shape of]</em> data-structure can&nbsp;the program cause?</p>\n\n<p>Remember, there are two sort of nodes in data-structure: reachable and unreachable.</p>\n\n<p>Then the following modifications by <em>mutator</em> (i.e. program)&nbsp;are possible (white circle represents <em>not-yet-reachable</em> node, colored circle represents <em>reachable</em> node, X means <em>whatever</em>):-</p>\n\n<p><img alt=\"5 types of mutator modifications\" onerror=\"this.src=&quot;img/undefined.jpg&quot;/\" src=\"/images/gc_modification_types.jpg\" style=\"max-width: 400px; max-height: 400px;\" /></p>\n\n<p>These basically represents that program can assign reference to a reachable node, or not-yet-reachable node (e.g. newly created object), it can redirect references.&nbsp;</p>\n\n<p>There is also a <strong><em>Free-List</em></strong> which is the collection of nodes identified as garbage and which is available to to be added to the datastructure.</p>\n\n<p>&nbsp;</p>\n\n<h2>Concurrent Collector</h2>\n\n<p>We need our Garbage Collector to be able to work concurrently while the program is running. We don&#39;t want to halt the program while the collector is doing its work.&nbsp;</p>\n\n<p><strong>WHY?</strong> - Minor reason is that program is halted unnecessarily (from program&#39;s point of view).&nbsp;Major reason is the unpredictability of GC (Garbage Collector) interludes, which makes it hard to design such systems so as to meet real-time requirements. <em>(You don&#39;t know how much time GC is gonna take to collect garbage)</em></p>\n\n<p>Now, concurrent algorithms require <a href=\"https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies\" target=\"_blank\">Atomic Operations</a>. And remember, even [reference]&nbsp;<em>assignment</em> is not an atomic operation by default.</p>\n\n<p>We can develop concurrent solutions in a <em>Coarse-grained</em> or <em>Fine-grained</em> manner.</p>\n\n<p><em>&quot;A is coarser-grained than B or B is finer-grained than A&quot;</em>&nbsp;or <em>&quot;A has coarser-grain of action&quot;</em>&nbsp;if B is the result of replacing an atomic operation of A by a piece of programs containing at least two atomic operations, and having <em>all by itself</em>, the same net effect as the original operation.</p>\n\n<p><strong>Why are we talking about Coarse-grained and Fine-grained solutions?</strong></p>\n\n<p>Because coarse-grained solutions are easier to verify/prove their correctness. However, they require more severe mutual-exclusion resources. So, we will start with a coarse-grained solution and prove its correctness and then move on to create a finer-grained solution.</p>\n\n<p>&nbsp;</p>\n\n<h2>First Coarse-Grained Solution</h2>\n\n<p>To arrive at a solution, we need to first reduce the complexity of viariety of actions that the program can make. First, let&#39;s introduce a special sort of root node: one which has both of its outgoing edges towards itself, let&#39;s call it <strong><em>NIL</em></strong> node.</p>\n\n<p>Looking closely, we see that type<strong><em> </em>(III)<em> </em></strong>and type <strong>(V)</strong> of mutator actions are just special form of type <strong>(I)</strong>. Similarly, type <strong>(IV)</strong> is a case of type <strong>(II)</strong>.</p>\n\n<p>So, effectively we have just two types of mutator actions.</p>\n\n<p>Now, let&#39;s perform another trick. So far, free-list of nodes is out of the data-structure. If we introduce some special root nodes such that only free-list and NIL can be accessible from them, we can include free-list as well in our data structure.</p>\n\n<p>Now, mutator action of type <strong>(II)</strong> can be achieved from mutator action of type <strong>(I)</strong> in the following way:- 1. Redirect the outgoing edge to one of free-list nodes (which is also be reachable);&nbsp;2. Redirect edges in free-list so as to remove the target node from free-list. Remember, the order is important, so that the node in the question doesn&#39;t ever go out of reachability for even a short period of time.</p>\n\n<p><img alt=\"Type-2 modification as Type-1\" src=\"/images/gc_mutator_type_2_modifications.jpg\" style=\"max-width: 600px; max-height: 250px;\" /></p>\n\n<p>So, effectively we are left with only one type of mutator action, type <strong>(I)</strong>.</p>\n\n<p>Before designing an algorithm, we must first set our goals as well as correctness criteria <em>(how can we be sure that we are doing the right thing)</em></p>\n\n<p>The goals and correctness criteria are:-</p>\n\n<ol>\n\t<li>Every garbage node is <strong><em>eventually</em></strong> appended to the free-list.</li>\n\t<li>Appending a garbage node to the free-list is the collector&#39;s only modification of (the shape of) the data structure.&nbsp;</li>\n</ol>\n\n<p>We assume that we have some facility of making following operations <em>atomic</em>:-</p>\n\n<ul>\n\t<li>Redirecting an edge</li>\n\t<li>Finding (the left or right) successor of a node</li>\n\t<li>testing and/or setting certain attribute of a node</li>\n</ul>\n\n<p>Our idea is simple, we will perform the overall task of GC in two phases:-</p>\n\n<ol>\n\t<li>Identify and mark all reachable nodes (<em>non-garbage</em>)</li>\n\t<li>Append all unmarked nodes (<em>garbage</em>)&nbsp;to the free-list and remove marking from all marked nodes.</li>\n</ol>\n\n<p>Lets play this out in an example where mutator (program) is making some unusual changes. A, B, C are three reachable nodes, C is reachable only from A initially. And mutator makes following changes sequentially.</p>\n\n<p><img alt=\"Counter_example_1\" src=\"/images/gc_counter_example_1.jpg\" style=\"max-width: 500px;\" /></p>\n\n<p>So, (since our&nbsp;GC performs its actions&nbsp;concurrently) it&#39;s quite possible that our collector might consider node C as garbage, while it never actually is garbage.</p>\n\n<p>So, we have to take some help from mutator (program), so that mutator itself marks the target node whenever it makes a redirection. In that way GC will never find the node C unmarked and hence garbage.</p>\n\n<p>&nbsp;</p>\n\n<p>So, we have the first phase of our algorithm. Identify and mark all reachable nodes. But this is a repetitive task (you cannot mark all reachable nodes in one go), <strong><em>when do we know that we should stop marking cycle now?</em></strong></p>\n\n<p>For that let&#39;s set an <a href=\"https://en.wikipedia.org/wiki/Invariant_(mathematics)\" target=\"_blank\">Invariant</a>&nbsp;which will be true before and after marking cycle. Colors of node: White means it is unmarked, Black means it has been marked.</p>\n\n<div class=\"math\">P1: \\text{ No edge points from Black node to a White node}</div>\n\n<p>This, obviously is true initially, but what happens when mutator performs below actions:-</p>\n\n<p>Mutator adds an edge from a Black node to a White node, this violates P1.</p>\n\n<p>What if mutator just marks the target to Black? &mdash; Even then we have a problem, since there may be successors of the new target node which are White.</p>\n\n<p>A trick: Use another color Gray. Mutator marks the target as Gray, which basically means that it is candidate for marking (non-garbage) but it has not been marked <strong><em>yet, because there might be White successors</em></strong>. This marking must be an atomic operation. Atomic operations are represented within angle brackets hereon.</p>\n\n<div class=\"math\">M1: \\lt \\text{redirect an outgoing edge of a reachable node towards an already reachable node, and shade the new target} \\gt</div>\n\n<p>M1 is mutator&#39;s only operation. For collector, whenever it encounters Gray node, it must mark it Black and shade all its successors Gray, Let this entire operation be atomic. Marking phase terminates when there are no gray nodes.</p>\n\n<p>Our coarse-grained solution then executes the following program repeatedly: This is a pseudo-code and Invariants are written in {} brackets.</p>\n\n<pre>\n<code class=\"language-python\">\"marking phase:\"\nbegin {there are no Black nodes}\n  \"shade all the roots\" {\"P1 and there are no White roots\"}\n  i := 0, k := M;\n  \"marking cycle:\"\n  do while k &gt; 0: {\"P1 and there are no White roots\"}\n     &lt;c := color of node nr i&gt;;\n     if c = Gray:\n         k := M;\n         C1: &lt;shade all the successors of node nr i and make node nr i Black&gt;;\n     else if c != Gray:\n         k := k - 1;\n     i = (i+1) mode M;\nend {\"\"\"P1 and there are no White roots and no Gray nodes hence, \n        as easily seen, all white nodes are garbage\"\"\"}\n\n\"appending phase:\"\nbegin i := 0;\n     \"appending cycle:\"\n     do while i &lt; M: {\"\"\"all nodes with a number &lt; i are either White or Gray, \n                      all nodes with a number &gt;= i are Black or White \n                      and garbage if White\"\"\"}\n         &lt;c := ccolor of node nr i&gt;;\n         if c = White:\n            &lt;append node nr i to the free-list&gt;\n         else if c = Black:\n            &lt;make node nr i White&gt;;\n         \n         i := i + 1;\n     {\"There are no black nodes\"}\n end\n     </code></pre>\n\n<p>Note: Appending a node to free-list includes redirecting its outgoing edges so that no other nodes than NIL or free nodes can be reached from it. Also, it does not matter in which order nodes are examined during marking phase.</p>\n\n<p>If the initial data-structure is like this:-</p>\n\n<p><img alt=\"GC_Initial state\" src=\"/images/gc_initial.jpg\" style=\"max-width: 500px; max-height: 400px;\" /></p>\n\n<p>After marking phase completes, it will be like this:-</p>\n\n<p><img alt=\"GC After Marking State\" src=\"/images/gc_after_marking.jpg\" style=\"max-width: 500px; max-height: 400px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p>Now, we need to <em>prove</em>&nbsp;that this program does only what is desired and nothing else.&nbsp;</p>\n\n<h2>Proof of Correctness</h2>\n\n<p>There are two criteria to prove for correctness:</p>\n\n<p><strong>CC1:</strong>&nbsp;Appending the garbage (and only garbage) node to the free-list is the only modification that our program makes to the data-structure (graph).</p>\n\n<p><strong>CC2:</strong>&nbsp;Every garbage node is eventually appended to the free-list. More precisely, every garbage node present at the beginning of an <em>appending phase</em>&nbsp;will have been appended by the end of the next appending&nbsp;phase.</p>\n\n<p><strong><u>Let&#39;s consider CC1 first:-</u></strong></p>\n\n<p>Marking phase clearly cannot violate it, since it doesn&#39;t modify the data-structure.</p>\n\n<p>Appending phase appends a node to free-list only after having it observed White, so the it is sufficient to show that&nbsp;the invariant: <em>&quot;A White node with number &gt;= i is garbage&quot;&nbsp;</em>is true&nbsp;</p>\n\n<ol>\n\t<li>When entering the appending cycle</li>\n\t<li>During the repeatition of the appending cycle</li>\n</ol>\n\n<p><strong>During repetition, how can the collector violate this invariant?</strong></p>\n\n<p>&nbsp;By making non-garbage node White, or by making White garbage node into non-garbage.</p>\n\n<p>&nbsp;By alternate construct either violation is possible, but only with respect to node nr i; we can still guarantee that <em>&quot;A White node with nr &gt; i is garbage&quot;</em>. And i is increased in loop, also i is a local variable so the invariant is restored after execution of i := i+1. <em>[This is a bit confusing to me!]</em></p>\n\n<p><strong>Remember, that mutator is also in action concurrently, so let&#39;s check whether mutator can violate these?</strong></p>\n\n<p>&nbsp;How can mutator violate these? &mdash;&nbsp;In the same way, by making non-garbage node White, or by making White garbage node into non-garbage.&nbsp;</p>\n\n<p>&nbsp;But notice that mutator performs only one action <strong>M1</strong>,&nbsp; which does not make anything White. And, M1&nbsp;redirects edges towards already reachable nodes, hence leaves garbage garbage. So, mutator cannot violate it.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Next, to show that&nbsp;<em>&quot;A White node with number &gt;= i is garbage&quot;&nbsp;</em>is true at the beginning of appending phase:</strong></p>\n\n<p>We have to demonstrate that the marking phase has established that <em>&quot;all White nodes are garbage&quot;</em>&nbsp;<strong>supposing that</strong>&nbsp;at the beginning of marking phase, there are no Black nodes.</p>\n\n<p>Absence of Black nodes&nbsp;&nbsp;&rArr; P1</p>\n\n<p>M1 and C1 have been carefully designed so as to leave P1 invariant and not to introduce any white roots.</p>\n\n<p>So, <em>&quot;P1 and no White roots&quot;</em> is clearly established before and kept during marking cycle.</p>\n\n<p>When furthermore all Gray nodes have disappeared, our target state in which all reachable nodes are Black and all White nodes are garbage has been reached.</p>\n\n<p>When marking cycle finds no Gray nodes after scanning all nodes, it terminates.</p>\n\n<p><em>Remember though, mutator can introduce new Gray nodes [between termination of marking phase and beginning of appending phase], so we have to look carefully.</em></p>\n\n<p>Absence of White reachable nodes prevents the mutator from introducing Gray ones.</p>\n\n<p>Absence of Gray nodes prevents GC from introducing Gray nodes.&nbsp;</p>\n\n<p>Mutator leaves Gray nodes as it is, GC didn&#39;t color [to White or Black] any nodes during the scan, a Gray node existing at the beginning would have been encountered during that scan. Hence we can conclude that upon the termination of marking phase all White nodes <strong>are indeed garbage</strong>.</p>\n\n<p>Because the appending phase makes all Black nodes White, and the mutator doesn&#39;t introduce Black nodes; there are no Black nodes at the end of the appending phase, this justifies the assumption made above that <em>&quot;There are no Black nodes at the beginning of marking phase&quot;</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong><u>Now, to show that CC2 is met:-</u></strong></p>\n\n<p>First, we have to show that two phases terminate properly.&nbsp;</p>\n\n<p>Proper termination of appending phase is obvious, except for one thing: node nr <em>i</em> must be Black or White, not Gray. But we have already proved that at the end of the marking phase there are no Gray nodes and every White node is garbage. Mutator cannot shade a garbage node, and shading a garbage node anyway has no effect.</p>\n\n<p>Termination of the marking phase follows from the fact that the integral quantity k + M*(the number of nonblack nodes) &mdash; which, by definition, is nonnegative &mdash;&nbsp;is left invariant by the activity of the mutator, and is decreased by at least one in each iteration of the marking cycle.</p>\n\n<p>Consider now the situation at the beginning of an appending phase. At that moment, the nodes are partitioned into three sets:</p>\n\n<ol>\n\t<li>The set of reachable nodes (they are black)</li>\n\t<li>The set of white garbage nodes (during the first appending phase to come, they will be appended to the free list)</li>\n\t<li>The set of black garbage nodes (during the first appending phase to come, they will not be appended to the free list, but they will be made white). <em>Let&#39;s call these D-nodes.</em></li>\n</ol>\n\n<p>We have to now show that D-nodes will be appended to free-list in the next [second] appending cycle.</p>\n\n<p><img alt=\"Sources of D Nodes are. always White\" src=\"/images/gc_d_nodes_1.jpg\" style=\"max-width: 500px; max-height: 150px;\" /></p>\n\n<p>Because D-nodes are garbage, we can say that at the beginning of first appending phase sources of edges leading into D-nodes are White garbage nodes.&nbsp;</p>\n\n<p>Since D-nodes are garbage, mutator will not redirect edges so as to make them point to a D-node. And since they are Black to start with, during the first appending phase, collector will not do so either. However, the collectpr will append all garbage nodes to free-list which includes redirecting outgoing edges of the nodes appended. So, as a result, we have at the end of the first appending phase:</p>\n\n<ol>\n\t<li>All D-nodes are White garbage nodes.</li>\n\t<li>There are no edges leading into D.</li>\n</ol>\n\n<p><strong>Okay, so we have established that at the end of the first appending phase all D-nodes are White garbage, but what about the next marking phase, do they change?</strong></p>\n\n<p>Mutator cannot redirect to garbage D-nodes. Collector does not redirect edges during marking phase, And because they are White, collector won&#39;t shade them. So, effectively at the end of next marking phase, the White garbage D-nodes will still remain garbage White nodes, and will be appended [to free-list] during&nbsp;the next appending phase.</p>\n\n<p>Hence, CC2 is also met.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>So, is the solution above good enough?</strong></p>\n\n<p>Well, first we need to convert this into a fine-grained solution (because implementing a course-grained solution is computationally costly), and then see if it works.</p>\n\n<p>Let&#39;s keep P1 as invariant, and divide M1 into two atomic operations:</p>\n\n<ol>\n\t<li>&nbsp;Redirecting the edge</li>\n\t<li>Shading the new target</li>\n</ol>\n\n<p>In order to keep P1, mutator had to shade first and then redirect there. But, there&#39;s a catch:</p>\n\n<p>Consider the following sequence of events:</p>\n\n<ol>\n\t<li>Mutator wants to redirect an edge from node A to node B. So, it shades node B. Then goes to sleep.</li>\n\t<li>Collector goes through complete marking phase, and then appending phase. Consequently,&nbsp;it makes node B White.&nbsp;</li>\n\t<li>Collector goes through next [second] marking phase, [it happens that] it makes node A black, and leaves B White. Then, collector goes to sleep.</li>\n\t<li>Mutator wakes up, introduces an&nbsp;edge from A to B. <strong>(P1 is now violated)</strong></li>\n\t<li>Mutator removes all other ingoing edges of B (the absence of garbage makes it possible). Then goes to sleep. <strong>Node B is now only reachable via the edge from A.</strong></li>\n\t<li>Collector completes its marking phase, node B has remained&nbsp;White.</li>\n\t<li>Collector goes through its appending phase during which the reachable node B is erroneously appended to the free-list.</li>\n</ol>\n\n<p>This demands some variation of mutator logic.</p>\n\n<p>We also have to weaken relationship P1. Note that P1 allowed us to conclude that during marking cycle if P1 is valid, and there&#39;s a White node reachable it must be through some Gray node, hence the existence of Gray node.</p>\n\n<p>We need something that allows us to make same conclusion.</p>\n\n<p><strong><em>Propagation path</em></strong>: a path formed by nodes and edges such that it starts from a Gray node, and the target of each edge is some White node. The Gray node is not necessarily reachable.</p>\n\n<p><span class=\"math\">P2: \\text{For each reachable White node, there exists some Propagation Path leading to it}</span></p>\n\n<p>P2 is automatically satisfied if each root is Gray or Black, and there are no Black&nbsp;&rarr; White edges. So, at the beginning of marking phase, P2 is true because there are only Gray nodes and no Black nodes.</p>\n\n<p>We can use P2 to conclude that <em>&quot;absence of Gray nodes implies all White nodes are garbage&quot;</em>&nbsp;during the marking cycle (just like we used P1 to prove correctness above). However, P2 is a weaker relation and can be broken. <em>[Need an example on how?] </em>So, let&#39;s introduce another relation analogous to P1, but weaker.</p>\n\n<div class=\"math\">P3: \\text{Only the last edge placed by mutator can be from Black to White node}</div>\n\n<p>So, P3&nbsp;also holds at beginning of marking cycle, because there&#39;re no Black nodes.</p>\n\n<p>Now, we just have to show that P2 and P3 are invariant during marking cycle.</p>\n\n<p>To show that the marking cycle leaves P2 and P3 invariant, we must show that atomic operation <em>C1: &lt;shade successors of node nr i and mark it Black&gt;</em> cannot destroy its truth. Shading a node cannot make P2, P3 false. Shading successors of a node means that its outgoing edges are no longer part of any &quot;Propagation path&quot;, so making that node Black immediately afterwards does not make P2 false. Moreover, successors are shaded, so making the node Black cannot introduce a&nbsp;&nbsp;Black&nbsp;&rarr; White edge. Hence cannot make P3 false either.</p>\n\n<p>So, we see that there&#39;s no way marking cycle can make P2, P3 false.</p>\n\n<p>Now, we just have to define a mutator action which leaves P2 and P3 invariant.</p>\n\n<div class=\"math\">M2: \\lt \\text{Shade the target of the previously redirected edge, and redirect an outgoing edge of a reachable node towards a reachable node} \\gt</div>\n\n<p>Note: For the first time when mutator redirects an edge, just shade an arbitrary node for simplicity.</p>\n\n<p>M2 has been carefully chosen so that it does not violate P3, but does it violate <span class=\"math\">P2 \\land P3</span>? Let&#39;s look closely:</p>\n\n<p>M2 cannot introduce a new reachable node, hence every White node which is reachable after the operation had a &quot;propagation path&quot; leading to it before the operation.</p>\n\n<p>If node whose successor is redefined is Black, then its outgoing edge was not part of any propagation path, so the edges of old propagation paths will be sufficient to provide propagation paths needed to maintain P2. (We may not need all of them, because of the shading operation and because some White reachable nodes may have been made unreachable).</p>\n\n<p>If node whose successor is redefined was White or Gray, then the net result of the action M2 will be a graph without Black&nbsp;&rarr; White edges: if one existed its target has now have been shaded, and no new one can be added because the source is not Black. The roots must still be Gray or Black, hence P2 holds true.</p>\n\n<p>From this new version of coarse-grained solution, we can easily get to a finer-grained solution. Refer to the paper for the listing of finer-grained solution.</p>\n\n<p>Source: <a href=\"https://lamport.azurewebsites.net/pubs/garbage.pdf\" target=\"_blank\">Dijkstra-Lamport&#39;s Paper on GC</a></p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"architecture","tags":null,"img":null,"summary":null,"lastUpdated":"2020-06-14T04:09:57.815+0000"}