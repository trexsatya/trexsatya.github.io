{"name":"ClassLoaders and Associated Problems","id":84,"content":"<h2>What is a class loader?</h2>\n\n<hr />\n<p>When you have written a class, and java compiler has compiled it into bytecodes. Then to use this class, it needs to be <em>loaded</em> into the memory. For that Java uses ClassLoader implementations.</p>\n\n<pre>\n<code class=\"language-java\">//Highlights of JDK ClassLoader\n\npublic abstract class ClassLoader {\n  public Class loadClass(String fullNameOfClass){ .. }\n  \n  protected Class defineClass(byte[] bytecode){\n    //...\n    //Resolve, run security checks, apply permissions, etc\n  }\n\n  public ClassLoader getParent(){ .. }\n\n  // All the classes loaded\n  private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();\n  \n}</code></pre>\n\n<h2><br />\nWhen does class actually get loaded?</h2>\n\n<hr />\n<p>Class is not loaded until you really need it. Remember just importing a class does not mean that you need it. Class is loaded when you call the constructor or refer to some static member of the class.</p>\n\n<pre>\n<code class=\"language-java\">public class A{\n\tpublic void doSomething(){\n\t\tB b = new B(); // This means that class has to be loaded, like this A.class.getClassLoader().loadClass(\"B\");\n// A.class beacuse this represents the context in which we are trying to load the class\n\n\t\tb.doSomethingElse();\n\t}\n}\n</code></pre>\n\n<h2><br />\nOK, But what about the classes that we don&#39;t define? How are they loaded?</h2>\n\n<hr />\n<p>When the JVM starts it uses three different class loaders, which load the classes you are gonna require.</p>\n\n<p>Bootstrap class loader loads classes from libraries under this directory:&nbsp;&lt;JAVA_HOME&gt;/jre/lib</p>\n\n<p>Extension class loader: loads classes from libraries under this directory:&nbsp;&lt;JAVA_HOME&gt;/jre/lib/ext<br />\n&nbsp;&nbsp; &nbsp; It can also load other classes, but you have to tell JVM using a System property <strong>&quot;java.ext.dirs&quot; to point to the directory containing classes/libraries.</strong></p>\n\n<p>System class loader or App class loader: loads classes found on&nbsp;<strong>java.class.path </strong>which maps to CLASSPATH environment variables.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>OK, But can I create my own class loaders? Is there any benefit of doing so?</h2>\n\n<hr />\n<p>Yes you can create your own custom loaders, many have done it. It helps in following ways:</p>\n\n<ol>\n\t<li>You can implement scripting languages like <a href=\"https://www.jython.org/\" target=\"_blank\">Jython</a> (a Java implementation of Python).</li>\n\t<li>You can allow multiple namespaces, CORBA and RMI technologies use it. And since Java EE is based on RMI, Java EE uses it heavily.</li>\n\t<li>You can change and control the way the bytecode is loaded. E.g. you can load encrypted bytecodes to enforce extra security.</li>\n\t<li>You can change the loaded bytecodes. AOP frameworks use this to perform weaving and provide super capabilities to normal classes.</li>\n</ol>\n\n<p>Containers like Tomcat use custom classloader&nbsp;so that&nbsp;It isolates the various web applications deployed into the container; that is, the behaviour of a web application will not be affected by (un)deploying another web application. Similarly,&nbsp;OSGI bundles get their own class loaders so different bundles can use different versions of the same plugin. Again, this isolation makes it less likely that adding a plugin (with its dependent libraries) will affect the other plugins in the system.<br />\n<a href=\"https://stackoverflow.com/questions/3550175/why-do-we-need-user-defined-classloader-in-java\" target=\"_blank\">why need user defined classloader</a></p>\n\n<p>&nbsp;Basically, you need user-defined classloaders if you need to load classes or resources in <strong><em>&quot;unusual&quot;</em></strong> ways... such as from an EAR or WAR file. As another example, you might load classes from a database, or from some secure storage.</p>\n\n<h2><br />\nWhat&#39;s with the Parent, why do we need it?</h2>\n\n<hr />\n<p>The task of loading class can be delegated to parent class loader, which might be able to load it and if it already has loaded then we can reuse it.&nbsp;</p>\n\n<p>Before trying to load&nbsp;the calss by self, the class loader asks parent to do so. Might be that parent already has loaded it earlier, and this will save time.</p>\n\n<p>However in Java EE, story is different. Java EE containers e.g. JBoss, WebSphere&nbsp;they try to load the class first, and it it is not found then only parent is asked to load it.</p>\n\n<p><br />\nHere are some typical classloader related problems:</p>\n\n<hr />\n<h2><br />\nProblem: I am getting NoClassDefinitionFoundError&nbsp;</h2>\n\n<p>Find the root cause. Try to inspect where the applcation is trying to load the class from?</p>\n\n<p>You can use container logs to do so. Or use a small code e.g.</p>\n\n<pre>\n<code class=\"language-java\">((URLClassLoader)(class containing the problematic class which was not found).getClassLoader()) .getURLs()</code></pre>\n\n<h2><br />\nProblem: I am getting NoSuchMethodError, NoSuchFieldError, AbstractMethodError</h2>\n\n<p>This might be caused by version update, caching used by container to maintain loaded classes.</p>\n\n<pre>\n<code class=\"language-java\">class.getClassLoader().getResource(full name of class containing the method, replacing dot with slash + \".class\")</code></pre>\n\n<p>&nbsp; &nbsp; It will tell you where the class is loaded from;<br />\n&nbsp;&nbsp; &nbsp;Go to that place and use javap to see the structure of that class.</p>\n\n<p>Problem:&nbsp;ClassCastException even though both the classes have same name.</p>\n\n<p>A class is uniquely identified by not just the fully qualified class name (i.e. package name + class name), but also the class loader used to load this class. If same class is loaded by different loaders, they are not same, they can not be cast to each other.</p>\n\n<p>And when the context is same, but two different loaders are loading the same class, following errors might also appear:</p>\n\n<p>LinkageError, IllegalAccessException</p>\n\n<h2>Class Loaders might cause OutOfMemoryError, which you might usually see when you redeploy an application multiple times in containers, e.g. in Tomcat</h2>\n\n<p>When you redeploy, if this scenario happens that every time a new object is added to and reference is kept. Since each object has reference to it&#39;s class, which has reference to its class loader, which has reference to all the classes loaded..This causes OutOfMemoryError.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java/6471947#6471947\" target=\"_blank\">https://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java/6471947#6471947</a></p>\n\n<p><a href=\"https://stackoverflow.com/questions/1464291/how-to-really-read-text-file-from-classpath-in-java/1464366#1464366\" target=\"_blank\">https://stackoverflow.com/questions/1464291/how-to-really-read-text-file-from-classpath-in-java/1464366#1464366</a></p>\n\n<p>Summary:</p>\n\n<pre>\n<code class=\"language-java\">// From ClassLoader, all paths are \"absolute\" already - there's no context\n// from which they could be relative. Therefore you don't need a leading slash.\nInputStream in = this.getClass().getClassLoader()\n                                .getResourceAsStream(\"SomeTextFile.txt\");\n// From Class, the path is relative to the package of the class unless\n// you include a leading slash, so if you don't want to use the current\n// package, include a slash like this:\nInputStream in = this.getClass().getResourceAsStream(\"/SomeTextFile.txt\");</code></pre>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-38","tags":["medium"],"img":"/images/classloader.jpg","summary":null,"lastUpdated":"2018-07-01T13:59:23.519+0000"}