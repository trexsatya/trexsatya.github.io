{"name": "Object Oriented Designing", "id": 180, "content": "<h2>Object Oriented Analysis</h2>\n\n<p>The philosophy of <em>Object Oriented Programming</em> is to see everything as an object. What do we mean by <em>everything</em>? By everything we mean literally everything. What are the examples?</p>\n\n<p>Entities that we can see in real world: Man, Woman, Cat, Dog, Tree, Car etc.</p>\n\n<p>Abstractions: What are abstractions? (<em>This can go as philosophical as you try, there is no definite explanation</em>). Ideas, Actions, Abilities, Categories, behaviours, structures etc are abstractions. For example, though you can see Cat and Dog through your eyes, can you see Animal through your eyes? - Yes and No. By seeing Cat and Dog, you just saw an Animal (an example/representation/instance of Animal to be precise), but you can never see Animal through your eyes. More importantly, what are the necessary properties of an Animal without which it can&#39;t be an Animal?</p>\n\n<p>Data-Structures: Array, List, Map etc are examples of data structures which can be seen objects.</p>\n\n<p><span style=\"font-size:20px;\"><strong>Process of object oriented analysis:</strong></span></p>\n\n<ol>\n\t<li>Identify and represent real entities/objects.</li>\n\t<li>Identify and represent abstract entities using interfaces or abstract classes.</li>\n\t<li>Ask &#39;How do these entities relate to each other?&#39; &amp; &#39;How should they talk to each other?&#39;. We are developing a system, it should not be chaotic, anyone talking to anyone at anytime. It should also not be closed. There is no way to talk to someone. We also want to avoid situations like &#39;One entity has more responsibilities than necessary &amp; hence becoming God&#39;.</li>\n\t<li>Find commonality and create hierarchical relationships of abstract or real entities.</li>\n\t<li>Apply knowledge of OOP principles, Inheritance, Composition, Aggregation, Design Patterns.</li>\n</ol>\n\n<p><span style=\"font-size:20px;\"><strong>OOP Principles:</strong></span></p>\n\n<p><strong>Abstraction:</strong> <em>&quot;Tell me What do you want rather than telling me how to do it.&quot;</em>&nbsp;</p>\n\n<p><strong>Encapsulation:</strong> <em>&quot;Don&#39;t worry about how I&#39;m doing it and also you can&#39;t depend on how I&#39;m doing it.&quot;</em></p>\n\n<p><strong>Inheritance:</strong> X is Y. If you are asking for Y and I give you X, it shouldn&#39;t matter to you. However remeber, X is Y means X has everything that Y has and X is dependent on Y in hidden ways, because unlike real life, if father changes, child maybe completely unaffected here in OOP world if father changes, it can affect child in many ways.</p>\n\n<p><strong>Aggregation:</strong> <em>&quot;Xs-are-part-of-Y conceptually not necessarily physically&quot;</em>. Another way to say is <em>&quot;Y uses X(s)&quot;</em>. If Y goes away, it doesn&#39;t mean X&#39;s will go away too.</p>\n\n<p><strong>Composition:</strong> <em>&quot;X is owned by Y&quot;</em>. If Y goes away, X goes away too. <em>&quot;X is only a part of Y, with no separate existence&quot;</em>.</p>\n\n<p><strong>Links:</strong> There are three types of links.</p>\n\n<ol>\n\t<li style=\"margin-left: 40px;\">Controller: Nonbody calls this, this can call everybody</li>\n\t<li style=\"margin-left: 40px;\">Server: Can&#39;t call others. Others can call it.</li>\n\t<li style=\"margin-left: 40px;\">Proxy: Can both call and be called.</li>\n</ol>\n\n<p>Finding sameness among objects which generally don&#39;t seem related, can prove to be useful, but can also be not useful. Either way it&#39;s creative though.</p>\n\n<p>More knowledge of domain =&gt; Better <strong>classification</strong> (Stepp and Michalski&rsquo;s study). More vision of anticipated changes also leads to better design, but also slow down process.</p>\n\n<p>What can be considered an object?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Things (Nouns), Roles (Adjectives), Events, Interactions (Verbs), Concepts, Abilities, Plans, Processes.</p>\n\n<p>Using Protoype-Object to establish structure of class. It&#39;s not easy to define anything especially abstract concepts (Plato wrote many books trying to find definition of Virtue, Knowledge etc.). So, sometimes it&#39;s best to use something that we already have established as a prototype.</p>\n\n<p style=\"margin-left: 40px;\">Weitgenstein on games: Games do not have a properly defined boundary, properties. A new game can be considered a game if it resembles with something that is already considered a game. Although two games may not share anything with them. (Apart from the fact that they both are considered game)</p>\n\n<p>Another technique: See the system as Data Flow and Control Flow and identify entities from there.</p>\n\n<p>Remember,</p>\n\n<ol>\n\t<li>There is no right way to classify abstractions.</li>\n\t<li>There is no right way to design the architecture of a given system.</li>\n</ol>\n\n<blockquote>\n<p>&quot;Whatever remains after eliminating all bad designs must be a good design.&quot;</p>\n</blockquote>\n\n<p>Design for Testability and Extendibility/Flexibility; Code for Readability and Maintainability.</p>\n\n<p>Start with Minimal Viable Product - a Working Prototype<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Thinking about every possible requirement is not possible &amp; also not advisable. You need to find a balance.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Assuming that it (some part of your system) won&#39;t change, without substantial proof, is silly.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Leaving no chance for flexibility/change is silly. Or even making it hard to change is silly. We live in a world that&#39;s constantly changing.</p>\n\n<p>&nbsp;</p>\n\n<h2>UML Diagrams:</h2>\n\n<p>Scopes of members in a class:&nbsp;</p>\n\n<ul>\n\t<li>Public (+)</li>\n\t<li>Private (-)</li>\n\t<li>Protected (#)</li>\n\t<li>Package (~)</li>\n\t<li>Derived (/)</li>\n\t<li>Static (underlined)</li>\n</ul>\n\n<p>Connecting two classes:</p>\n\n<ol>\n\t<li>Association (unidirectional [&nbsp;<em>arrowed&nbsp;</em>] or bidirectional [ <em>no arrow</em> ]): also tell count of associations e.g. 0..* (zero or more)</li>\n\t<li>Extends</li>\n\t<li>Aggregation</li>\n\t<li>Composition</li>\n\t<li>Dependency</li>\n</ol>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0b/Uml_class_relation_arrows_en.svg.png\" style=\"width: 300px; height: 200px;\" /></p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/AggregationAndComposition.svg/330px-AggregationAndComposition.svg.png\" style=\"width: 330px; height: 118px;\" /></p>\n\n<p>Two class diagrams. The diagram on top shows Composition between two classes: A Car has exactly one Carburetor, and a Carburetor has at most one Car (Carburetors may exist as separate parts, detached from a specific car). The diagram on bottom shows Aggregation between two classes: A Pond has zero or more Ducks, and a Duck has at most one Pond (at a time).</p>\n\n<h2>Design Of Chess Game</h2>\n\n<p><img alt=\"\" src=\"/images/chess.png\" style=\"width: 1100px; height: 528px;\" />Spot { int x;&nbsp;int y; }</p>\n\n<p>PathTrace has a list of Spots&nbsp;which will represent the paths which can be used to move. Instead of Spots PathTrace could also have the Move strategies&nbsp;like&nbsp;</p>\n\n<p>enum MovePath { LEFT, RIGHT, DIAGONAL, KNIGHTS_MOVE } which given a source Spot could produce the list of Spots.</p>\n\n<p>Board could use these strategies while making a move.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "programming", "tags": [], "img": "", "summary": "", "lastUpdated": "2021-06-27 10:59:09.342350"}