{"name":"Why MongoDB?","id":62,"content":"<div class=\"box1\" style=\"\">Suppose you are using MySQL to store data in your application. Application load increaes in some time, and more users are now visiting your application, and new features are demanded. You realize that in order to add new feature you have to add a column to one of the <strong><em>table</em></strong>s. But then you realize that it&#39;s not so easy, there are so many <strong><em>relations</em></strong>, and with relations come <strong><em>constraint</em></strong>s. So you can&#39;t just go and add a new column in table in your MySQL or any other <em>Relational</em> DB.<br />\nThis is the question of data storage flexibility.<br />\n<span style=\"color:#27ae60;\"><em>Is your system prepared to incorporate such changes in data storage which you had not thought about while doing data modelling?</em></span></div>\n\n<p>&nbsp;</p>\n\n<p>Non-Relational DBs like MongoDB give you the flexibility which can save you in these kinds of situations. In these data is stored in form of (JSON) documents. You can add new &quot;<em>field</em>&quot; anytime to your <em>document</em> structure.</p>\n\n<p>In simple words, these databases have been built for modern day use-cases (Agile changes, and High-Availability Cluster based architecture).&nbsp;</p>\n\n<p>But you cannot replace MySQL or Relational DB with MongoDB or any other Non-Relational DB in every scenario. <em>This could change in future</em>.</p>\n\n<p>Read this:&nbsp;<a href=\"https://www.mongodb.com/compare/mongodb-mysql\">https://www.mongodb.com/compare/mongodb-mysql</a></p>\n\n<p>MongoDB has very good documentation (which is an indication of a good Software) and learning resources and huge community support.&nbsp;<a href=\"https://university.mongodb.com\">https://university.mongodb.com</a></p>\n\n<h2>MongoDB Architecture</h2>\n\n<p>Someone intelligently claimed that: It&#39;s impossible&nbsp;to have all three of these at the same time. (<a href=\"https://en.wikipedia.org/wiki/CAP_theorem\" target=\"_blank\">CAP Theorem</a>)<br />\n<br />\nCONSISTENCY -- You should see the latest update your friend posted.<br />\nAVAILABILITY -- Every time you open the page, you must see something&nbsp;<br />\nPARTITION-TOLERANCE. -- Even if some messages are dropped between nodes, the system should not fail.<br />\n<br />\nIn distributed systems Partition-Tolerance is must, so you have option between Consistency and Availability. Partition Tolerance comes into play when connection between two nodes in the network is either broken or is slow.<br />\n<br />\nMongoDB does not completely support ACID properties before version 4.0.</p>\n\n<div>\n<p>MongoDB is a distributed transactional system.<br />\n&nbsp;&nbsp; &nbsp;Multiple copies of data &nbsp;- Replication<br />\n&nbsp;&nbsp; &nbsp;Read and write operations are directed to the primary replica by default for strong consistency<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;But in certain scenarios, we can read from secondary replicas where it would be beneficial e.g. when users are geographically dispersed, or for isolating operational and analytical workloads running in a single cluster<br />\n&nbsp;&nbsp; &nbsp;MongoDB is highly tunable for consistency and availability<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>ACID Transactions:</strong><br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;For single document<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;For multi-document : supported from version MongoDB 4.0<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nYou can enforce schema if you require<br />\nProvides join like functionality $lookup between multiple collections.<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Indexing Strategies:</strong><br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MongoDB permits secondary indexes to be declared on any field, including field within arrays. Indexes can be created and dropped at any time to easily support changing application requirements and query patterns. Index types include compound indexes, text indexes, geospatial indexes, and more.</p>\n\n<p style=\"margin-left: 40px;\">&nbsp;</p>\n\n<ul>\n\t<li style=\"margin-left: 40px;\"><strong>Primary Index:</strong> Every Collection has a primary key index</li>\n\t<li style=\"margin-left: 40px;\"><strong>TTL Indexes:</strong> Single Field indexes, when expired delete the document</li>\n\t<li style=\"margin-left: 40px;\"><strong>Compound Index:</strong> Index against multiple keys in the document</li>\n\t<li style=\"margin-left: 40px;\"><strong>Unique Indexes:</strong> Ensures value is not duplicated</li>\n\t<li style=\"margin-left: 40px;\"><strong>MultiKey Index:</strong> Index into arrays Partial Indexes: Expression based indexes, allowing indexes on subsets of data</li>\n\t<li style=\"margin-left: 40px;\"><strong>Text Indexes:</strong> Support for text searches Case Insensitive Indexes: supports text search using case insensitive search</li>\n\t<li style=\"margin-left: 40px;\"><strong>GeoSpatial Indexes:</strong> 2d &amp; 2dSphere indexes for spatial geometries</li>\n\t<li style=\"margin-left: 40px;\"><strong>Sparse Indexes:</strong> Only index documents which have the given field</li>\n\t<li style=\"margin-left: 40px;\"><strong>Hashed Indexes:</strong> Hashed based values for sharding</li>\n</ul>\n\n<p><strong>Availability</strong></p>\n\n<p>MongoDB maintains multiple copies of data using replica sets (Figure 3). Unlike relational databases, replica sets are self-healing as failover and recovery is fully automated, so it is not necessary to manually intervene to restore a system in the event of a failure, or to add additional clustering frameworks and agents. A replica set consists of multiple database replicas. To maintain strong data consistency, one member assumes the role of the primary replica against which all write operations are applied.</p>\n\n<p>The other members of the replica set act as secondaries, replicating all data changes from the oplog (operations log).<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\nThe oplog contains an ordered set of idempotent operations that are replayed on the secondaries</p>\n\n<p>If the primary replica set member suffers a failure (e.g., a power outage, hardware fault, network partition), one of the secondary members is automatically elected to primary, typically within several seconds, and the client connections automatically failover to that new primary. Any writes that could not be serviced during the election can be automatically retried by the drivers once a new primary is established, with the MongoDB server enforcing exactly-once processing semantics. Retryable writes enable MongoDB to ensure write availability, without sacrificing data consistency.</p>\n\n<p>The replica set election process is controlled by sophisticated algorithms based on an extended implementation of the Raft consensus protocol.&nbsp;</p>\n\n<p>Up to 50 members can be configured per replica set, providing operational flexibility and wide data distribution across multiple geographic sites, co-locating data in close proximity to remote users.</p>\n\n<p>MongoDB&rsquo;s write concern can be configured in such a way that writes are only acknowledged once specific policies have been fulfilled, such as writing to at least two replica set members in one region and at least one replica in a second region.&nbsp; This reduces the risk of data loss in the event of a complete data center outage.</p>\n\n<p>The nearest read preference allows the client to read from the lowest-latency members of a replica set. This is typically used to route queries to a local data center, thus reducing the effects of geographic latency, while being able to immediately fallback to the next nearest replica if the closest node goes down. Tags can also be used to ensure that reads are always routed to a specific node or subset of nodes.</p>\n\n<p>Within a replica set, one set of nodes can be provisioned to serve operational applications, replicating data in real time to other nodes dedicated to serving analytic workloads.</p>\n\n<p>Replica set tags allow read operations to be directed to specific nodes within the cluster, providing physical isolation between analytics and operational queries. Different indexes can even be created for the analytics nodes, allowing developers to optimize for multiple query patterns.</p>\n\n<p><strong>Scalability</strong></p>\n\n<p>To meet the needs of apps with large data sets and high throughput requirements, MongoDB provides horizontal scale-out for databases on low-cost, commodity hardware or cloud infrastructure using a technique called sharding.</p>\n\n<p>Sharding automatically partitions and distributes data across multiple physical instances called shards. Each shard is backed by a replica set to provide always-on availability and workload isolation.&nbsp;</p>\n\n<p>To respond to workload demand, nodes can be added or removed from the cluster in real time, and MongoDB will automatically rebalance the data accordingly, without manual intervention</p>\n\n<p>Applications issue queries to a query router that dispatches the query to the appropriate shards. For key-value queries that are based on the shard key, the query router will dispatch the query to the shard<br />\nthat manages the document with the requested key.</p>\n\n<p>When using range-based sharding, queries that specify ranges on the shard key are only dispatched to shards that contain documents with values within the range. For queries that don&rsquo;t use the shard key, the query router will broadcast the query to all shards, aggregating and sorting the results as appropriate. Multiple query routers can be used within a MongoDB cluster, with the appropriate number governed by the performance and availability requirements of the application</p>\n\n<p>By simply hashing a primary key value, many distributed databases randomly spray data across a cluster of nodes, imposing performance penalties when data is queried, or adding application complexity when data needs to be localized to specific nodes. By exposing multiple sharding policies to developers, MongoDB offers a better approach.</p>\n\n<p>Ranged Sharding. Documents are partitioned across shards according to the shard key value. Documents with shard key values close to one another are likely to be co-located on the same shard. This approach is well suited for applications that need to optimize range based queries, such as co-locating data for all customers in a specific region on a specific shard.</p>\n\n<p>Hashed Sharding. Documents are distributed according to an MD5 hash of the shard key value. This approach guarantees a uniform distribution of writes across shards, which is often optimal for ingesting<br />\nstreams of time-series and event data.</p>\n\n<p>Zoned Sharding. Provides the ability for developers to define specific rules governing data placement in a sharded cluster. Zones are discussed in more detail in the following Data Locality section of the guide.</p>\n\n<p><a class=\"vglnk\" href=\"https://dzone.com/articles/mongodb-replication-lag-and\" rel=\"nofollow\" target=\"_blank\">Replication Lag In Mongo</a></p>\n\n<p><a class=\"vglnk\" href=\"http://highscalability.com/blog/2010/10/15/troubles-with-sharding-what-can-we-learn-from-the-foursquare.html\" rel=\"nofollow\" target=\"_blank\">Troubles With Sharding</a></p>\n</div>\n\n<h2>Working With MongoDB</h2>\n\n<p>Installation:</p>\n\n<p>On Linux:&nbsp;</p>\n\n<pre>\n<code class=\"language-bash\">echo \"deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list\n\nsudo apt-get install -y mongodb-org\nsudo service mongod start\n\nvim /var/log/mongodb/mongod.log</code></pre>\n\n<p>Use Mongo through Terminal</p>\n\n<pre>\n<code class=\"language-bash\">mongo\nshow dbs;\nuse &lt;db-name&gt;;\nshow tables;\n\ndb.&lt;table-name&gt;.find().map(&lt;lambdaFunction&gt;)</code></pre>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://github.com/mongodb/specifications\" target=\"_blank\">See the mongodb specifications</a></p>\n\n<p>Here&#39;s the TLA+ Specification of the MongoDB ReplicaSet engine which helped discover many bugs (liveness and safety related): <a href=\"https://github.com/will62794/mongo-repl-tla-models\" target=\"_blank\">MongoDB Replication TLA+</a></p>\n","authorId":null,"subject":"architectures","tags":null,"img":null,"summary":"MongoDB is a document oriented DB for flexible data storage. Now that it supports ACID transactions, it can easily replace MySQL or other DBs in most of the scenarios.","lastUpdated":"2020-05-09T16:35:26.708+0000"}