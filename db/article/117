{"name": "Philosophies for Problem Solving", "id": 117, "content": "<p>Here are the few philosophies that have been proven helpful in coming up with solutions.</p>\n\n<p>First step in problem-solving is: <strong>Hope &amp; Determination</strong>. You can find in the history books, how every problem that has been solved was once thought to be unsolvable. You can see that nobody tried to solve it because they thought they can&#39;t solve it&nbsp;until someone comes with a strong determination and solves it.</p>\n\n<p><em>Well, that was quite motivating, wasn&#39;t it?&nbsp;</em></p>\n\n<p>But like most of the things this is both true and false at the same time. Not all problems have been solved because someone decided to solve it and then came up with a way to solve it. Many a times it happens that you are just trying a few things and solutions come up. If you look into the history of science, most of the novel ideas just appeared.&nbsp;</p>\n\n<p>But nonetheless you have to be prepared to find a solution. A solution doesn&#39;t occur to someone who has not even thought about the problem <em>(in some rare cases, it might come, but would be useless unless someone familiar with the problem picks it up)</em>.</p>\n\n<p>Second philosophy in problem-solving is: <strong>Know the problem</strong>. I already mentioned that novel solutions come more from the exploration (rather accidental discoveries) instead of techniques. But you have to be ready,&nbsp; prepared, you must have knowledge about the nature of the problem to find a solution. The more you study the problem, the closer you will approach towards a solution (<em>if there&#39;s any</em>).</p>\n\n<hr />\n<h2>Elimination Method</h2>\n\n<p>Like in life&nbsp;you should follow the path which gives you hope and light, and abandon the path of darkness; similarly while solving a problem if you have many options to choose from (paths to walk upon), choose one (or many)&nbsp;which give you hope to get to solution &amp; eliminate the other options/paths.</p>\n\n<p><span style=\"font-size:16px;\"><strong>But how do you know that which path is helpful and which is not?</strong></span></p>\n\n<p>This depends on the problem being asked, and the characteristics of paths, and your prior experience.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<h2>Backtracking</h2>\n\n<p>One idea of solving problems is &mdash;&nbsp;just try some path that will hopefully lead to solution.&nbsp;If you finally discover that this path was not correct, go back to starting point of the path, and choose another path.</p>\n\n<p>The process can be generalized as: Choose one path, move along with it trying to find the solution. If you find at last that this was the wrong path, start over with another path.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<h2>From pieces to the&nbsp;whole</h2>\n\n<p>This is&nbsp; a classic technique of problem solving&nbsp; &mdash;&nbsp; <a href=\"https://en.wikipedia.org/wiki/Reductionism\">Reductionism</a>. The idea is to reduce the problem into parts, then solve the parts and then combine those&nbsp;solutions to get the solution for the whole problem.</p>\n\n<p>In computer programming, this is seen as <em><strong>Divide and Conquer</strong></em>. The main thing is that there must a step, a possibility of coming up with the &quot;merge&quot; step, that would help in solving the overall problem from the pieces.</p>\n\n<p>&nbsp;</p>\n\n<h2>From Simpler to The Complex</h2>\n\n<p>Before solving the problem of large size, see how it evolved from smaller size. Ask yourself, &quot;had the problem been smaller in size,&nbsp;how would I solve it&quot;, and &quot;if I&nbsp;could remember the&nbsp;solutions for the smaller sizes of the problem,&nbsp;does it help in solving the bigger problem?&quot;</p>\n\n<p>In computer programming, this is called <em><strong>Dynamic Programming</strong></em>.</p>\n\n<p>Another way to say this is &mdash;break down the problems, write them down, start from the smallest version, build the solution up.</p>\n\n<p>&nbsp;</p>\n\n<h2>Occam&#39;s Razor</h2>\n\n<p>a.k.a. Ockham&#39;s razor or Ocham&#39;s razor or law of parsimony.</p>\n\n<p>Entities should not be multiplied without necessity. (It is misquoted as &quot;The simplest solution is most likely the right one&quot;)<br />\nIf you have many hypotheses which make the same predictions, one should choose select the solution with the fewest assumptions.</p>\n\n<p>In science, Occam&#39;s razor is used as an abductive heuristic in the development of theoretical models rather than as a rigorous arbiter between candidate models.<br />\nAbductive reasoning (also called <a href=\"\" reactlink=\"/article/230\">abduction, abductive inference, or retroduction</a>) is a form of logical inference which starts with an observation or set of observations then seeks to find the simplest and most likely explanation for the observations. This process, unlike deductive reasoning, yields a plausible conclusion but does not positively verify it. Abductive conclusions are thus qualified as having a remnant of uncertainty or doubt, which is expressed in retreat terms such as &quot;best available&quot; or &quot;most likely.&quot; One can understand abductive reasoning as inference to the best explanation, although not all usages of the terms abduction and inference to the best explanation are exactly equivalent</p>\n\n<p>&nbsp;</p>\n\n<h2>The Least Effort Principle</h2>\n\n<p>Rather than giving a good way for solving a problem, this principle simply explains the common way which people choose to solve problems. They choose a path which takes least amount of effort, offers least resistance.</p>\n\n<p>For example, one might consult a generalist co-worker down the hall rather than a specialist in another building, so long as the generalist&#39;s answers were within the threshold of acceptability.</p>\n\n<p>&nbsp;</p>\n\n<h2 class=\"firstHeading\" id=\"firstHeading\" lang=\"en\">Fundamental theorem of software engineering</h2>\n\n<p>We can solve any problem by introducing an extra level of <a href=\"https://en.wikipedia.org/wiki/Indirection\" target=\"_blank\" title=\"Indirection\">indirection</a>.</p>\n\n<p>This principle is generally fit for solving system designs rather than Algorithm design.</p>\n\n<p>This can also be seen in Beurocratic systems (government, management), in Economics (e.g. Franchise model).</p>\n\n<p>&nbsp;</p>\n\n<h2>Simplest Non-trivial Example</h2>\n\n<p>While doing research, or solving a problem, after listing down trivial examples, find and work on the <strong><em>&quot;simplest non-trivial example&quot;</em></strong>.</p>\n\n<p>Symmetry Finding: Take advantage of symmetries, similarities of parts,&nbsp;if any, in the problem.</p>\n\n<p>&nbsp;</p>\n\n<h2>Abstract Representation</h2>\n\n<p>It helps a lot to represent the problem in a way that you are already familiar with, and the way which already has been studied, which is easier to see and analyze. You can use geometry, algebra, pictures, graphs to represent it.</p>\n\n<p>Try to generalize the problem without losing the information of the particular aspects of the problem.</p>\n\n<p>Just by simple representation, you will get an abstract form of the problem. Then go on refining the details of it, find the patterns, apply existing knowledge to it to reach a solution.</p>\n\n<p>&nbsp;</p>\n\n<h2>Verification&nbsp;of the Solution</h2>\n\n<p>Often times, we think that we have found the solution but do not&nbsp; try it out various possibilities. This&nbsp; results in a situation where we&nbsp; have illusion of the solution, but do not have a real solution. In computer&nbsp; programs it&#39;s called <em>bug</em>.</p>\n\n<p>So, it&#39;s wise to try the solution on different forms of&nbsp; the problem. By different forms I mean that different ccombination of values for the variables involved&nbsp; in the problem.</p>\n\n<p>It is not just&nbsp; enough to find the solution, you must know how the solution works, and why the solution works. You should be able to prove it&nbsp; somehow. In computer programs this is called Correctness proof/checking.</p>\n\n<p>&nbsp;</p>\n\n<h2>Tradeoff Consideration</h2>\n\n<p>While solving any problem there are tradeoffs. There is nothing perfect. And no problem can be solved in a <em>perfect</em> way because of the constraints. You have take constraints into account while developing the solution.</p>\n\n<p>In computer programming while developing algorithms, a&nbsp;common tradeoff is between <em>Memory</em> and <em>Computational complexity (runtime)</em>.&nbsp;</p>\n\n<p>In computer architecture problems, you&nbsp;have tradeoff between flexibility and complexity.</p>\n\n<p>You might not even have that much time to implement a very good solution, so you can consider a lean solution instead.</p>\n\n<p>&nbsp;</p>\n\n<h2>Multi-Dimensional Approach</h2>\n\n<p>Same soluiton can be approached in multiple ways. Moreover, considering multiple ways may lead to multiple solutions, then you can choose the &quot;best&quot; one among them. And this can lead to some novel solutions as well.</p>\n\n<p><strong>Write down</strong> different ways from which the problem can be seen. Then pick them one by one and proceed.&nbsp;</p>\n\n<p>It&#39;s better to write down assumptions as well, and test for aassumptions before making significant progress on a particular path. Also, factor in unknowns.</p>\n\n<p>&nbsp;</p>\n\n<h2>Systemic Problem Solving</h2>\n\n<p>Actually there&#39;s no systemic way of problem solving, because most of the crucial steps that advance the problem solving (in any domain - science, philosophy, society etc) come somewhat accidently &mdash;from intuition, imagination, or just purely accidental discovery etc &mdash; still we might want to have some sort of framework, which would help in at least transferring the knowledge (from past) of problem solving from one domain to another, or from one problem to another.</p>\n\n<p>&nbsp;</p>\n</div>\n</div>\n", "authorId": 1, "subject": "algos", "tags": [""], "img": "", "summary": "", "lastUpdated": "2021-02-20 07:20:54.732234"}