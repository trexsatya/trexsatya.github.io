{"name": "Philosophy of Problem Solving", "id": 117, "content": "<p>Here are the few philosophies that have been proven helpful in coming up with solutions.</p>\n\n<p>First step in problem-solving is: <strong>Hope &amp; Determination</strong>. You can find in the history books, how every problem that has been solved was once thought to be unsolvable. You can see that nobody tried to solve it because they thought they can&#39;t solve it&nbsp;until someone comes with a strong determination and solves it.</p>\n\n<p><em>Well, that was quite motivating, wasn&#39;t it?&nbsp;</em></p>\n\n<p>But like most of the important things, this is both true and false at the same time. Not all problems have been solved because someone decided to solve it and then came up with a way to solve it. Many a times it happens that you are just trying a few things and solutions come up. Looking into the history of science, it seems that the&nbsp;most of the novel ideas just <em>appeared</em> somehow.&nbsp;</p>\n\n<p>But nonetheless, you have to be prepared to find a solution. A solution doesn&#39;t occur to someone who has not even thought about the problem <em>(in some rare cases, it might come, but would be useless unless, someone familiar with the problem picks it up)</em>.</p>\n\n<p>Second philosophy in problem-solving is: <strong>Know the problem</strong>. I already mentioned that novel solutions come from the exploration<i> </i>instead of techniques. But you have to be ready,&nbsp;prepared, you must have knowledge about the nature of the problem to find a solution. The more you study the problem, the closer you will move towards a solution (<em>if there&#39;s any</em>).</p>\n\n<p>It&#39;s also very important to understand the relationship of the problem - relationship with the entities, the context(s), with other problems etc.</p>\n\n<hr />\n<p>When working in a team, having unfruitful discussions is not uncommon. And, at the same time, discussions are unavoidable because they are necessary to move forward, to bring in new ideas and so on. So, teams have to learn the art/science of&nbsp;structured discussion for problem-solving, brainstorming and so on. In fact, the success of a project, and a team is directly propertional to how fruitful their discussions are.</p>\n\n<h2><big>Structured Discussion ft Collaboration (as opposed to competition):</big></h2>\n\n<p>Starting point: Best starting point - A Question which needs to be answered.&nbsp; Other options include:</p>\n\n<ol>\n\t<li>A theory</li>\n\t<li>An observation</li>\n\t<li>A claim etc</li>\n\t<li>A problem</li>\n</ol>\n\n<p>Acknowledgement (from everyone)</p>\n\n<ul>\n\t<li>that the question is understood clearly by everyone (this might require a pre-discussion to setup the context)</li>\n\t<li>that the question needs to be answered</li>\n\t<li>that the theory needs to be evaluated</li>\n\t<li>that the problem needs to be solved (this might cause a diversion in the discussion, but it&#39;s required to settle)</li>\n</ul>\n\n<p>&nbsp;&nbsp; &nbsp;...</p>\n\n<p>Analysis of the parts involved</p>\n\n<ul>\n\t<li>parts of the question</li>\n\t<li>assumptions of the theory</li>\n\t<li>evidence of the claim/observation/problem <em>(Evidence helps not only in verification, but can also lead to other theories, and give some hint for problem-solving)</em></li>\n</ul>\n\n<p>&nbsp;<br />\nSubmission of the:</p>\n\n<ul>\n\t<li>alternate theories</li>\n\t<li>counter-theories, counter-points</li>\n\t<li>arguments, evidence, etc</li>\n</ul>\n\n<p>&nbsp;&nbsp; &nbsp;....<br />\n&nbsp;&nbsp; &nbsp;(This will form a loop)</p>\n\n<p>If it is a problem we are discussing:<br />\n&nbsp;&nbsp; &nbsp;The result should be one or more solution candidates<br />\n&nbsp;&nbsp; &nbsp;..<br />\n&nbsp;&nbsp; &nbsp;Evaluation of solution candidates</p>\n\n<p>&nbsp;&nbsp; &nbsp;If there are multiple solution candidates:</p>\n\n<ol>\n\t<li>Prioritise</li>\n\t<li>Select one or more to be considered further</li>\n\t<li>Acknowledgement from everyone on the agreed solution items</li>\n</ol>\n\n<p>If it is a theory/observation/claim we are discussing:</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp; The output should be the validity of the claim/theory/observation as per the collective understanding. Consequently, it would either be accounted for or rejected.</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp; A well-formed problem statement can also be an output for the further discussion.</p>\n\n<p>There&#39;s no my solution or your solution or winning theory/solution or losing theory/solution, there&#39;s just a solution which we have chosen to work with as per our collective understanding and collective agreement.</p>\n\n<p>&nbsp;</p>\n\n<hr class=\"dots\" />\n<h2>&nbsp;</h2>\n\n<h2>Elimination Method</h2>\n\n<p>It is said that in life you <em>should</em> follow the path which gives you hope and light, and abandon the path of darkness; similarly while solving a problem if you have many options to choose from (paths to walk upon), choose one (or many)&nbsp;which give you hope to get to solution &amp; eliminate the other options/paths.</p>\n\n<p><span style=\"font-size:16px;\"><strong>But how do you know which path is helpful and which is not?</strong></span></p>\n\n<p>This depends on the problem being asked, and the characteristics of paths, and your prior experience. <em>[Although, this is a very generic statement, not much helpful!]</em></p>\n\n<p>So, we can say that you can apply different modes of thinking to do the elimination. The different modes of thinking are &mdash; Logical System (mathematics, deductions etc), Thought Experiments, Intuition/Imagination etc. Just remember that only Logical system of thiking guarantees that the conclusion will hold true (<strong>if the assumptions are <em>true</em></strong>). Other modes of thinking <em>are</em>&nbsp;helpful, but, generally,&nbsp;you cannot exercise them at your will.</p>\n\n<p>Science progresses by this method. Theories are eliminated (or modified) based on the observations. [Karl Popper]</p>\n\n<p>&nbsp;</p>\n\n<div>\n<h2>From Pieces to The Whole</h2>\n\n<p>A classic technique of problem solving&nbsp; &mdash;&nbsp; <a href=\"https://en.wikipedia.org/wiki/Reductionism\">Reductionism</a>. The idea is to reduce the problem into parts, then solve the parts and then combine those&nbsp;solutions to get the solution for the whole problem.</p>\n\n<p>In computer programming, this is can be seen in&nbsp;<em><strong>Divide and Conquer&nbsp;</strong></em>methodology. The main thing is that there must be a step, a possibility of coming up with the &quot;merge&quot; step, that would help in solving the overall problem from the solutions of pieces, otherwise you are just left with pieces of the solution, and the original problem.</p>\n\n<p>&nbsp;</p>\n\n<h2>From Simpler to The Complex</h2>\n\n<p>Before solving the problem of large size, you can see how it evolved from the smaller size. Ask yourself, &quot;had the problem been smaller in size,&nbsp;how would I solve it&quot;, and &quot;if I&nbsp;could remember the&nbsp;solutions for the smaller sizes of the problem,&nbsp;does it help in solving the bigger problem?&quot;</p>\n\n<p>In computer programming, this manifests in&nbsp;<em><strong>Dynamic Programming</strong></em>. Again, this works if there&#39;s a method to jump from solution of smaller to bigger form of the problem. This can be figured by applying Logic (especially mathematical logic).</p>\n\n<p>Another way to say this is &mdash;break down the problem (preserving the <em>nature</em> of the problem), write them down, start from the smallest version, build the solution up (Bottom Up solutions).&nbsp;</p>\n\n<p><em>[It is interesting to see that our world has favored, continues to favor&nbsp;Top Down solutions, in social problem solving, of course due to constraints, which is manifested in all sort of <strong>authority-</strong>based systems]</em></p>\n\n<div>&nbsp;</div>\n\n<h2>Occam&#39;s Razor</h2>\n\n<p>a.k.a. Ockham&#39;s razor or Ocham&#39;s razor or law of parsimony.</p>\n\n<p>Entities (involved in the problem/solution space) should not be multiplied without necessity. (It is misquoted as &quot;The simplest solution is most likely the right one&quot;).&nbsp;<br />\nIf you have many hypotheses which make the same <strong>predictions</strong>, one should choose the solution with the fewest <strong>assumptions</strong>.</p>\n\n<p>You should not add one more assumption, one more entity unless there&#39;s no other way to progress with the solution.&nbsp;</p>\n\n<p>But, you have to be cautious as well - &quot;Everything has to be made as simple as possible, but not simpler&quot;</p>\n\n<blockquote>\n<p>In science, Occam&#39;s razor is used as an abductive heuristic in the development of theoretical models rather than as a rigorous arbiter between candidate models.<br />\nAbductive reasoning (also called <a href=\"/#/article/230\">abduction, abductive inference, or retroduction</a>) is a form of logical inference which starts with an observation or set of observations then seeks to find the simplest and most likely explanation for the observations. This process, unlike deductive reasoning, yields a plausible conclusion but does not positively verify it. Abductive conclusions are thus qualified as having a remnant of uncertainty or doubt, which is expressed in retreat terms such as &quot;best available&quot; or &quot;most likely.&quot; One can understand abductive reasoning as inference to the best explanation, although not all usages of the terms abduction and inference to the best explanation are exactly equivalent</p>\n</blockquote>\n\n<p>&nbsp;</p>\n\n<hr class=\"dots\" />\n<h2>&nbsp;</h2>\n\n<h2>Backtracking</h2>\n\n<p>One idea of solving problems is &mdash;&nbsp;just try some path that will <strong><em>hopefully</em></strong> lead to the solution.&nbsp;If you finally discover that this path was not correct, go back to starting point of the path, and choose another path.</p>\n\n<p>The process can be generalized as: Choose one path, move along with it trying to find the solution. If you find at last that this was the wrong path, start over with another path. <em>[You must keep track of the starting point]</em></p>\n\n<p>This is a rather simplistic method, and should be followed only if somehow you are not able to follow any other way of problem solving.</p>\n\n<p>&nbsp;</p>\n\n<h2>The Least Effort Principle</h2>\n\n<p>Rather than giving a good way for solving a problem, this principle simply states&nbsp;the common way which people choose to solve problems. They choose a path which takes least amount of effort, offers least resistance.</p>\n\n<p>For example, one might consult a generalist co-worker down the hall rather than a specialist in another building, so long as the generalist&#39;s answers were within the threshold of acceptability. <em>(Although this example can have other factors as well e.g. that person could consult&nbsp;the generalist co-worker because of the social aspect)</em></p>\n\n<p>In computer engineering domain, this is manifested when programmers choose to apply patches, write imperative lines of code without thinking much about the structure, design etc.</p>\n\n<p>In general, this is manifested when people choose to take the problem (as it appears at the moment), and try to solve it rather than diving deep into the root of the problem. <em>[Though, problem analysis is slippery slope, how long would you analyse, how many factors would you consider etc]. </em><strong>Instant Gratification </strong>can also be seen as a manifestation of this principle, if it is seen in terms of problem and solutions.</p>\n\n<p><strong>Confirmation Bias</strong>, can also be seen in the same light. People fall prey to confirmation bias because their mental system chooses the least effort path.</p>\n\n<p>General Law of Computation &mdash; that natural, autopoetic systems seem to take the path (toward <em>&quot;solution&quot;</em>) which involves <strong>the least computation</strong> <em>(we can say least expenditure of resources, to generalise)</em>&mdash;also manifests the above principle. <em>[This has been noted in theory&nbsp;of Evolution, theory&nbsp;of Innate Language system in humans, ....]</em></p>\n\n<p>&nbsp;</p>\n\n<h2>Simplest Non-trivial Example</h2>\n\n<p>While doing research, or solving a problem, after listing down trivial examples, find and work on the <strong><em>&quot;simplest non-trivial example&quot;</em></strong>.</p>\n\n<p>Symmetry Finding: Take advantage of <em>symmetries</em>, similarities of parts,&nbsp;if any, in the problem.</p>\n\n<p>&nbsp;</p>\n\n<h2 class=\"firstHeading\" id=\"firstHeading\" lang=\"en\">Fundamental Theorem of Software Engineering</h2>\n\n<p>We can solve any problem by introducing an extra level of <a href=\"https://en.wikipedia.org/wiki/Indirection\" target=\"_blank\" title=\"Indirection\">indirection</a>.</p>\n\n<p>This principle is generally fit for solving system designs rather than Algorithm design.</p>\n\n<p>This can also be seen in Beurocratic systems (government, management), in Economics (e.g. Franchise model).</p>\n\n<p><em>[This, in no way,&nbsp;means that you will have an optimal solution/system]</em></p>\n\n<p>&nbsp;</p>\n\n<h2>Abstract Representation</h2>\n\n<p>It helps a lot to represent the problem in a way that you are already familiar with, and the way which already has been studied, which is easier to see and analyze. You can use geometry, algebra, pictures, graphs to represent it.</p>\n\n<p>Try to generalize the problem without losing much of the information about the particular aspects of the problem.</p>\n\n<p>Just by simple representation, you will get an abstract form of the problem. Then go on refining the details of it, find the patterns, apply existing knowledge to it to reach a solution. Note that the best (<em>most precise</em>) form of abstract representation known to man is mathematics.</p>\n\n<p>In computer engineering, often diagrams are used. Although in computer <em>science</em>, people use a combined approach (diagrams, mathematics etc) to come up with solutions.</p>\n\n<p>&nbsp;</p>\n\n<h2>Verification&nbsp;of the Solution</h2>\n\n<p>Often times, we think that we have found the solution but do not&nbsp;try out various possibilities, different use-cases etc. This&nbsp;results in a situation where we&nbsp; have illusion of the solution, but do not have a real solution. In computer&nbsp;programs it&#39;s called <em>bug</em>. <em>[In societies, it results in crisis.]</em></p>\n\n<p>So, it&#39;s only wise to try the solution on different forms of&nbsp;the problem. By different forms I mean that different ccombination of values for the variables, entities involved&nbsp; in the problem.</p>\n\n<p>It is not just&nbsp;enough to find a solution, you must know how the solution works, and why the solution works. You should be able to <em>prove</em> it&nbsp;somehow. In computer science this is called Correctness proof/checking.</p>\n\n<p>&nbsp;</p>\n\n<h2>Tradeoff Consideration</h2>\n\n<p>While solving any problem, there are tradeoffs to consider. There is nothing <em>perfect</em>. And no problem can be solved in a <em>perfect</em> way because of the constraints. You have to take the constraints into account while developing the solution.</p>\n\n<p>In computer programming while developing algorithms, a&nbsp;common tradeoff is between <em>Memory</em> and <em>Computational complexity (runtime)</em>.&nbsp;</p>\n\n<p>In computer architecture problems, you&nbsp;have tradeoff between flexibility and complexity.</p>\n\n<p>You might not even have that much time to implement a very good solution, so you can consider a lean solution instead.</p>\n\n<p>In general life, the tradeoff could be as simple &mdash; and difficult at the same time&mdash;&nbsp;as <em>deciding whether to act or not, </em>whether to apply a solution (whatever minimal, fuzzy, insufficient solution we have at hand) or not, whether to at least try or not.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>Multi-Dimensional Approach</h2>\n\n<p>Same problem/solution can be approached in multiple ways. Moreover, considering multiple ways may lead to multiple solutions, then you can choose the &quot;best&quot; one among them. And this can lead to some novel solutions as well.</p>\n\n<p><strong>Write down</strong> different ways from which the problem can be seen. Then pick them one by one and proceed.&nbsp;</p>\n\n<p>It&#39;s better to <strong>write down (specify)</strong> assumptions as well, and test for assumptions before making significant progress on a particular path. Also, factor in <strong><em>unknowns</em></strong>.</p>\n\n<p><em>[It should be noted that different perspective comes from <strong>different mental configurations</strong>, which in practical world would mean different types of people, with different interests in the problem]</em></p>\n\n<p>&nbsp;</p>\n\n<h2>Systematic Problem Solving</h2>\n\n<p>Actually there&#39;s no systematic way of problem solving, because most of the crucial steps that advance the problem solving (in any domain &mdash;&nbsp;science, philosophy, society etc) come somewhat accidently &mdash;from intuition, imagination, or just purely accidental discovery etc &mdash; still we might want to have some sort of framework, which would help in at least transferring the knowledge (from past) of problem solving to present,&nbsp;from one domain to another, or from one problem to another.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/Problem_Solving_Approach.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n</div>\n\n<p>&nbsp;After doing the problem solving, you would want to have a system in place. Note that there is no hard boundary between problem solving and system designing steps. They may be&nbsp;co-dependent.</p>\n\n<p>Also, note that <em><strong>there is no perfect system</strong></em>.</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Problem_Solution.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>Note that there&#39;s no solid boundary of the problem space and the solution space. This manifests in most of the complex problems in the real world. The fuzzy boundary may&nbsp;<strong><em>evolve</em></strong>&nbsp;into&nbsp;solid boundary with time. <em>[It may&nbsp;not be because we were able to correctly define the original problem, it could be just because we narrowed down the problem, and just accepted it to our satisfaction]</em> We can even say that the evolution of man-made systems is much like the evolution in natural world, and much like the evolution of sciences.</p>\n\n<p>One of the main observations in evolutions is Punctuated Equilibrium &mdash; for a long time the current situation (solution space, and&nbsp;artefacts seem enough), but then a crisis occurs (<em>often noted by <strong>other</strong> people, someone who sees a new problem, or discovers conflicts, inconsistencies, paradoxes, insufficiencies etc</em>), and then a <strong>paradigm shift</strong> happens (often by different people coming together), ... <em><strong>this cyle continues</strong></em>. In simple problem domains this thing is manifested simply as unforeseen requirements coming up.</p>\n\n<p>While designing any sort of system, you would also like to keep the people involved in the system (users, actors etc) in mind.</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Users_Context.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>Real World is the supreme container system (<em>a system within which your system would operate</em>), and it can manifest any event (known, unknown), it can cause anything to break, it can show unimaginable events (positive, negative). This has been seen many times that people didn&#39;t consider real-world events resulting in huge losses. For example, a natural catastrophe can occur in the place central to the system, this has to be considered.</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Entities_Etc.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p><strong>In abstract world, every name is an entity.</strong></p>\n\n<p>Domain-language evolves, and cannot be defined solidly, with more experience with the system and associated processes, more domain terms may emerge. Different people, with different interests and different perspectives, may contribute to the domain vocabulary. But, it basically means the entities that are core to the problem domain.&nbsp;</p>\n\n<p>A-priori language is basically every entity that comes from non-logical modes of thinking.&nbsp;</p>\n\n<p>Expertise-Language may come from the people who have experience with the problem-elements, or parts of the system (that you get after reduction), or with similar problems/systems, or with interfacing problems/systems.</p>\n\n<p>&nbsp;</p>\n\n<p>Primary Generator in Design Process:</p>\n\n<p><span style=\"color:#2c3e50;\"><strong>An early archetype, exemplar form of the designed artefact/output may dictate the whole design process, for better or worse. So, it&#39;s better to somehow bring in fresh perspectives, in the early phase itself.</strong></span></p>\n\n<p>&nbsp;</p>\n\n<hr />\n<p>&nbsp;</p>\n\n<p>In organisations, problem-solving is more like &quot;conversation with the situation&quot;. Organisational knowledge is shared through participation in interactive work-practices &amp; organisational forms, rather than being understood through articulation.</p>\n\n<p>Individual Solution Space&nbsp;&nbsp;\u25ba Consensus Problem Space&nbsp;&nbsp;\u25ba Breakdown&nbsp; \u25ba&nbsp; Reframing&nbsp;&nbsp;\u25ba&nbsp;.... repeat</p>\n\n<p>Sharing &amp; Integrating diverse domain knowledge is a critical design activity.</p>\n\n<p>&nbsp;</p>\n\n<hr />\n<p>An Even More Generic Way of Problem-Solving</p>\n\n<p><img alt=\"P\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/Problem_Solving.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong><em>Deducing from What We Have:</em></strong><br />\n&nbsp; &nbsp; Fill In The Blanks: E.g. the problem doesn&#39;t talk about something, but it&#39;s implcitily (associated) there.</p>\n\n<p><em><strong>Examples:</strong></em><br />\n&nbsp;&nbsp; &nbsp;Unique: Examples that cover different possibilities.<br />\n&nbsp;&nbsp; &nbsp;Extreme examples.<br />\n&nbsp; &nbsp; Symmetric examples.<br />\n&nbsp; &nbsp; Simplest Non-Trivial Examples.</p>\n\n<p><em><strong>(Re)Building The Situation:</strong></em><br />\n&nbsp;&nbsp; &nbsp;How did this problem evolve;<br />\n&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;Instead of starting from ground up, you could also (re)build by referring to what is the most recent state that may have led to the current situation.</p>\n\n<p><br />\n<em><strong>Reduce:</strong></em><br />\n&nbsp;&nbsp; &nbsp;This and previous one are highly linked. You can reduce on the different aspects of the problem. You divide the problem, entities into categories etc.<br />\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n\n<p><em><strong>Resemblance:</strong></em><br />\n&nbsp;&nbsp; &nbsp;It&#39;s very hard to find resemblance by logical methods. That would take huge amount of time, and it is very confusing.<br />\n&nbsp;&nbsp; &nbsp;Try Abstract Reasoning Tests, you&#39;ll know what I mean.</p>\n\n<p>&nbsp;&nbsp; &nbsp;But, with experience, an intuition automatically develops and then you can work backword to connect the dots once you have an intuition that this problem/situation<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;resemblance something from your experience/knowledge.</p>\n\n<p>&nbsp;</p>\n\n<h2>Learning from mistakes:</h2>\n\n<p>Template:</p>\n\n<p>Summary of the bug/mistake: what happened?<br />\n&nbsp; ....</p>\n\n<p>What is the impact (Add explanation for each, if possible):<br />\n&nbsp; Can it impact those who rely on the system?&nbsp;<br />\n&nbsp; Can it impact system (performance, resources)?&nbsp;</p>\n\n<p>Attach a picture indicating where the bug started impacting in system diagram.</p>\n\n<p>What could have we done better?<br />\n&nbsp; Were the tests/checks missing?<br />\n&nbsp; If not, Were the tests weak? (For example, not enough assertion, not readable enough to be reviewed)<br />\n&nbsp; Could the review have been better? How?<br />\n&nbsp; Was there a flaw in the design?</p>\n\n<p>What actions are taken for this to prevent this further?<br />\nWhat actions are taken to minimise the impact/damage done?</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "philosophy", "tags": [""], "img": "", "summary": "", "lastUpdated": "2023-12-27 11:47:12.477335"}