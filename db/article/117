{"name": "Philosophy of Problem Solving", "id": 117, "content": "<p>Here are the few philosophies that have been proven helpful in coming up with solutions.</p>\n\n<p>First step in problem-solving is: <strong>Hope &amp; Determination</strong>. You can find in the history books, how every problem that has been solved was once thought to be unsolvable. You can see that nobody tried to solve it because they thought they can&#39;t solve it&nbsp;until someone comes with a strong determination and solves it.</p>\n\n<p><em>Well, that was quite motivating, wasn&#39;t it?&nbsp;</em></p>\n\n<p>But like most of the important things, this is both true and false at the same time. Not all problems have been solved because someone decided to solve it and then came up with a way to solve it. Many a times it happens that you are just trying a few things and solutions come up. Looking into the history of science, it seems that the&nbsp;most of the novel ideas just <em>appeared</em> somehow.&nbsp;</p>\n\n<p>But nonetheless, you have to be prepared to find a solution. A solution doesn&#39;t occur to someone who has not even thought about the problem <em>(in some rare cases, it might come, but would be useless unless, someone familiar with the problem picks it up)</em>.</p>\n\n<p>Second philosophy in problem-solving is: <strong>Know the problem</strong>. I already mentioned that novel solutions come from the exploration<i> </i>instead of techniques. But you have to be ready,&nbsp;prepared, you must have knowledge about the nature of the problem to find a solution. The more you study the problem, the closer you will move towards a solution (<em>if there&#39;s any</em>).</p>\n\n<hr class=\"dots\" />\n<h2>Elimination Method</h2>\n\n<p>It is said that in life,&nbsp;you <em>should</em> follow the path which gives you hope and light, and abandon the path of darkness; similarly while solving a problem if you have many options to choose from (paths to walk upon), choose one (or many)&nbsp;which give you hope to get to solution &amp; eliminate the other options/paths.</p>\n\n<p><span style=\"font-size:16px;\"><strong>But how do you know that which path is helpful and which is not?</strong></span></p>\n\n<p>This depends on the problem being asked, and the characteristics of paths, and your prior experience. <em>[Although, this is a very generic statement, not much helpful]</em></p>\n\n<p>So, we can say that you can apply different modes of thinking to do the elimination. The different modes of thinking are &mdash; Logical System (mathematics, deductions etc), Though Experiments, Intuition/Imagination etc. Just remember that only Logical system of thiking guarantees that the conclusion will hold true (if the assumptions are true). Other modes of thinking <em>are</em>&nbsp;helppful, but, generally,&nbsp;you cannot exercise them at your will.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<div>\n<h2>From Pieces to The Whole</h2>\n\n<p>A classic technique of problem solving&nbsp; &mdash;&nbsp; <a href=\"https://en.wikipedia.org/wiki/Reductionism\">Reductionism</a>. The idea is to reduce the problem into parts, then solve the parts and then combine those&nbsp;solutions to get the solution for the whole problem.</p>\n\n<p>In computer programming, this is seen as <em><strong>Divide and Conquer</strong></em>. The main thing is that there must a step, a possibility of coming up with the &quot;merge&quot; step, that would help in solving the overall problem from the pieces, otherwise you are just left with pieces of the solution.</p>\n\n<p>&nbsp;</p>\n\n<h2>From Simpler to The Complex</h2>\n\n<p>Before solving the problem of large size, see how it evolved from smaller size. Ask yourself, &quot;had the problem been smaller in size,&nbsp;how would I solve it&quot;, and &quot;if I&nbsp;could remember the&nbsp;solutions for the smaller sizes of the problem,&nbsp;does it help in solving the bigger problem?&quot;</p>\n\n<p>In computer programming, this manifests in&nbsp;<em><strong>Dynamic Programming</strong></em>. Again, this works if there&#39;s a method to jump from solution of smaller to bigger form of the problem. This can be figured by applying Logic (especially mathematical logic).</p>\n\n<p>Another way to say this is &mdash;break down the problems, write them down, start from the smallest version, build the solution up (Bottom Up solutions).&nbsp;</p>\n\n<p><em>[It is interesting to see that our world has favored, continues to favor&nbsp;Top Down solutions, of course due to constraints, which is manifested in all sort of <strong>authority-</strong>based systems]</em></p>\n\n<div>&nbsp;</div>\n\n<h2>Occam&#39;s Razor</h2>\n\n<p>a.k.a. Ockham&#39;s razor or Ocham&#39;s razor or law of parsimony.</p>\n\n<p>Entities (involved in the problem/solution space) should not be multiplied without necessity. (It is misquoted as &quot;The simplest solution is most likely the right one&quot;).&nbsp;<br />\nIf you have many hypotheses which make the same predictions, one should choose the solution with the fewest assumptions.</p>\n\n<blockquote>\n<p>In science, Occam&#39;s razor is used as an abductive heuristic in the development of theoretical models rather than as a rigorous arbiter between candidate models.<br />\nAbductive reasoning (also called <a href=\"/#/article/230\">abduction, abductive inference, or retroduction</a>) is a form of logical inference which starts with an observation or set of observations then seeks to find the simplest and most likely explanation for the observations. This process, unlike deductive reasoning, yields a plausible conclusion but does not positively verify it. Abductive conclusions are thus qualified as having a remnant of uncertainty or doubt, which is expressed in retreat terms such as &quot;best available&quot; or &quot;most likely.&quot; One can understand abductive reasoning as inference to the best explanation, although not all usages of the terms abduction and inference to the best explanation are exactly equivalent</p>\n</blockquote>\n\n<p>&nbsp;</p>\n\n<hr class=\"dots\" />\n<h2>&nbsp;</h2>\n\n<h2>Backtracking</h2>\n\n<p>One idea of solving problems is &mdash;&nbsp;just try some path that will hopefully lead to solution.&nbsp;If you finally discover that this path was not correct, go back to starting point of the path, and choose another path.</p>\n\n<p>The process can be generalized as: Choose one path, move along with it trying to find the solution. If you find at last that this was the wrong path, start over with another path. <em>[You must keep track of the starting point]</em></p>\n\n<p>This is a rather simplistic method, and should be followed only if somehow you are not able to follow any other way of problem solving.</p>\n\n<p>&nbsp;</p>\n\n<h2>The Least Effort Principle</h2>\n\n<p>Rather than giving a good way for solving a problem, this principle simply states&nbsp;the common way which people choose to solve problems. They choose a path which takes least amount of effort, offers least resistance.</p>\n\n<p>For example, one might consult a generalist co-worker down the hall rather than a specialist in another building, so long as the generalist&#39;s answers were within the threshold of acceptability.</p>\n\n<p>In computer engineering domain, this is manifested when programmers choose to apply patches, write imperative lines of code without thinking much about the structure, design etc.</p>\n\n<p>In general, this is manifested when people choose to take the problem (as it appears at the moment), and try to solve it rarther than diving deep into the root of the problem. <em>[Though, problem analysis is slippery slope, how long would you analyse, how many factors would you consider etc]. </em><strong>Instant Gratification </strong>can also be seen as a manifestation of this principle, if it is seen in terms of problem and solutions.</p>\n\n<p><strong>Confirmation Bias</strong>, can also be seen in the same light. People fall prey to confirmation bias because their mental system chooses the least effort path.</p>\n\n<p>General Law of Computation &mdash; that natural, autopoetic systems tend to take the path (toward <em>&quot;solution&quot;</em>) which involves <strong>the least computation</strong> <em>(we can say least expenditure of resources, to generalise)</em>&mdash;also manifests the above principle. <em>[This has been noted in theory&nbsp;of Evolution, theory&nbsp;of Innate Language system in humans, ....]</em></p>\n\n<p>&nbsp;</p>\n\n<h2>Simplest Non-trivial Example</h2>\n\n<p>While doing research, or solving a problem, after listing down trivial examples, find and work on the <strong><em>&quot;simplest non-trivial example&quot;</em></strong>.</p>\n\n<p>Symmetry Finding: Take advantage of <em>symmetries</em>, similarities of parts,&nbsp;if any, in the problem.</p>\n\n<p>&nbsp;</p>\n\n<h2 class=\"firstHeading\" id=\"firstHeading\" lang=\"en\">Fundamental theorem of software engineering</h2>\n\n<p>We can solve any problem by introducing an extra level of <a href=\"https://en.wikipedia.org/wiki/Indirection\" target=\"_blank\" title=\"Indirection\">indirection</a>.</p>\n\n<p>This principle is generally fit for solving system designs rather than Algorithm design.</p>\n\n<p>This can also be seen in Beurocratic systems (government, management), in Economics (e.g. Franchise model).</p>\n\n<p>&nbsp;</p>\n\n<h2>Abstract Representation</h2>\n\n<p>It helps a lot to represent the problem in a way that you are already familiar with, and the way which already has been studied, which is easier to see and analyze. You can use geometry, algebra, pictures, graphs to represent it.</p>\n\n<p>Try to generalize the problem without losing much of the information about the particular aspects of the problem.</p>\n\n<p>Just by simple representation, you will get an abstract form of the problem. Then go on refining the details of it, find the patterns, apply existing knowledge to it to reach a solution. Note that best form of abstract representation known to man is mathematics.</p>\n\n<p>In computer engineering, often diagrams are used. Although in computer <em>science</em>, people use a combined approach (diagrams, mathematics etc) to come up with solutions.</p>\n\n<p>&nbsp;</p>\n\n<h2>Verification&nbsp;of the Solution</h2>\n\n<p>Often times, we think that we have found the solution but do not&nbsp;try out various possibilities, different use-cases etc. This&nbsp;results in a situation where we&nbsp; have illusion of the solution, but do not have a real solution. In computer&nbsp;programs it&#39;s called <em>bug</em>. <em>[In societies, it results in crisis.]</em></p>\n\n<p>So, it&#39;s only wise to try the solution on different forms of&nbsp;the problem. By different forms I mean that different ccombination of values for the variables, entities involved&nbsp; in the problem.</p>\n\n<p>It is not just&nbsp;enough to find a solution, you must know how the solution works, and why the solution works. You should be able to <em>prove</em> it&nbsp;somehow. In computer science this is called Correctness proof/checking.</p>\n\n<p>&nbsp;</p>\n\n<h2>Tradeoff Consideration</h2>\n\n<p>While solving any problem, there are tradeoffs to consider. There is nothing <em>perfect</em>. And no problem can be solved in a <em>perfect</em> way because of the constraints. You have to take the constraints into account while developing the solution.</p>\n\n<p>In computer programming while developing algorithms, a&nbsp;common tradeoff is between <em>Memory</em> and <em>Computational complexity (runtime)</em>.&nbsp;</p>\n\n<p>In computer architecture problems, you&nbsp;have tradeoff between flexibility and complexity.</p>\n\n<p>You might not even have that much time to implement a very good solution, so you can consider a lean solution instead. In general life, the tradeoff could be as simple &mdash; and equally difficult &mdash;&nbsp;as <em>deciding whether to act or not, </em>whether to apply a solution (whatever minimal, fuzzy, insufficient solution we have at hand) or not, whether to at least try or not.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>Multi-Dimensional Approach</h2>\n\n<p>Same problem/solution can be approached in multiple ways. Moreover, considering multiple ways may lead to multiple solutions, then you can choose the &quot;best&quot; one among them. And this can lead to some novel solutions as well.</p>\n\n<p><strong>Write down</strong> different ways from which the problem can be seen. Then pick them one by one and proceed.&nbsp;</p>\n\n<p>It&#39;s better to <strong>write down (specify)</strong> assumptions as well, and test for aassumptions before making significant progress on a particular path. Also, factor in <strong><em>unknowns</em></strong>.</p>\n\n<p>&nbsp;</p>\n\n<h2>Systemic Problem Solving</h2>\n\n<p>Actually there&#39;s no systemic way of problem solving, because most of the crucial steps that advance the problem solving (in any domain &mdash;&nbsp;science, philosophy, society etc) come somewhat accidently &mdash;from intuition, imagination, or just purely accidental discovery etc &mdash; still we might want to have some sort of framework, which would help in at least transferring the knowledge (from past) of problem solving to present,&nbsp;from one domain to another, or from one problem to another.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/Problem_Solving_Approach.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n</div>\n</div>\n\n<p>&nbsp;After doing the problem solving, you would want to have a system in place. Note that there is no hard boundary between problem solving and system designing steps. They may be&nbsp;co-dependent.</p>\n\n<p>Also, note that <em><strong>there is no perfect system</strong></em>.</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Problem_Solution.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>Note that there&#39;s no solid boundary of the problem space and the solution space. This manifests in most of the complex problems in the real world. The fuzzy boundary may&nbsp;<strong><em>evolve</em></strong>&nbsp;into&nbsp;solid boundary with time. <em>[It may&nbsp;not be because we were able to correctly define the original problem, it could be just because we narrowed down the problem, and just accepted it to our satisfaction]</em> We can even say that the evolution is much like the evolution in natural world, and much like the evolution of sciences.</p>\n\n<p>One of the main observations in evolutions is Punctuated Equilibrium &mdash; for a long time the current situation (solution space, and&nbsp;artefacts seem enough), but then a crisis occurs (<em>often noted by <strong>other</strong> people, someone who sees a new problem, or discovers conflicts, inconsistencies, paradoxes, insufficiencies etc</em>), and then a <strong>paradigm shift</strong> happens (often by different people coming together), ... <em><strong>this cyle continues</strong></em>. In simple problem domains this thing is manifested simply as unforeseen requirements coming up.</p>\n\n<p>While designing any sort of system, you would also like to keep the people involved in the system (users, actors etc)</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Users_Context.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://storage.googleapis.com/cupitor-220103.appspot.com/images/System_Design_Entities_Etc.jpg\" style=\"max-width: 100%; overflow: scroll;\" /></p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "algos", "tags": [""], "img": "", "summary": "", "lastUpdated": "2021-02-20 09:24:07.284399"}