{"name":"Reactive Programming","id":155,"content":"<ul>\n\t<li>A&nbsp;<strong>Function</strong>&nbsp;is a lazily evaluated computation that synchronously returns a single value on invocation.</li>\n\t<li>A&nbsp;<strong>generator</strong>&nbsp;is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</li>\n</ul>\n\n<p style=\"margin-left: 40px;\">Normally we use Functions or Generators for programming, in which we pull data by invoking function() or generator.next()</p>\n\n<ul>\n\t<li>A&nbsp;<strong>Promise</strong>&nbsp;is a computation that may (or may not) eventually return a single value.</li>\n\t<li>An&nbsp;<strong>Observable</strong>&nbsp;is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it&#39;s invoked onwards.</li>\n</ul>\n\n<p>How is Observable different from&nbsp;EventEmitters ?</p>\n\n<p style=\"margin-left: 40px;\">EventEmitters share the side effects and have eager execution regardless of the existence of subscribers, Observables have no shared execution and are lazy.</p>\n\n<p style=\"margin-left: 40px;\">Subject (a special&nbsp;Observable) is equivalent to&nbsp;EventEmitters.</p>\n\n<p>Are&nbsp;Observables asynchronous?</p>\n\n<p style=\"margin-left: 40px;\">Not always. Not by default. Subscribing to an Observable is equivalent to calling a function.</p>\n\n<p>Typical Obserber flow:</p>\n\n<ul>\n\t<li><strong>Creating</strong>&nbsp;Observables</li>\n\t<li><strong>Subscribing</strong>&nbsp;to Observables</li>\n\t<li><strong>Executing</strong>&nbsp;the Observable</li>\n\t<li><strong>Disposing</strong>&nbsp;Observables</li>\n</ul>\n\n<p>How is subscription different from&nbsp;event handler APIs like&nbsp;<code>addEventListener</code>&nbsp;/&nbsp;<code>removeEventListener?</code></p>\n\n<p style=\"margin-left: 40px;\">The Observable does not even maintain a list of attached Observers. However a Subject does maintain list of observers.</p>\n\n<h2>RxJS</h2>\n\n<pre>\n<code class=\"language-javascript\">//Create observer\nvar observable = Rx.Observable.create(function subscribe(observer) {\n  var id = setInterval(() =&gt; { //asynchronously\n    observer.next('hi')\n  }, 1000);\n});\n\nRx.Observable.interval(1000);\n</code></pre>\n\n<p>Subscriptions can also be put together, so that a call to an&nbsp;<code>unsubscribe()</code>&nbsp;of one Subscription may unsubscribe multiple Subscriptions. You can do this by &quot;adding&quot; one subscription into another:</p>\n\n<p>A Subject is both an Observable and an Observer.&nbsp;Subjects are the only way of making any Observable execution be shared to multiple Observers.</p>\n\n<pre>\n<code class=\"language-javascript\">var subject = new Rx.Subject();\nsubject.subscribe({\n  next: (v) =&gt; console.log('observerA: ' + v)\n});\nsubject.subscribe({\n  next: (v) =&gt; console.log('observerB: ' + v)\n});\n\nvar observable = Rx.Observable.from([1, 2, 3]);\nobservable.subscribe(subject); // You can subscribe providing a Subject</code></pre>\n\n<p>Variants of Subject:&nbsp;BehaviorSubject, ReplaySubject,&nbsp;AsyncSubject</p>\n\n<p>ReplaySubject is more generalized&nbsp;BehaviorSubject: It records the values it emits and provides the history as soon as someone subscribes. You can control the amount of records and the timeline from history to record.</p>\n\n<p>AsyncSubject sends only the last value emitted by source, and only when execution completes.</p>\n\n<p>Operators:</p>\n\n<pre>\n<code class=\"language-javascript\">//Transform:  mapTo(constant), pluck are utility operators which can be replaced by map\n//Peek: do operator\n//Choose: filter, first(predicate), take(count), takeWhile(predicate), elementAt(i), last, takeLast, takeUntil(anotherObservableWhichGivesStopSignal)\n//Ignore: ignoreElements (all from now on), skip, skipWhile, skipUntil, distinct(function to select distinct based on what), distinctUntilChanged, distinctUntilKeyChanged(keyName, biFunctionPredicateOnKeyName))\n//Ignore too frequent items: Based on time-window: \n      .throttle(ev =&gt; Rx.Observable.interval(1000)); //Or\n      .throttleTime(1000);\n      //Throttle emits first value in each time interval and ignores others\n//    .audit emits the last value instead.\n//Ignore items if not enough time has passed since last emit. Rate-delimiting\n     //.debounce\n//Perform computation on all values emitted:\n     //.reduce to one output value which will be emitted on completion.\n     //.reduce =~ .scan() followed by last()\n     //.mergeScan when accumulator function itself returns an observable\n//Fallbacks\n     .timeout //throw error\n     .timeoutWith //switch to another source\n//Delay\n     .delay(amount)\n     .delayWhen(someObservable_emits_value)\n//Grouping\n     .pairwise\n     .partition\n   //batching\n     .bufferCount\n     .windowCount\n     .bufferTime\n     .windowTime\n     .buffer(until_other_observer_emits)\n     .window(until_other_observer_emits)\n   //buffer and window operators do same thing, but buffer returns an array instead of an Observable\n     .bufferWhen(when_other_observer_emits)\n     .windowWhen\n     .bufferToggle, .windowToggle\n\n//Nesting\n     //New observable for each value\n     .mergeMap and .mergeMapTo //parallel version\n     .concatMap and .concatMapTo //ordered version\n\n    \n \n</code></pre>\n\n<pre>\n<code class=\"language-javascript\">javascript: (function() {\n    var checkAndInject = function(name, url) {\n        if (typeof window[name] != 'undefined') {\n            return console.log(name + ' already present: v' + jQuery.fn.jquery);\n        }\n        var script = document.createElement('script');\n        script.src = url;\n        var head = document.getElementsByTagName('head')[0],\n            done = false;\n        script.onload = script.onreadystatechange = function() {\n            if (!done &amp;&amp; (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) {\n                done = true;\n                if (typeof jQuery == 'undefined') {\n                    console.log(name + ' not loaded');\n                } else {\n                    console.log(name + ' loaded');\n                }\n                script.onload = script.onreadystatechange = null;\n                head.removeChild(script);\n            }\n        };\n        head.appendChild(script);\n    };\n\n    function getSelectionText() {\n        var text = \"\";\n        if (window.getSelection) {\n            text = window.getSelection().toString();\n        } else if (document.selection &amp;&amp; document.selection.type != \"Control\") {\n            text = document.selection.createRange().text;\n        }\n        return text;\n    }\n    \n\n    checkAndInject('jQuery', 'https://code.jquery.com/jquery-latest.min.js');\n    try { if (window['$'] == undefined) $ = jQuery; } catch(e){}\n    checkAndInject('fabric', 'https://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.7.20/fabric.js');\n    checkAndInject('Rx', 'https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.5.2/Rx.js');    \n})();\n\nfunction addCanvasPlayer(){\n    $('body').prepend($('&lt;canvas&gt;').attr({id: 'myCanvasPlayer', width: 1300, height: 600}).css({\n        position: 'fixed', top: '15%', left: '15%', width: '80%', zIndex: 1000\n    }))\n   \n}\n\nfunction showImageInCanvas(url){\n    slideshowControl.pause();\n    fabric.Image.fromURL(url, img =&gt; {\n        img.set({left: 0, top: 0, width: 600, height: 600});\n        canvas.add(img);\n        slideshowControl.resume();\n    })    \n}\n\nfunction slideshow(delay){\n    var images = $('.product-thumb').toArray().map(x =&gt; $(x).attr('data-src2'));\n    console.log(images.length+' images');\n\n    var eachSecond = Rx.Observable.interval(delay).take(images.length);\n    var pauser = new Rx.Subject();\n    \n    var shouldStop = pauser.switchMap(paused =&gt; paused ? Rx.Observable.never() : Rx.Observable.interval(delay).map(x=&gt; true));\n\n    var pausable = Rx.Observable.zip(eachSecond, shouldStop).timeInterval().map(x =&gt; x.value[0]);\n\n    window.slideshowControl = {\n        resume: ()=&gt; shouldStop.next(false),\n        pause: ()=&gt; shouldStop.next(true)\n    };\n\n    window.slideshowSource = pausable;\n\n    pausable.subscribe(indx =&gt; {\n        console.log(\"showing image number \"+ indx +\" \"+images[indx]);\n        showImageInCanvas(images[indx]);\n    });\n\n    Rx.Observable.fromEvent(document, 'keyup')\n        .map((e) =&gt; e.key).subscribe(key=&gt; {\n            switch(key){\n                case 'p': slideshowControl.pause(); break;\n                case 'r': slideshowControl.resume(); break;\n            }\n        })\n}\n\naddCanvasPlayer()\ncanvas = new fabric.Canvas('myCanvasPlayer')\n\nslideshow(5000)\nslideshowControl.resume()\n\n</code></pre>\n","authorId":null,"subject":"linked-to-143","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:26.461+0000"}