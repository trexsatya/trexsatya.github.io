{"name":"Java System Performance","id":80,"content":"<p>So your application is slow. How would you solve this. First thing: find the culprit.&nbsp;</p>\n\n<p><strong>Who is the culprit? </strong></p>\n\n<p>Is it your application coding?&nbsp; Is it the JVM you are using? Is it the Garbage Collection system that is being used? Is it the machine you are using? Is it the infrastructure you are using? Is it some other process that&#39;s interfering? Is it multithreading that&#39;s the culprit?</p>\n\n<p><strong>Your application could be culprit</strong>, if it is unncessarily creating objects, and maintaining them for more than required time (kind of Memory Leakage). The processing path (algorithm implmented, etc) could also be problem.</p>\n\n<p>&nbsp; If you find out that application code is the culprit, how would you solve this?&nbsp;</p>\n\n<ul>\n\t<li>Write better algorithms</li>\n\t<li>Eliminate memory leakage, Minimize memory requirements, Create less objects, Reduce the scope and lifecycle of objects</li>\n\t<li>Many libraries provide High Performance Computing. Use them instead of writing on your own.</li>\n</ul>\n\n<p><strong>Your JVM could be culprit:</strong>&nbsp;There are different variants of JVMs out there. Sun&#39;s JVM can be and needs to be tuned for specific requirements.</p>\n\n<p>&nbsp;&nbsp;The Sun JVM understands the options -classic, -client and -server</p>\n\n<ul>\n\t<li>classic : disables the Hotspot JIT compiler.</li>\n\t<li>client (default): activates the Hotspot JIT for &quot;client&quot; applications.</li>\n\t<li>server: activates the &quot;server&quot; Hotspot JIT: it requires a fair amount of time to warm up, but delivers best performance for server.</li>\n</ul>\n\n<p>There are many possibilities for JVM implementations. IBM J9 , Azul Zulu , Azul Zing , Oracle JDK.&nbsp;<a href=\"https://en.wikipedia.org/wiki/List_of_Java_virtual_machines\" target=\"_blank\">See https://en.wikipedia.org/wiki/List_of_Java_virtual_machines</a></p>\n\n<p><strong>Garbage Collector could be culprit:</strong>&nbsp; because it might be spending more time cleaning up objects, GC can be and has to be configured (tuned) to suit your application requirements. How would you tune the GC, depends on what&#39;s your requirement.</p>\n\n<p><strong>The machine could be the culprit:</strong>&nbsp;32-bit machines are slower, 32-bit Java is also slower than 64-bit Java. Some machine (and CPU) architectures perform better than others.</p>\n\n<p><strong>Is it some other process interfering</strong> : maybe some process is running in background that&#39;s keeping IO busy, hence your application being slowed down. Remember this kind of issue sometimes hard to find by inspecting logs.</p>\n\n<p><strong>Multi-threading could be culprit:</strong>&nbsp;Remeber synchronization comes at the cost of performance. Deadlock, Livelock could be issue.</p>\n\n<p>&nbsp; &nbsp; You might need to tune thread-pool size. You can try to make your applicaiton as lock-free as possible. Use lock-free concurrent implementation instead of synchronized and lock-based data structures.</p>\n\n<p><strong>DB could be the culprit:</strong>&nbsp;There are many situations which make DB slow.&nbsp;</p>\n\n<ul>\n\t<li>Lack of indexing or wrong indexing</li>\n\t<li>N+1 Problem</li>\n\t<li>Unnecessary joins. (There could be better way to fetch same data)</li>\n</ul>\n\n<p>There are different type of databases (Relational, Non-relational, Graph based) which have their own benefits in different situations. Try using different databases for different use-cases.</p>\n\n<p>Use caching whenever possible. (There are many high performance caching solutions out there, however distributed caching is a non-trivial problem)</p>\n\n<p>READ:&nbsp;<a href=\"https://www.dynatrace.com/resources/ebooks/javabook/\" target=\"_blank\">https://www.dynatrace.com/resources/ebooks/javabook/</a></p>\n","authorId":null,"subject":"hidden","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:23.296+0000"}