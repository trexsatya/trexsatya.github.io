{"name":"Thread Pools - What, Why, How","id":25,"content":"<p>Thread Pool: is a construct which maintains some ready-to-use threads, so that they do not have to be created. Also, these threads will be reused once they finish the task assigned.</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Why use Thread Pools?</strong></span></p>\n\n<p>&nbsp; Reasons: To bound resource usage, prevent livelock by limiting number of threads executing simultaneously,</p>\n\n<p>java.util.concurrent.Executors class has factory methods which create different types of thread pools:</p>\n\n<ul>\n\t<li>The&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool-int-\" target=\"_blank\"><code>newCachedThreadPool</code></a>&nbsp;method creates an executor with an expandable thread pool. This executor is suitable for applications that launch many short-lived tasks.</li>\n\t<li>The&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor-int-\" target=\"_blank\"><code>newSingleThreadExecutor</code></a>&nbsp;method creates an executor that executes a single task at a time.</li>\n\t<li>Several factory methods are&nbsp;<code>ScheduledExecutorService</code>&nbsp;versions of the above executors.</li>\n</ul>\n\n<pre>\n<code>ScheduledExecutorService</code>&nbsp;is preferable to java.util.Timer when multiple worker threads are needed.</pre>\n\n<h2>Minimalistic Thread Pool Implementation</h2>\n\n<pre>\n<code class=\"language-java\">int minimumAliveWorkers;\nint CAPACITY;\n\nclass Worker implements Runnable{\n   Thread thread; //this worker will run in\n\n   Worker(){ thread = threadFactory.newThread(); }\n   \n   lock(){}\n   unlock(){}\n   isLocked(){}\n   interruptIfStarted(){\n     if(!thread.isInterrupted()) thread.interrupt();\n   }\n\n   run(){  runWorker(this); }\n}\n\nrunWorker(Worker w){\n  Thread wt = Thread.currentThread();\n  w.unlock(); // allow interrupts\n  Runnable task = null;\n\n  try {\n        while( (task = getTask() != null){\n        w.lock();\n\n        try {\n            beforeExecute(wt, task); //hook\n            Throwable thrown = null;\n            try {\n                task.run();\n            } catch (Throwable x) {\n                thrown = x; throw x;\n            } finally {\n                afterExecute(task, thrown); //hook\n            }\n        } finally {\n            task = null;\n            w.completedTasks++;\n            w.unlock();\n        }        \n      }\n  }finally {\n    processWorkerExit(w);\n  }\n}\n\ngetTask(){ workQueue.take(); }\n\nprocessWorkerExit(Worker w) {\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n    //If replacement needed, e.g. \n    addWorker();\n}\n\naddWorker(){\n   Worker w = new Worker();\n   workers.add(w);\n   workerCount++;  \n\n   w.thread.start();\n\n   return w;\n}\n\nexecute(Runnable task){\n  if(workerCount &lt; minimumAliveWorkers) {\n    runWorker(addWorker());\n    return;\n  }\n  if(workerCount == CAPACITY){ reject(); return; }\n\n  workQueue.offer(task);\n}\n\nshutdown(){\n  for(Worker w: workers){\n    Thread t = w.thread;\n    if (!t.isInterrupted() &amp;&amp; w.tryLock()) {\n        try {\n            t.interrupt();\n        } catch (SecurityException ignore) {\n        } finally {\n            w.unlock();\n        }\n    }\n  }\n}\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"color:#2980b9;\">Efficiently Using Thread Pools From Executor Framework</span></h2>\n\n<p>&nbsp; PooledExecutor:<br />\n&nbsp; &nbsp; Queueing:&nbsp;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; Queless synchronous channel to hand off commands to threads. Might be good if tasks are interdependent.<br />\n&nbsp; &nbsp; &nbsp; &nbsp; Queued channels: for tasks which are independent, e.g. handling HTTP requests<br />\n&nbsp; &nbsp; &nbsp; &nbsp; Queing is good for smoothing out temporary bursts, but if average incoming is greater than outgoing, it slows down the system.<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;In these cases, use you should run the thread if blocked<br />\n&nbsp; &nbsp; &nbsp; &nbsp;Queue size and max pool size can be traded off<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; large Q and small pool =&gt; minimize CPU usage, OS resources, context-switch overhead. But low throughput especially if tasks frequently block e.g. on I/O<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; small Q , large pools &nbsp;=&gt; Maximize CPU usage, But scheduling overhead.</p>\n\n<p>&nbsp; &nbsp;It is possible that a new thread will be created even when there is and idle worker thread, but it has not reached to a point where it can accept new task.<br />\n&nbsp; &nbsp;It happens when burst of short tasks are executed, because handing off tasks to idle threads require synchronization which depends on JVM scheduling.</p>\n\n<p>&nbsp; &nbsp;Warm threads on startup:&nbsp;<br />\n&nbsp; &nbsp; &nbsp;Threads lying around unnecssary impede GC. So create threads with expiration time. Tradeoff between GC time and thread creation time<br />\n&nbsp; &nbsp; &nbsp;Using Weak reference may also solve the problem, but then there might be costly synchronization issue.</p>\n","authorId":null,"subject":"linked-to-138","tags":[""],"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:22.563+0000"}