{"name":"Spring Boot","id":106,"content":"<h2>Overview</h2>\n\n<p>In initial days of Spring, it was quite hard to kickstart a project. You had to write a lot of configurations in XML files, place them at right location on classpath. There was a high possibilty that you would mess things up first time. To make things easy Spring tried many things. With newer versions of Spring released it became easier to bootstrap an application.&nbsp;</p>\n\n<p>Now a days it&#39;s super easy to create a Spring application with Spring Boot. Spring Boot magically sets the correct default configurations for you. You can then customize as per your needs.</p>\n\n<h2>Creating Spring Boot Application</h2>\n\n<ul>\n\t<li>Go to&nbsp;<a href=\"https://start.spring.io/\" target=\"_blank\">https://start.spring.io/</a>&nbsp;</li>\n\t<li>Select what features you intend to use in your application, download ZIP file, import the project in your IDE.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String... args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n\n<p>This is all you need to start a Spring application with Spring Boot. Place this class in root package (I mean, main package), and other Spring beans in subpackages, and you are good to go.</p>\n\n<p>This short code does a lot of work:</p>\n\n<p>If you see the code of <code>@SpringBootApplication</code></p>\n\n<pre>\n<code class=\"language-java\">@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters={@ComponentScan.Filter(type=CUSTOM,classes=TypeExcludeFilter.class),})\npublic @interface SpringBootApplication {\n  //....\n}</code></pre>\n\n<p>Most amazing work is done by <code>@EnableAutoConfiguration</code>. Read the explainatory documentation for it:&nbsp;<a href=\"https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html\" target=\"_blank\">https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html</a></p>\n\n<p>You can exclude certain auto-configurations to take control. See <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html\" target=\"_blank\">here</a>. (Summary: use annotation property or external propery <code class=\"literal\">spring.autoconfigure.exclude)</code></p>\n\n<p>&nbsp;</p>\n\n<p>Spring Boot gives you an embedded Tomcat server, which is helpful in creating microservices, you don&#39;t have to do server setup, and you can run the application as a JAR application. Spring Boot also provides you with in built functionality to monitor health of the system, and stats too.</p>\n\n<p>If you want, you can use some other server instead of Tomcat. See how to do that, <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html\" target=\"_blank\">here</a>. (Summary: exclude &quot;<code>org.springframework.boot:spring-boot-starter-tomcat</code>&quot; from &quot;<code>org.springframework.boot:spring-boot-starter-web</code>&quot; and include &quot;<code>org.springframework.boot:spring-boot-starter-jetty</code>&quot; using your dependency management tool (Maven or Gradle).</p>\n\n<p>To configure the web server you have different Factory classes like <code class=\"literal\">TomcatServletWebServerFactory, JettyServletWebServerFactory</code>, <code class=\"literal\">TomcatReactiveWebServerFactory</code></p>\n\n<p>Once you&rsquo;ve got access to a <code class=\"literal\">WebServerFactory</code>, you can often add customizers to it to configure specific parts, like connectors, server resources, or the server itself - all using server-specific APIs.</p>\n\n<p>Spring Boot allows you to easily register Filters, Servlets, Listeners by using annotations. <code class=\"literal\">@WebServlet</code>, <code class=\"literal\">@WebFilter</code>, and <code class=\"literal\">@WebListener</code> annotated classes can be automatically registered with an embedded servlet container by annotating a <code class=\"literal\">@Configuration</code> class with <code class=\"literal\">@ServletComponentScan</code> and specifying the package(s) containing the components that you want to register. By default, <code class=\"literal\">@ServletComponentScan</code> scans from the package of the annotated class.</p>\n\n<p><strong>Spring Boot Starters</strong></p>\n\n<p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, include the <code class=\"literal\">spring-boot-starter-data-jpa</code> dependency in your project. You can create your own starter, see <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html#boot-features-custom-starter\" target=\"_blank\">here</a>.</p>\n\n<p>&nbsp;</p>\n\n<h2>Easy REST with Spring Boot</h2>\n\n<p>Use annotations <code class=\"literal\">@RestController</code><em><span class=\"hl-annotation\" style=\"color: gray\"> <code>@RequestMapping</code></span></em></p>\n\n<p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto-spring-mvc.html\" target=\"_blank\">See the doc</a>.</p>\n\n<p>By default JSON is used in Rest controllers, you can have XML instead either by having <code class=\"literal\">jackson-dataformat-xml</code> on classpath, JAXB on classpath (but then you will need to annotate your model POJOs with <code class=\"literal\">@XmlRootElement</code></p>\n\n<p>If you are using above Java 1.8, you will need to include org.glassfish.jaxb:jaxb-runtime in your dependency management file.</p>\n\n<p>To get the server to render XML instead of JSON, you might have to send an <code class=\"literal\">Accept: text/xml</code> header (or use a browser).</p>\n\n<p>You can take full control of MVC configuration. Use <code class=\"literal\">@Configuration</code> with the <code class=\"literal\">@EnableWebMvc</code> annotation and provide all configurations including ViewResolver, MessageConverter etc</p>\n\n<h2>Testing With Spring Boot</h2>\n\n<p>Spring Boot provides easy setup to write integration tests too.</p>\n\n<p><code class=\"literal\">Use spring-boot-starter-test in dependency management.</code></p>\n\n<p>Spring Boot provides a <code class=\"literal\">@SpringBootTest</code> annotation, which can be used as an alternative to the standard <code class=\"literal\">spring-test</code> <code class=\"literal\">@ContextConfiguration</code> annotation when you need Spring Boot features. The annotation works by <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config\" title=\"46.3.2 Detecting Test Configuration\">creating the <code class=\"literal\">ApplicationContext</code> used in your tests through <code class=\"literal\">SpringApplication</code></a>. In addition to <code class=\"literal\">@SpringBootTest</code> a number of other annotations are also provided for <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests\" title=\"46.3.8 Auto-configured Tests\">testing more specific slices</a> of an application.</p>\n\n<p>If you are using JUnit 4, don&rsquo;t forget to also add <code class=\"literal\">@RunWith(SpringRunner.class)</code> to your test, otherwise the annotations will be ignored. If you are using JUnit 5, there&rsquo;s no need to add the equivalent <code class=\"literal\">@ExtendWith(SpringExtension.class)</code> as <code class=\"literal\">@SpringBootTest</code> and the other <code class=\"literal\">@&hellip;Test</code> annotations are already annotated with it.</p>\n\n<p>By default, <code class=\"literal\">@SpringBootTest</code> will not start a server. You can use the <code class=\"literal\">webEnvironment</code> attribute of <code class=\"literal\">@SpringBootTest</code> to further refine how your tests run:</p>\n\n<div class=\"itemizedlist\">\n<ul class=\"itemizedlist\" style=\"list-style-type: disc; \">\n\t<li class=\"listitem\"><code class=\"literal\">MOCK</code>(Default) : Loads a web <code class=\"literal\">ApplicationContext</code> and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web <code class=\"literal\">ApplicationContext</code>. It can be used in conjunction with <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-mock-environment\" title=\"46.3.4 Testing with a mock environment\"><code class=\"literal\">@AutoConfigureMockMvc</code> or <code class=\"literal\">@AutoConfigureWebTestClient</code></a> for mock-based testing of your web application.</li>\n\t<li class=\"listitem\"><code class=\"literal\">RANDOM_PORT</code>: Loads a <code class=\"literal\">WebServerApplicationContext</code> and provides a real web environment. Embedded servers are started and listen on a random port.</li>\n\t<li class=\"listitem\"><code class=\"literal\">DEFINED_PORT</code>: Loads a <code class=\"literal\">WebServerApplicationContext</code> and provides a real web environment. Embedded servers are started and listen on a defined port (from your <code class=\"literal\">application.properties</code>) or on the default port of <code class=\"literal\">8080</code>.</li>\n\t<li class=\"listitem\"><code class=\"literal\">NONE</code>: Loads an <code class=\"literal\">ApplicationContext</code> by using <code class=\"literal\">SpringApplication</code> but does not provide <span class=\"emphasis\"><em>any</em></span> web environment (mock or otherwise).</li>\n</ul>\n\n<p class=\"listitem\">You don&#39;t need to use <code class=\"literal\">@ContextConfiguration(classes=&hellip;​) </code>Spring Boot&rsquo;s <code class=\"literal\">@*Test</code> annotations search for your primary configuration automatically whenever you do not explicitly define one.</p>\n\n<p class=\"listitem\">The search algorithm works up from the package that contains the test until it finds a class annotated with <code class=\"literal\">@SpringBootApplication</code> or <code class=\"literal\">@SpringBootConfiguration</code>. As long as you <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-structuring-your-code.html\" title=\"14. Structuring Your Code\">structured your code</a> in a sensible way, your main configuration is usually found.</p>\n\n<p class=\"listitem\">If you want to customize the primary configuration, you can use a nested <code class=\"literal\">@TestConfiguration</code> class. Unlike a nested <code class=\"literal\">@Configuration</code> class, which would be used instead of your application&rsquo;s primary configuration, a nested <code class=\"literal\">@TestConfiguration</code> class is used in addition to your application&rsquo;s primary configuration.</p>\n\n<p class=\"listitem\">Spring&rsquo;s test framework caches application contexts between tests. Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once.</p>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@WebMvcTest(OwnerController.class)\npublic class OwnerControllerTests {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private OwnerRepository owners;\n\n    @Test\n    public void testInitCreationForm() throws Exception {\n        mockMvc.perform(get(\"/owners/new\"))\n            .andExpect(status().isOk())\n            .andExpect(model().attributeExists(\"owner\"))\n            .andExpect(view().name(\"owners/createOrUpdateOwnerForm\"));\n    }\n\n    @Test\n    public void testProcessFindFormSuccess() throws Exception {\n        given(this.owners.findByLastName(\"\")).willReturn(Lists.newArrayList(george, new Owner())); //mockito BDD\n        mockMvc.perform(get(\"/owners\"))\n            .andExpect(status().isOk())\n            .andExpect(view().name(\"owners/ownersList\"));\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@DataJpaTest(includeFilters = @ComponentScan.Filter(Service.class))\npublic class ClinicServiceTests {\n\n    @Autowired\n    protected OwnerRepository owners;\n\n    @Autowired\n    protected PetRepository pets;\n\n    @Test\n    @Transactional\n    public void shouldInsertOwner() {\n        Collection&lt;Owner&gt; owners = this.owners.findByLastName(\"Schultz\");\n        int found = owners.size();\n\n        Owner owner = new Owner();\n        owner.setFirstName(\"Sam\");\n        owner.setLastName(\"Schultz\");\n        owner.setAddress(\"4, Evans Street\");\n        owner.setCity(\"Wollongong\");\n        owner.setTelephone(\"4444444444\");\n        this.owners.save(owner);\n        assertThat(owner.getId().longValue()).isNotEqualTo(0);\n\n        owners = this.owners.findByLastName(\"Schultz\");\n        assertThat(owners.size()).isEqualTo(found + 1);\n    }\n\n}    </code></pre>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class PetclinicIntegrationTests {\n\n    @Autowired\n    private VetRepository vets;\n\n    @Test\n    public void testFindAll() throws Exception {\n        vets.findAll();\n        vets.findAll(); // served from cache\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n</div>\n\n<h2>Externalized Configurations</h2>\n\n<p>There are a lot of ways to provide property values. <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html\" target=\"_blank\">See this page to find out which setting is given priority over which</a>.</p>\n\n<p>You can provide profile specific values using files like <code class=\"literal\">application-{profile}.properties</code></p>\n\n<p>Use&nbsp;<code class=\"literal\">spring.profiles.active</code> environment property to tell which profile to use while running Spring Boot application.</p>\n\n<p>You can provide type-safe properties. <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties\" target=\"_blank\">See here</a>. (Summary: Annotate the class containing all properties required with <em><span class=\"hl-annotation\" style=\"color: gray\">@ConfigurationProperties(&quot;acme&quot;)</span></em>&nbsp; and <em><span class=\"hl-annotation\" style=\"color: gray\">@EnableConfigurationProperties(AcmeProperties.class)</span></em>on a @Configuration class.&nbsp; You can then simply inject this class in any bean)</p>\n\n<p>&nbsp;</p>\n\n<h2>Profiles</h2>\n\n<p>Any <code class=\"literal\">@Component</code> or <code class=\"literal\">@Configuration</code> can be marked with <code class=\"literal\">@Profile</code> to limit when it is loaded.</p>\n\n<p>Use property to tell Spring which profile to use while running e.g.</p>\n\n<pre class=\"programlisting\">\n<span class=\"hl-attribute\" xmlns:d=\"http://docbook.org/ns/docbook\">spring.profiles.active</span>=dev,hsqldb</pre>\n\n<p>&nbsp;</p>\n\n<h2>Spring Web-MVC</h2>\n\n<p>How does Spring Boot setup MVC framework for you.</p>\n\n<p>Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</p>\n\n<p>The auto-configuration adds the following features on top of Spring&rsquo;s defaults:</p>\n\n<div class=\"itemizedlist\">\n<ul class=\"itemizedlist\" style=\"list-style-type: disc; \">\n\t<li class=\"listitem\">Inclusion of <code class=\"literal\">ContentNegotiatingViewResolver</code> and <code class=\"literal\">BeanNameViewResolver</code> beans.</li>\n\t<li class=\"listitem\">Support for serving static resources, including support for WebJars.</li>\n\t<li class=\"listitem\">Automatic registration of <code class=\"literal\">Converter</code>, <code class=\"literal\">GenericConverter</code>, and <code class=\"literal\">Formatter</code> beans.</li>\n\t<li class=\"listitem\">Support for <code class=\"literal\">HttpMessageConverters</code> .</li>\n\t<li class=\"listitem\">Automatic registration of <code class=\"literal\">MessageCodesResolver</code> .</li>\n\t<li class=\"listitem\">Static <code class=\"literal\">index.html</code> support.</li>\n\t<li class=\"listitem\">Custom <code class=\"literal\">Favicon</code> support .</li>\n\t<li class=\"listitem\">Automatic use of a <code class=\"literal\">ConfigurableWebBindingInitializer</code> bean .</li>\n</ul>\n\n<blockquote>\n<p>If you want to keep Spring Boot MVC features and you want to add additional <a class=\"link\" href=\"https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/web.html#mvc\" target=\"_top\">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code class=\"literal\">@Configuration</code> class of type <code class=\"literal\">WebMvcConfigurer</code> but <span class=\"strong\"><strong>without</strong></span> <code class=\"literal\">@EnableWebMvc</code>. If you wish to provide custom instances of <code class=\"literal\">RequestMappingHandlerMapping</code>, <code class=\"literal\">RequestMappingHandlerAdapter</code>, or <code class=\"literal\">ExceptionHandlerExceptionResolver</code>, you can declare a <code class=\"literal\">WebMvcRegistrationsAdapter</code> instance to provide such components.</p>\n\n<p>If you want to take complete control of Spring MVC, you can add your own <code class=\"literal\">@Configuration</code> annotated with <code class=\"literal\">@EnableWebMvc</code></p>\n</blockquote>\n\n<p>All <code class=\"literal\">@JsonComponent</code> beans in the <code class=\"literal\">ApplicationContext</code> are automatically registered with Jackson. Spring Boot also provides convenient classes like <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html\" target=\"_top\"><code class=\"literal\">JsonObjectSerializer</code></a> and <a class=\"link\" href=\"https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html\" target=\"_top\"><code class=\"literal\">JsonObjectDeserializer</code></a></p>\n\n<p><strong>Serving Static Content With Spring Boot</strong></p>\n\n<p>Just tell Spring where static files are located.</p>\n\n<pre class=\"programlisting\">\n<span class=\"hl-attribute\" xmlns:d=\"http://docbook.org/ns/docbook\">spring.mvc.static-path-pattern</span>=/resources/**</pre>\n\n<p><code class=\"literal\">and/or spring.resources.static-locations=....</code></p>\n\n<p>Need More Info on this? <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html\" target=\"_blank\">See the doc</a>.</p>\n\n<p>&nbsp;</p>\n\n<h2>Working With Databases</h2>\n\n<p>You have different options on how to work with databases in Spring Boot application.</p>\n\n<ul>\n\t<li>You can use JDBC (Spring provides JDBC template to make this easy for you)</li>\n\t<li>You can use ORM frameworks like Hibernate</li>\n\t<li>You can make this even easier using Spring Data</li>\n\t<li>Spring Boot also provides easy setup for in-memory DB to kickstart development quickly.</li>\n</ul>\n\n<p>In any case you need to configure a&nbsp;<code class=\"literal\">javax.sql.DataSource</code> , rather a pooling data source.</p>\n\n<p>Production database connections can also be auto-configured by using a pooling <code class=\"literal\">DataSource</code>. Spring Boot uses the following algorithm for choosing a specific implementation:</p>\n\n<div class=\"orderedlist\">\n<ol class=\"orderedlist\" type=\"1\">\n\t<li class=\"listitem\">We prefer <a class=\"link\" href=\"https://github.com/brettwooldridge/HikariCP\" target=\"_top\">HikariCP</a> for its performance and concurrency. If HikariCP is available, we always choose it.</li>\n\t<li class=\"listitem\">Otherwise, if the Tomcat pooling <code class=\"literal\">DataSource</code> is available, we use it.</li>\n\t<li class=\"listitem\">If neither HikariCP nor the Tomcat pooling datasource are available and if <a class=\"link\" href=\"https://commons.apache.org/proper/commons-dbcp/\" target=\"_top\">Commons DBCP2</a> is available, we use it.</li>\n</ol>\n</div>\n\n<p>If you use the <code class=\"literal\">spring-boot-starter-jdbc</code> or <code class=\"literal\">spring-boot-starter-data-jpa</code> &ldquo;starters&rdquo;, you automatically get a dependency to <code class=\"literal\">HikariCP</code>.</p>\n\n<p>Additional connection pools can always be configured manually. If you define your own <code class=\"literal\">DataSource</code> bean, auto-configuration does not occur.</p>\n\n<p>You should at least specify the URL by setting the <code class=\"literal\">spring.datasource.url</code> property. Otherwise, Spring Boot tries to auto-configure an embedded database.</p>\n\n<p>You often do not need to specify the <code class=\"literal\">driver-class-name</code>, since Spring Boot can deduce it for most databases from the <code class=\"literal\">url</code>.</p>\n\n<p><strong>Important:</strong></p>\n\n<p>If you are running a web application, Spring Boot by default registers <a class=\"link\" href=\"https://docs.spring.io/spring/docs/5.1.9.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html\" target=\"_top\"><code class=\"literal\">OpenEntityManagerInViewInterceptor</code></a> to apply the &ldquo;Open EntityManager in View&rdquo; pattern, to allow for lazy loading in web views. If you do not want this behavior, you should set <code class=\"literal\">spring.jpa.open-in-view</code> to <code class=\"literal\">false</code> in your <code class=\"literal\">application.properties</code>.</p>\n\n<p>It provides easy setup for jOOQ.</p>\n\n<p>Spring Boot also provides easy integration with NoSQL products like Redis, MongoDB, Neo4J, Cassandra, ElasticSearch. <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-nosql.html\" target=\"_blank\">See the doc</a>.</p>\n\n<p>With Spring Boot you can easy mark any computation as <code>@Cacheable</code>, and you can configure which caching solution to use e.g. JCache, EhCache, Hazelcast, Infinispan, Couchbase, Redis, Caffeine etc. <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html\" target=\"_blank\">See Documentation</a>.</p>\n\n<p>&nbsp;</p>\n</div>\n","authorId":null,"subject":"linked-to-136","tags":null,"img":null,"summary":null,"lastUpdated":"2018-09-30T17:21:17.922+0000"}