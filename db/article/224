{"name":"Debates in Software Engineering","id":224,"content":"<p>We will explore some debates in Software Engineering community.</p>\n\n<p>Note: This is a work in progress, ... and will always remain so!</p>\n\n<h2>TDD: To Do Or Not To Do?</h2>\n\n<hr />\n<p>Arguments against TDD (<a href=\"https://en.wikipedia.org/wiki/Test-driven_development\" target=\"_blank\">Test Driven Development</a>):</p>\n\n<blockquote>\n<p>XYZ didn&#39;t use TDD (and yet they created awesome products)</p>\n</blockquote>\n\n<p>Are you XYZ? Do you consider yourself equal to XYZ in all the critical dimensions? Did XYZ work on a similar type of product, in similar set of contstraints, in a similar period of time?</p>\n\n<p>There have been people who have built amazing things with minimal equipments and tools.&nbsp;What does it prove? - Nothing. If you can gain some help from tools, you should use it. There&#39;s no denying that tool has to be mastered as well before you get the best out of it, but that kind of tradeoff is everywhere.</p>\n\n<p>If you think already that something will not&nbsp;work, probably it won&#39;t -&nbsp;that&#39;s a general principle in life.</p>\n\n<p>Now let&#39;s talk in terms of data.</p>\n\n<blockquote>\n<p>We don&#39;t have statistical evidence that TDD reduces the number of bugs while developing software.</p>\n</blockquote>\n\n<p>The problem with Software Engineering industry is that, we don&#39;t have much data regarding anything. Do we have statistical evidence that Static Typing causes fewer bugs than Dynamic Typing. Do we have statistical evidence that OOP makes software more efficient?</p>\n\n<p>- Not really. All we have are examples, that how dynamic typing caused problems and how static typing could have saved in the given situation. Other things we have is case studies, controlled experiments. Are you sure that with more care you would not have achieved same success with Dynamic Typing as with Static typing? - Maybe you could, or maybe not. Maybe you would not have achieved that level of care and attention.</p>\n\n<blockquote>\n<p>Most Software bugs are at interaction level</p>\n</blockquote>\n\n<p>Yes. But that does not make TDD ineffective.</p>\n\n<blockquote>\n<p>Tests are yet another liability</p>\n</blockquote>\n\n<p><em><strong>You don&#39;t like system? Try Chaos</strong>. </em>Every correctness check adds overhead - even a single null-check. TDD may make development slower (sometimes by 25%), but if you see the drop in the number of bugs in production (sometimes by 60%) your overall cost is lower than when you are not using TDD.</p>\n\n<blockquote>\n<p>We have better alternatives to TDD like Design By Contract</p>\n</blockquote>\n\n<p>Design By Contract means you have precondition and poscondition checks for each state transition.</p>\n\n<p>Why not use them in combination with TDD. Moreover you can mimic Design By Contract with TDD.</p>\n\n<blockquote>\n<p>Haskell has property based testing. It throws tons of tests at your code, well more than you&rsquo;ll ever think of.</p>\n</blockquote>\n\n<p>Each language has its pros and cons. One tool doesn&#39;t fit all scenarios. Moreover there are libraries to implement Property-Based-Testing (a.k.a. Generative Testing) <em>[which basically means testing on all possible types of values for each property]</em> in other languages and can be used along with TDD. E.g. for java <a href=\"https://github.com/pholser/junit-quickcheck\" target=\"_blank\">JUnit-Quickcheck</a>, for Python <a href=\"http://hypothesis.works/\" target=\"_blank\">Hypothesis</a>&nbsp;</p>\n\n<blockquote>\n<p>If TDD was silver bullet, organizations would not have QA departments.</p>\n</blockquote>\n\n<p>TDD is not silver bullet. But then nothing is silver bullet. TDD is for developers, to help them write better code. QA would still be needed for more extensive, system level, integration level testing. <em>A person can behave bad even if all the body parts are working fine, so can systems.</em></p>\n\n<p>Reference: <a href=\"https://www.hillelwayne.com/post/why-tdd-isnt-crap/\" target=\"_blank\">https://www.hillelwayne.com/post/why-tdd-isnt-crap/</a></p>\n\n<h2>Formal Specification Of The Systems: To Do Or Not To Do?</h2>\n\n<hr />\n<p>Formal Specification methods include using tools like <a href=\"https://lamport.azurewebsites.net/tla/tla.html\" target=\"_blank\">TLA+</a> (which represents your system&#39;s abstract design as a state machine).</p>\n\n<p>How do you create a system?</p>\n\n<ul>\n\t<li>First you need requirements (what do you want?)</li>\n\t<li>Have an abstract idea about how would you meet such requirements; you start with something simple</li>\n\t<li>Refine that idea/design</li>\n\t<li>Create a proper view of how would the system look like, how would it behave</li>\n\t<li>Prove that it does what it must do</li>\n\t<li>Find what it may do; And prevent bad things from happening.</li>\n</ul>\n\n<p><strong>How would you depict a mental picture of what a system would look like?</strong></p>\n\n<p>There are graphical methods of doing that, mathematical methods of doing that. Flowcharts, Sequence Diagrams, UML Diagrams etc are concrete examples.</p>\n\n<p>For example, you can use <a href=\"https://mermaidjs.github.io\" target=\"_blank\">Mermaid</a> to depict the system, interactions of components, etc in graphical way.</p>\n\n<p>For depicting your system in a mathematical way, you can use TLA+.</p>\n\n<p>But, why mathematical way?&nbsp;</p>\n\n<p>Using mathematical depiction, you can use tools to validate your design specification, you can find bugs at design level. This is very useful in case of the complex systems.</p>\n\n<p><strong>Are Formal Specifications necessary?</strong></p>\n\n<p>Of course not. Ultimatimately only one thing is necessary &quot;working code&quot;. But to get that working code we have to do a lot of things. Formal Specification is one of those things which can give you confidence in your design, can help you refine the design, find bugs at design level even before implementing the system.</p>\n\n<p>&nbsp;</p>\n\n<h2>Are Tools The Answer?</h2>\n\n<hr />\n<p>Is anything <em>the</em> answer in life? - No.</p>\n\n<p>People have used different ways of living to live a fullfilling and successful life. Similarly, in Software Engineering, people have had failures with many methodologies, and had success too in creating systems.</p>\n\n<p>The point is we have tools, techniques, methodolgies, processes available. We have historical record, data regarding their usage. You can use statistics, philosophy, intuition to decide what suits for your specific team and for specific project. <strong>The thing is that you identify pain points while creating system and try to resolve them as soon as possible.&nbsp;</strong>Otherwise, you will just grow a cancer which will cause suffering later on.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>Micro-Service: To Do Or Not To Do?</h2>\n\n<hr />\n<blockquote>\n<p>You can do just fine with monoliths along with properly defined modules.</p>\n</blockquote>\n\n<p>Probably you can, but when the system grows and becomes complex, isolating problems in monolith will become harder, and putting fixes for them even more difficult and time-consuming. And, it&#39;s not just about the technical challenges, the complexities that arise in co-ordination among the members working on the project also becomes strenuous.</p>\n\n<p>It&#39;s true that a microservice can be viewed as a module. The difference then is that, each module can be in different technology. There is only one way to talk to other modules, while in monolith you have to be very careful to make it happen and not create coupling. If one microservice directly calls another microservice, that&#39;s also an example of coupling. But microservices architecture comes with some patterns to follow <em>(along with their challenges)</em> which reduce coupling.</p>\n\n<p>&nbsp;</p>\n\n<h2>Pair Programming</h2>\n\n<hr />\n<p>Quasi-experimental studies suggest positive impact on Job Satisfaction, Team performance.</p>\n\n<ul>\n\t<li data-selectable-paragraph=\"\" id=\"e7bb\"><a href=\"https://collaboration.csc.ncsu.edu/laurie/Papers/ieeeSoftware.PDF\" rel=\"noopener nofollow\" target=\"_blank\">&ldquo;Strengthening the Case for Pair Programming&rdquo;, Jeffries et al</a></li>\n\t<li data-selectable-paragraph=\"\" id=\"3752\"><a href=\"https://collaboration.csc.ncsu.edu/laurie/Papers/Succi-Pedrycz--PreliminaryAnalysisoftheEffectsofPairProgramming.pdf\" rel=\"noopener nofollow\" target=\"_blank\">&ldquo;Preliminary Analysis of the Effects of Pair Programming on Job Satisfaction&rdquo;, Williams et al, 2002</a></li>\n\t<li data-selectable-paragraph=\"\" id=\"1fcc\"><a href=\"https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF\" rel=\"noopener nofollow\" target=\"_blank\">&ldquo;The Costs and Benefits of Pair Programming&rdquo;, Cockburn and Williams, 2001</a></li>\n\t<li data-selectable-paragraph=\"\" id=\"07fe\"><a href=\"https://collaboration.csc.ncsu.edu/laurie/Papers/Kindergarten.PDF\" rel=\"noopener nofollow\" target=\"_blank\">&ldquo;All I Really Need to Know about Pair Programming I Learned In Kindergarten&rdquo;, Williams and Kessler, 2000</a></li>\n</ul>\n\n<p>Should the expert teach?&nbsp;</p>\n\n<p>Should the expert be open to be observed, implicitly or explicitly? E.g. when the lead developer deliberately discusses the design in open, so that novices can hear. <strong><em>Learning By Observing</em></strong>.</p>\n\n<p>How much communication should there be when there is expertise-gap?</p>\n\n<p><strong>What are the hurdles?</strong></p>\n\n<p><em>Managerial View:</em>&nbsp;One task, two resources!! Waste!</p>\n\n<p><em>Personal Preferences:</em>&nbsp;Not willing to communicate, not able to communicate, inertia of solitary way of working, Friction in co-ordination with the pair.</p>\n\n<p>But once these hurdles are crossed, pair programming results in faster delivery, better design and better code, more job satisfaction.</p>\n\n<p>Principles of Pair Programming:</p>\n\n<ul>\n\t<li>At any given time, one person working and&nbsp;the other one is reviewing, thinking on varying levels of context. This goes in turns.</li>\n\t<li>Good or bad, everything owned by pair not any individual.&nbsp;</li>\n\t<li>Inferiority Complex, Superiority Complex should be thrown out of the window.</li>\n\t<li>Discuss things <em>without ego, </em>in purely constructive form.</li>\n\t<li>Believe that pair programming will work for you.</li>\n\t<li>Take breaks from the activity and from the pairing process itself.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h2>Null as a Design Choice</h2>\n\n<hr />\n<p>References: <a href=\"https://dzone.com/articles/the-worst-mistake-of-computer-science-1\">Null The Worst Mistake</a>, <a href=\"https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5\">Null Is Your Friend Not A Mistake</a></p>\n\n<p><strong><em>Is it mistake of the design, or is it the mistake of the use?</em></strong></p>\n\n<p>You can always write good code, considering the scenarios where null actually makes sense, and where it&nbsp; needs to be handled.</p>\n\n<p>But, the point is that we are humans and humans are bound to make mistakes. So, the trade-off is to be decided between the cost of the mistakes, and the cost of the fixing/avoiding such mistakes. The cost of null-related mistakes is historically recorded, in billions.</p>\n\n<p><a href=\"https://stackoverflow.com/questions/3989264/best-explanation-for-languages-without-null\">And, also the point is that an alternative - without null - is possible.&nbsp;</a></p>\n\n<p>&nbsp;</p>\n\n<p><em>In Java, all object references are initialize to NULL unless you explicitly assign them to a valid object. This is nice.</em></p>\n\n<p>You will always be testing for the knowns, so if lets suppose that someone initialised their strings to &quot;&quot;, leading to an error. That error will most certainly be captured during testing, because most certainly it would be covered in your positive cases. While on the other hand, you can&#39;t test for all the unknowns, so it is much more difficult to find out errors caused by nulls.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>What&#39;s the problem with null/None/Nil etc?</strong></p>\n\n<ol>\n\t<li>Increases efforts: for manually handling nulls, <em>otherwise increases chances of bugs.</em></li>\n\t<li>Semantically, it is&nbsp;ambiguous. <em>Null tells us that currently we don&#39;t have its value, <strong>but it does not tell whether it is allowed to not have a value or not</strong>.&nbsp;</em>One can argue that it&#39;s not big a deal, but in combination with the first point, it kind of is a big deal.</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"architecture","tags":null,"img":null,"summary":null,"lastUpdated":"2020-11-18T10:11:33.128+0000"}