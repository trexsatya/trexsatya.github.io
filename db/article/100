{"name":"Multi-threading and Concurrency in Java","id":100,"content":"<p>3 Threads: T1, T2, T3</p>\n\n<p>Run-x-after-y scenario:</p>\n\n<p>Wait-for-x scenario:&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2><strong><span style=\"\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Synchronisation, Atomicity and Volatility</span></span></strong></h2>\n\n<p><span style=\"\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Thread-Safety is comprised of Atomicity,Visibility and Ordering.&nbsp;</span></span></p>\n\n<p>Synchronisation ensures all three.</p>\n\n<p><i>synchronization has no effect unless both read and write operations are synchronized - <strong>Effective Java &nbsp;{because, then changes will not be visible to other threads}</strong></i></p>\n\n<pre>\n<code class=\"language-java\">int i;\nsynchronized(this){i++;} //any synchronised usage\n\n//Above can also be done using this code, while being faster\nAtomicInteger i = new AtomicInteger();\ni.getAndIncrement();\n\n//Above is faster because it uses native Optmistic Locking using CAS operations\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Volatility ensures only visibility; and should be considered thread safe only if atomicity is guaranteed somehow.</p>\n\n<p>If order is important and updation (writing) is done by more than one threads, <strong>volatile</strong> is not thread safe.</p>\n\n<p>AtomicReference is identical to volatile reference. But AtomicReference provides CAS operation for Test-Then-Act scenarios for reference hence providing Atomicity without need for Synchronisation.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Run-X-Y-Alternatively</span></span></h2>\n\n<pre>\n<code class=\"language-java\">Thread T1 = new Thread(){\n        int count = 1;\n        String name = \"1\";\n        @Override\n        public void run() {\n            while (count++ &lt; 50) {\n                waitForTurn(1);\n                println(name);\n                changeCounterAndTellEveryoneWaiting(() -&gt; threadWhichShouldRun = 2);\n            }\n        }\n};\n//Similarly other threads\n\nprivate void waitForTurn(int turn){\n        try {\n            synchronized (this) {\n                while (threadWhichShouldRun != turn) wait();\n                // if (threadWhichShouldRun != turn) wait(); will be wrong here.\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n}\n\nprivate void changeCounterAndTellEveryoneWaiting(Runnable o) {\n        synchronized (this) {\n            o.run();\n            notifyAll();\n        }\n}\n</code></pre>\n\n<h2><strong><span style=\"font-family:Comic Sans MS,cursive;\">Ways to create threads, or ways to do something in different threads</span></strong></h2>\n\n<p><span style=\"font-family:Comic Sans MS,cursive;\">Using Runnable implies Composition, extending Thread class implies Inheritance. Favor Composition over Inheritance.</span></p>\n\n<p><span style=\"font-family:Comic Sans MS,cursive;\">Extend Thread class, or implement Runnable interface and call start() method of Thread class.</span></p>\n\n<p><span style=\"font-family:Comic Sans MS,cursive;\">Use some thread-pool (Executor framework in Java provides that) and just submit the tasks as a Callable object.</span></p>\n\n<p><span style=\"font-family:Comic Sans MS,cursive;\">Use fork-join framework. Use Actor models like Akka.</span></p>\n\n<h2><strong><span style=\"color:#8e44ad;\"><span style=\"font-family:Comic Sans MS,cursive;\">Wait, sleep, yield and join</span></span></strong></h2>\n\n<p><font face=\"Comic Sans MS, cursive\">Wait releases the lock, thread may wake even before time specified to wait(..), sleep guarantees that thread goes to waiting/sleeping state for at least the time specified. The purpose of wait is to make inter-thread communication happen, while the purpose of sleep is to temporarily stop execution.</font></p>\n\n<p><font face=\"Comic Sans MS, cursive\">yiels sends a thread from Running state to Runnable state, so some other thread might get the chance to run.</font></p>\n\n<p><font face=\"Comic Sans MS, cursive\">join() method blcoks as long as the thread is running.</font></p>\n\n<h2><strong><span style=\"color:#8e44ad;\"><span style=\"font-family:Georgia,serif;\">How can we kill a thread</span></span></strong></h2>\n\n<p>There is no direct way to kill a thread. You can interrupt a thread. Implementation may choose to exit from run() method on seeing the interruption. Inside run method there are two ways to know about interruption.</p>\n\n<p>Either catch the InterruptedException if it is thrown from some method you have called. Or,&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">while(! Thread.interrupted()){\n  //Do your work\n}\n\n//Or\nif(Thread.interrupted()){\n //return\n //throw new InterruptedException(); //this will clear the interrupt-status-flag\n}</code></pre>\n\n<p>Daemon threads are killed automatically when there is no non-daemon thread active and then JVM exits. JVM does not wait for daemon threads to exit run() method.</p>\n\n<h2><strong><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">When should you use Thread-Locals</span></span></strong></h2>\n\n<p>When storing a new object is chaper than cost of synchronizing</p>\n\n<p>Also, when you need some contextual information that should be available across many method calls e.g. Transaction object in Spring, FacesContext in JSF.</p>\n\n<h2><strong><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">What is Java Memory Model</span></span></strong></h2>\n\n<p>Java memory model specifies how memory is used in context of threads.&nbsp;</p>\n\n<p>Thread stack &rarr; stores the local variables (primitives and references, actual objects are stored on Heap though ). Local variables of methods of objects called by thread are also on thread stack, though the object itself is on Heap.<br />\nStatic class variables, class definition are also stored on Heaps.<br />\nProgram order ( order in which statements are written) and execution order (in which loads and writes are performed to Main Memory) may differ, due to caches and when they are evicted.<br />\nTwo concerns regarding Java MM and Hardware MM:<br />\nVisibility of thread updates to shared variables.<br />\nRace conditions when reading, checking and writing shared variables<br />\n&nbsp;</p>\n\n<h2><strong><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Deadlock, Livelock&nbsp;</span></span></strong></h2>\n\n<p><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Prevention strategies: Lock ordering (if all locks are known ahead of time), lock timeouts, Deadlock detection.<br />\nFor deadlock detection use some Data structure to record locks requests and lock holds, and if deadlock is detected backoff some threads based on some priority randomly assigned to threads.</span><br />\n&nbsp;</p>\n\n<h2><meta charset=\"utf-8\" /><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\"><b id=\"docs-internal-guid-2c8af5b1-e070-1b47-7bb8-e9dba41340df\">Why use Lock instead of synchronized blocks</b></span></span></h2>\n\n<p>To achieve fairness.<br />\nReentrantLock &rarr; takes a fairness parameter at construction.However, Fairness does not guarantee fair thread scheduling,only fair lock acquisition.<br />\n&nbsp;</p>\n\n<h2><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\"><strong>What makes ConcurrentHashMap give better performance than a synchronizedMap</strong></span></span></h2>\n\n<p>CHM is high-performant in high-read-low-write scenarios. It also does not throw ConcurrentModificationException but only at cost of possibility of weak-consistence</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"utf-8\" /></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">Get is a two step process : search without locking, search with locking (if not returned ).</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">Removing is a two step process:</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">First the entry is found and it&rsquo;s value is set to null (this is used in get() in first step to check if entry might have been removed)</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">Second, rebuild the list without this entry. Nodes preceding the one being deleted need to be cloned.</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">Is CHM consistent ?</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">CHM retrieval is consistent, but iteration is weakly consistent.</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e077-42f7-cbe3-ff3a431cec38\">CHM iterations may or may not reflect insertions during iteration, but they guarantee the updates or removal of keys that have yet not been reached by iterator.</b></p>\n\n<p dir=\"ltr\">&nbsp;</p>\n\n<h2 dir=\"ltr\"><span style=\"color:#8e44ad;\"><strong><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Atomic constructs in concurrent package and Non-Blocking Algorithms</span></strong></span></h2>\n\n<p dir=\"ltr\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Wait-free: every thread will continue to make progress in case of delay or even failure of other threads.<br />\nlock-free : some thread always makes progress, implies no deadlock, less contention time, higher parallelism.<br />\nAtomicInteger, AtomicLong and AtomicReference provide such functionality, to be used in non-blocking algos.<br />\nAtomicReferenceArray can be used as a lock-free single consumer / multiple producer ring buffer.<br />\n&nbsp;<br />\nABA problem : is possible even with Atomics.<br />\nIt was A when compared, then changed to B and hence might have affected some state, then just before CAS operation, it was back to A.<br />\nTo avoid this use AtomicStampedReference.</span><br />\n&nbsp;</p>\n\n<h2 dir=\"ltr\"><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\"><strong>Concurrent Collections And Synchronizers</strong></span></span></h2>\n\n<p dir=\"ltr\">ConcurrentSkipListMap -&gt; guarantees logN performance for most operations. But does not support tuning for concurrency sake (e.g. load-Factor, concurrency-Level) etc. It maintains a sort order which is very expensive to compute with CHM.<br />\nCHM does not guarantee performance but most close to O(1) mostly ignoring rehashing.<br />\n&nbsp;<br />\nSynchronizers:<br />\nFutureTask &rarr; while(! future.isDone())...isCancelled() get() cancel()<br />\nSemaphores &rarr; Use when one thread acquires lock and different thread releases.&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;acquire(n) call blocks until the number of permits mentioned are available.<br />\nSemaphore with timeouts may be simulated with BlockingQueue&lt;Integer&gt;&nbsp;<br />\nCountDownLatch &rarr;&nbsp;<br />\nCyclicBarrier &rarr;&nbsp;<br />\nExchanger &rarr;&nbsp;<br />\nReentrantLock &rarr; lockInterruptibly() tries to acquire lock, it responds to interrupts quickly.<br />\n&nbsp;&nbsp; &nbsp;Any thread can interrupt. While trying to acquire lock, preference is given to interrupt over acquisition.<br />\n&nbsp;</p>\n\n<p dir=\"ltr\"><meta charset=\"utf-8\" /></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-2c8af5b1-e07e-92a0-9ffd-4ab20112fc02\">ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, ConcurrentLinkedQueue, LinkedList, PriorityQueue,</b></p>\n\n<p dir=\"ltr\">DelayQueue : unbounded blocking queue of &lt;&lt;Delayed&gt;&gt; elements, elements can be take() &nbsp;and &nbsp;poll() returns least recent expired element.<br />\ntake() blocks, poll() returns null.<br />\nLinkedBlockingQueue : optionally bounded.<br />\nArrayBlockingQueue : bounded buffer, fairness enforced (first come first serve while blocked) and hence slower.<br />\nConcurrentLinkedQueue : returns right away if queue is empty. It is lock-free implementation.<br />\n&nbsp; &nbsp; &nbsp; Usable in N-Producer-1-Consumer<br />\nLinkedBlockingQueue : blocks until there is an element.<br />\n&nbsp; &nbsp; &nbsp;Suits in 1-Producer-N-Consumer<br />\nHow does linked blocking queue function:<br />\nputLock and takeLock locks,<br />\nnotEmpty (takeLock.newCondition()) and notFull conditions<br />\nPut signals one taker; that taker in turn signals others if more items have been added since signal. Symmetrically for takes signalling puts.<br />\nVisibility between readers and writers &nbsp;&rarr; &nbsp;putLock acquired, subsequent readers either use fully lock or takeLock and then read counter.get() counter is AtomicInteger, this gives visibility to first n items.<br />\nremove(), clear() acquire full lock.<br />\nIterator is weakly consistent.<br />\n&nbsp;<br />\nput() throws InterruptedException , blocks.<br />\noffer() does not block.<br />\nBoth are to add to tail of queue.<br />\noffer(time,unit) throws IE blocks for specified time.<br />\nSymmetrically for take() , poll() and poll(time,unit).<br />\n&nbsp;<br />\nCopyOnWriteArrayList: fully locks in case of add(), remove(), addIfAbsent(), clear(), addAllAbsent(),&nbsp;<br />\nIterator(), contains() work on snapshot.<br />\nEach mutation creates a new array and replaces the old one.<br />\n&nbsp;<br />\nWhy null values not allowed in concurrent hash map?<br />\nIf map.get(k) returns null, do you know whether the value was actually null or the key does not exist? No. In hash map you could check this situation using containsKey(), but in CHM the map may have been modified in between calls.<br />\n&nbsp;<br />\nSafe update to CHM&rsquo;s value:<br />\nConcurrentHashMap&lt;String,AtomicReference&lt;BigDecimal&gt;&gt; map;&nbsp;<br />\npublic void addToSum(String account, BigDecimal amount) { AtomicReference&lt;BigDecimal&gt; newSum = map.get(account);&nbsp;<br />\nfor (;;) { BigDecimal oldVal = newSum.get();&nbsp;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (newSum.compareAndSet(oldVal, oldVal.add(amount)))&nbsp;<br />\nreturn; } }<br />\nOR synchronized update.<br />\n&nbsp;<br />\nConcurrentModificationException :<br />\nThings to notice :&nbsp;<br />\nCan iterator.remove() throw CME ?<br />\nNo.<br />\nCan list.remove() throw CME ?<br />\nYes and sometimes No.<br />\n&nbsp; public static void remove(Integer toRemove) {<br />\n&nbsp; &nbsp; &nbsp; &nbsp; for(Integer currentItem : integerList)&nbsp;<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(currentItem.equals(toRemove)) &nbsp;integerList.remove(currentItem);<br />\n&nbsp; &nbsp;}<br />\n&nbsp;<br />\n&nbsp; &nbsp; public static void main(String... args) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />\n&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;integerList = new ArrayList&lt;&gt;(Arrays.asList(1,2,3));<br />\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(Integer.valueOf(2)); // No exception<br />\n&nbsp; &nbsp; }<br />\ncheckForComodification() called in next(), and next() is called only after hasNext() -&gt; cursor != size. In above case it returns false after removing an element and hence no exception.<br />\n&nbsp;<br />\n&nbsp;<br />\nThrottle execution of some method to max M calls in N seconds.<br />\nInitialize DelayQueue with M delayed instances with their delay initially set to 0.<br />\nAs requests to method come in , take a token, which causes method to block until throttling requirement has been met, when a token has been taken, add a new token to queue with delay N.<br />\nDelayQueue can be used to handle throttling and short term bursts.<br />\n&nbsp;<br />\nConcurrent Set: Collections.newSetFromMap( a-Concurrent-Hash-Map-Instance );<br />\nSetting a value in multithreaded environment:<br />\nAtomicReference&lt;T&gt; value;<br />\n&nbsp;do {&nbsp;<br />\n&nbsp; &nbsp; &nbsp; &nbsp;old = value.get(); &nbsp;new = createImmutable(old);<br />\n&nbsp; } while ( ! value.compareAndSet(old, new);<br />\n&nbsp;</p>\n","authorId":null,"subject":"notes","tags":null,"img":null,"summary":null,"lastUpdated":null}