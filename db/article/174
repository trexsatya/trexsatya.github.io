{"name": "REST and SOAP", "id": 174, "content": "<p><strong>Web Services</strong>: In simple sentences, web service is a way of exposing your API to the clients on the internet (or intranet).&nbsp;Web Services could be implemented based on REST architecture. Web services could also be in other forms e.g. SOAP. <strong>Web resources</strong> (basically everything on the internet small or large) are dealt with using uniform identifiers called URI (<strong>Uniform Resource Identifiers</strong>, these are like PAN cards numbers or social security numbers).</p>\n\n<p><b>REpresentational State Transfer</b>&nbsp;(<b>REST</b>) is an architectural style; based on HTTP (almost always). And the best thing about it is that it is a&nbsp;<strong>standard</strong>.</p>\n\n<p>There are predefined ways (operations) to interact using these URIs in REST architecture. In case when HTTP is used for transport, standard HTTP methods like GET, POST, DELETE, PUT mean something specific. The term&nbsp;<strong><i>representational state transfer</i></strong>&nbsp;as presented in original paper, has special meaning. It wants you to see web as a <strong>virtual state machine </strong>(see the image below). Where the end-user will interact with the web resource and the next resource (or say next state of the application) will be transferred to the user.</p>\n\n<div class=\"collapsable\">\n<p>A little more detail on this: Suppose the application is about user management. The end-user first requests its details using GET operation <u>GET /user/1</u>; this results in a response which tells contains the user details and other links (URIs) which can be used to get to next state. The response could be in any format like JSON, XML etc. Then end-user could make some changes to user details and use PUT operation <u>PUT /user/1 {user details}</u>&nbsp;.&nbsp;</p>\n\n<p><img alt=\"REST-State-Machine\" src=\"/images/RestStateMachine.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>Why would you create Web-Service instead of just creating a JAR and supplying it to whoever is interested in using it?</strong></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">&nbsp; &nbsp; Why Web-Service?&nbsp;<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Flexibility of technology, infrastructure e.g for scaling multiple instance.<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Faster deployment (clients (projects which use API) just have to change version at most).<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />\n&nbsp;&nbsp; &nbsp;Why not Web-Service?<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Add latency (libraries do not).<br />\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- Clients now&nbsp;depend on availability of API Web Service (libraries do not).</div>\n\n<p>&nbsp;</p>\n\n<p>(<a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\">From Wikipedia</a>) In a retrospective look at the development of REST, Fielding said:</p>\n\n<blockquote>\n<p><span style=\"font-family:Verdana,Geneva,sans-serif;\">Throughout the HTTP standardization process, I was called on to defend the design choices of the Web. That is an extremely difficult thing to do within a process that accepts proposals from anyone on a topic that was rapidly becoming the center of an entire industry. I had comments from well over 500 developers, many of whom were distinguished engineers with decades of experience, and I had to explain everything from the most abstract notions of Web interaction to the finest details of HTTP syntax. That process honed my model down to a core set of principles, properties, and constraints that are now called REST.</span></p>\n</blockquote>\n\n<p>This suggests that REST is just&nbsp; a set of HTTP properties and constraints.</p>\n\n<p>REST Architecture: This is architecture which views everything as resources. Each of your business data (business data meaning anything in which your clients are interested in). Authentication is a resource. Users are resources, roles assigned to the users are resources, and so on.</p>\n\n<p>Using a proper, pre-defined template for the URLs which the clients should use to access resources makes it standard, which is not only intuitive, clear, but can also be used in developing tools which can make use of such standards e.g. for code generation.</p>\n\n<p>REST makes use of standard template for API&nbsp;URLs, HTTP Verbs, HTTP Headers.</p>\n\n<p>&nbsp;</p>\n</div>\n\n<h2>The formal REST constraints without which System cannot be RESTful</h2>\n\n<p><strong>Client-server architecture:</strong>&nbsp;Separating the user interface concerns from the data storage concerns</p>\n\n<p><strong>Statelessness:</strong> NO&nbsp;client context being stored on the server between requests (this request cannot know about previous one);&nbsp;session state is held in the client;&nbsp;</p>\n\n<p><strong>Cacheability:</strong>&nbsp;Responses must&nbsp;implicitly or explicitly, define themselves as cacheable or not to prevent clients from reusing stale or inappropriate data in response to further requests.&nbsp;</p>\n\n<p><strong>Layered system:</strong>&nbsp;A client cannot (should not be able to) ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. This allows for load-balancing, scalability, proxies.</p>\n\n<p><strong>Code on demand (optional):</strong>&nbsp;Servers can temporarily extend or customize the functionality of a client by transferring executable code. Examples of this may include compiled components such as&nbsp;<a href=\"https://en.wikipedia.org/wiki/Java_applet\" title=\"Java applet\">Java applets</a>&nbsp;and client-side scripts such as&nbsp;<a href=\"https://en.wikipedia.org/wiki/JavaScript\" title=\"JavaScript\">JavaScript</a>.</p>\n\n<p>Uniform interface:&nbsp;</p>\n\n<ul>\n\t<li>Resource identification (<strong>URI</strong>) in requests.</li>\n\t<li><span>Resource manipulation through representations .</span></li>\n\t<li><span>Self-descriptive messages (e.g. MIME type to tell which parser should be used by client to decipher this message).</span></li>\n\t<li><span>Hypermedia As The Engine Of Application State (<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" title=\"HATEOAS\">HATEOAS</a>). Responses containing server-provided links that end-user can use <strong>dynamically</strong> to <strong>discover all the available actions and resources</strong> it needs</span></li>\n</ul>\n\n<p><span>Following is a table that shows the <strong>standard URI Formats</strong>.</span></p>\n\n<div>\n<style type=\"text/css\">td{ padding-top: 5px; padding-bottom: 5px; padding-left: 3px; padding-right: 3px; text-align: center;     color: blue;\n    font-size: small; }\n</style>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:100%;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td>\n\t\t\t<p>Collection</p>\n\n\t\t\t<p>e.g. /api.example.com/resources/</p>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<p>Item</p>\n\n\t\t\t<p>e.g. /api.exaple.com/resources/item1</p>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>GET</strong></td>\n\t\t\t<td><b>Lists</b>&nbsp;the URIs and perhaps other details of collection members.</td>\n\t\t\t<td><b>Retrieve</b>&nbsp;a representation of an addressed member of collection, expressed by any MIME type.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>PUT<br />\n\t\t\t(idempotent)</strong></td>\n\t\t\t<td><b>Replace&nbsp;</b>the entire collection with another collection.</td>\n\t\t\t<td><b>Replace&nbsp;</b>the addressed member in the collection, or if it does not exist,&nbsp;<b>create</b>&nbsp;it.<br />\n\t\t\tIf a field is sent as null, it will also be updated to null on server.<br />\n\t\t\tThe client must provide ID</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>PATCH</strong></td>\n\t\t\t<td>&nbsp;Not used generally</td>\n\t\t\t<td><b>Update&nbsp;</b>the addressed member of the collection with partial details provided.<br />\n\t\t\tIt can be idempotent or non-idempotent depending upon structure of request and implementation.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>POST</strong></td>\n\t\t\t<td><b>Create</b>&nbsp;a new entry in the collection. The new entry&#39;s URI is assigned automatically is generally returned.</td>\n\t\t\t<td>Not generally used. Treat the addressed member as a collection in its own right and&nbsp;<b>create</b>&nbsp;a new entry within it.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>DELETE</strong></td>\n\t\t\t<td>Delete the entire collection.</td>\n\t\t\t<td><b>Delete&nbsp;</b>the addressed member from the collection.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#2c3e50;\"><strong><span style=\"background-color:#f1c40f;\">In short, POST &rArr; Create; PUT &rArr; Replace; PATCH &rArr;&nbsp;Update (Partially);&nbsp;</span></strong></span></p>\n</div>\n\n<p>The above is a generic view of HTTP operations.</p>\n\n<p>Following is a view from <a href=\"https://docs.spring.io/spring-data/rest/docs/current/reference/html/#repository-resources.item-resource\" target=\"_blank\">Spring Data REST</a>, which is a prominent implementation (and very easy to use) of RESTful architecture.</p>\n\n<div>\n<style type=\"text/css\">td{ padding-top: 5px; padding-bottom: 5px; padding-left: 3px; padding-right: 3px; text-align: center;    color: blue;\n    font-size: small; }\n</style>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:100%;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td>\n\t\t\t<p><strong>Collection</strong></p>\n\n\t\t\t<p>e.g. /api.example.com/resources/</p>\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t<p><strong>Item</strong></p>\n\n\t\t\t<p>e.g. /api.exaple.com/resources/item1</p>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>GET</strong></td>\n\t\t\t<td><b>Lists</b>&nbsp;the entities and links. Each entity representation also has links</td>\n\t\t\t<td><b>Retrieve</b>&nbsp;a representation of a single entity: detail and links.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>PUT</strong></td>\n\t\t\t<td><b>&nbsp;</b>N/A</td>\n\t\t\t<td><b>Replace&nbsp;</b>the entity in the collection, or if it does not exist,&nbsp;<b>create</b>&nbsp;it.</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>PATCH</strong></td>\n\t\t\t<td>&nbsp;N/A</td>\n\t\t\t<td><b>Update&nbsp;</b>the entity with partial details provided</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>POST</strong></td>\n\t\t\t<td><b>Create</b>&nbsp;a new entry in the collection. The new entry&#39;s URI is assigned automatically and is returned.</td>\n\t\t\t<td>N/A</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><strong>DELETE</strong></td>\n\t\t\t<td>N/A</td>\n\t\t\t<td><b>Delete&nbsp;</b>the entity from the collection.</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p><br />\nPUT and DELETE are idempotent operations; meaning if called twice there would be no side-effect and it will leave the system in the same state.</p>\n\n<p>Status codes:<br />\n&nbsp;</p>\n\n<ul>\n\t<li>\n\t<p><code>200 OK</code>&nbsp;- for plain&nbsp;<code>GET</code>&nbsp;requests.</p>\n\t</li>\n\t<li>\n\t<p><code>201 Created</code>&nbsp;- for&nbsp;<code>POST</code>&nbsp;and&nbsp;<code>PUT</code>&nbsp;requests that create new resources. Along with location header</p>\n\t</li>\n\t<li>\n\t<p><code>204 No Content</code>&nbsp;- for&nbsp;<code>PUT</code>,&nbsp;<code>PATCH</code>, and&nbsp;<code>DELETE</code>&nbsp;requests if the configuration is set to not return response bodies for resource updates (<code>RepositoryRestConfiguration.returnBodyOnUpdate</code>). If the configuration value is set to include responses for&nbsp;<code>PUT</code>,&nbsp;<code>200 OK</code>&nbsp;will be returned for updates,&nbsp;<code>201 Created</code>&nbsp;will be returned for resource created through&nbsp;<code>PUT</code>.</p>\n\t</li>\n</ul>\n</div>\n\n<p><br />\n<strong>Why PUT instead of POST?</strong><br />\n<br />\nBoth PUT and POST can be used to create, update resources. But PUT is generally preferred to update a resource (especially replace the whole resource with new content). Why?</p>\n\n<p><a href=\"https://stackoverflow.com/questions/630453/put-vs-post-in-rest/630475\" target=\"_blank\">https://stackoverflow.com/questions/630453/put-vs-post-in-rest/630475</a></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">PUT is <strong><em>idempotent</em></strong>. Browser somehow (maybe because connection dropped in between) sends the same request again, it doesn&#39;t behave in unwanted way, the system will be in same state if same request is called multiple times.<br />\n&nbsp; &nbsp;-&nbsp;So what? I can make POST requests idempotent too, by implementing it on server side.<br />\nYou can, but browsers do not know that. So, you miss some benefits of that. E.g. browsers won&#39;t be able to make automatic request if connection is dropped temporarily.<br />\n<br />\nPUT is <a href=\"https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-16#section-7.5\" target=\"_blank\">standard</a>.<br />\n&nbsp; - No argument against that.</div>\n\n<p><br />\n<strong>Why JSON instead of XML?</strong></p>\n\n<p><a href=\"https://stackoverflow.com/questions/4862310/json-and-xml-comparison\" target=\"_blank\"><strong>https://stackoverflow.com/questions/4862310/json-and-xml-comparison</strong></a></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">Because it&#39;s faster? - No, speed of parsing depends on the parser.&nbsp;<br />\nBecause it&#39;s less verbose? - Yes, XML is more verbose and takes more space for same info.<br />\n<br />\nStructure &amp; Schema Validation&nbsp;- JSON can also be schema-validated, however it&#39;s less standardized than XML. In XML you can create custom data types, refer them and validate it.</div>\n\n<p>&nbsp;</p>\n\n<p><strong>Would you choose REST over MQ based system?</strong></p>\n\n<p><strong><a href=\"https://stackoverflow.com/questions/2383912/message-queue-vs-web-services\" target=\"_blank\">https://stackoverflow.com/questions/2383912/message-queue-vs-web-services</a></strong></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">Why REST?<br />\n&nbsp; - Because REST is easy, client service discovery is obvious with HATEOAS.<br />\n<br />\nWhy not REST?<br />\n&nbsp; - Because you have to design and implement redelivery logic, fault tolerance etc yourself.<br />\n&nbsp; - Asynchronisity can be implmented but you have to implment it yourself. Either by using a reactive design, or treating processes as resource and exposing endpoint for them.<br />\n<br />\nWhy MQ?<br />\n&nbsp; - Because you get Fault Tolerance, Message Persistence, Guaranteed Redelivery for free (without additional development).<br />\n<br />\nWhy Not MQ?<br />\n&nbsp; - It is complex.<br />\n&nbsp; - MQs can have additional cost if your clients (consumers) are external. So just because your clients are down, you are bearing cost for the messages stored on your MQ.</div>\n\n<p>&nbsp;</p>\n\n<p><a href=\"https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13\" target=\"_blank\">https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13</a></p>\n\n<p>A good idea is to start your system with REST and move to MQ based system if complexity of the system increases.</p>\n\n<p>&nbsp;</p>\n\n<p>Some more points regarding REST specification standards:</p>\n\n<p>To Create a resource: Use <code>POST</code> Verb in the HTTP request. After processing to the request, if the resource has been created successfully, return a status code of <code>201</code>, with HTTP Header <code>Location</code> containing the URL of the newly created resource.&nbsp;</p>\n\n<p>One of the most incredible benefits of using HTTP for Web APIs is this: It has survived since the origin of web. Servers can change independently of clients, clients can changed independent of servers, they are not coupled with each other because in the end they understand each other using HTTP.</p>\n\n<p>REST APIs are concerned with resources only, however there are different views of these resources. E.g. the collection of resources of a particular type, all users for example. An individual resource, a particular user for example. Also, you might want to support querying on the resources. You might also want to provide the capability for clients to fetch resource data in different formats.</p>\n\n<p>If in contrast you use function-oriented approach of Web-Api design, you will have exmploding list of web URLs to support. There&#39;s no standard.</p>\n\n<p>You might want to inform clients about some expected behavior from them, e.g. that clients should retry a URL if needed, cache the response for performance, or be tolerable to the addition of new fields in&nbsp;a resource.&nbsp;</p>\n\n<p>APIs response for resources should contain links which are permanent e.g. URLs based on ID of the resource instead of name, so that even if the name changes the URL doesn&#39;t change. So, basically there should be a user-friendly URL, and then there should be an immutable resource URL link.</p>\n\n<p>To tell about relationships in the response, you should use relationship links instead of property because this allows for flexiblity, e.g. when giving response for a <code>Dog</code> resource, provide a link for <code>owner</code>, this way you don&#39;t have to worry when the entity of relationship changes for future requirements e.g. maybe today the owner of the dog is a person, tomorrow it be an institution, a police department for example. However, here clients must be aware of the fact that owner link may point to different resources.&nbsp;</p>\n\n<p>Don&#39;t use Verbs in URLs, use Nouns.</p>\n\n<p>Query URLs: Use path parameters instead of query parameters.E.g. <code>https://&lt;base_url&gt;/persons/{personId}/dogs</code> instead of&nbsp;<code>https://&lt;base_url&gt;/search?type=Dog&amp;owner={personId}</code>&nbsp;Reasons are: first one is more intuitive, more precise (doesn&#39;t give a sense that any combination is allowed), more readable. It also allows to represent graph (of relationships) navigation queries easily.</p>\n\n<p>Use query parameters to support filtering of the results from server.</p>\n\n<p>To create URLs for non-persistent processing e.g. calculation of some sort, treat the resulting data as resource and have a conceptual type for that result to use as resource name. E.g.&nbsp;<code>GET /monetary-amount/100/EUR/CNY</code>. Or, you can treat the algorithm as a resource e.g.&nbsp; <code>POST /currency-converter</code>. However, notice that you are using POST while not creating any resource on the server, which is against HTTP standards, also the response is not cacheable unless you write custom logic for caching.</p>\n\n<p>Why should I use Self link in response? &mdash; It allows you to derive knowledge about the resource, without having knowledge of outer context, is helpful in case of nested JSON responses.</p>\n\n<p>Why should I use <code>kind</code> property in response? &mdash; It allows you be able to add new concepts without changing API versions. Your clients should not worry as long as they are receiving a known value in <code>kind</code> property.</p>\n\n<p>If you respond collections in form of an object with fields <code>selfLink</code>, <code>kind</code>, <code>contents</code>, <code>pageOf</code>, <code>next, previous&nbsp;</code> it becomes more intuitive in case of pagination. Your server can send a redirect to a paginated URL if it unable to provide the whole collection.</p>\n\n<p>You might want to support responding with simply a collection then you can use URL suffix in form of <code>#Collection</code> or <code>#Page</code> to tell what the client wants.</p>\n\n<p>Remember, semantics of a <code>PUT</code> request is that it replaces the whole resource&nbsp;object on the server. For partial updates: see <a href=\"https://stackoverflow.com/questions/2443324/best-practice-for-partial-updates-in-a-restful-service\" target=\"_blank\">this StackOverflow anwer</a>. Either use PATCH or use POST to a sub-resource and return <code>Other</code> and <code>Location</code> headers in response and <code>303</code> as response code. Keep this in mind when you are adding new properties/fields into resources.</p>\n\n<p>&nbsp;</p>\n\n<h2>SOAP&nbsp;(originally&nbsp;Simple Object Access Protocol)</h2>\n\n<p>SOAP is a messaging protocol. Web-Services built based on SOAP have to use XML as message format, and can use any application-layer protocol e.g. HTTP, SMTP, TCP, UDP, JMS for message negotiation and transmission.</p>\n\n<p>SOAP evolved as a successor of&nbsp;<a href=\"https://en.wikipedia.org/wiki/XML-RPC\" title=\"XML-RPC\">XML-RPC</a>, though it borrows its transport and interaction neutrality from Web Service Addressing&nbsp;and the envelope/header/body from elsewhere (probably from&nbsp;<a href=\"https://en.wikipedia.org/wiki/WDDX\" title=\"WDDX\">WDDX</a>)</p>\n\n<p>While using SOAP, you cannot just send any XML as request or response. SOAP has clearly specified formats that you have to use. (<em>Why would you want that anyway? You must have contracts, no matter which tech you are using.</em>)</p>\n\n<p>However a SOAP message is an ordinary XML document containing the following elements:</p>\n\n<table border=\"1\" class=\"wikitable\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>Element</th>\n\t\t\t<th>Description</th>\n\t\t\t<th>Required</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Envelope</td>\n\t\t\t<td>Identifies the XML document as a SOAP message.</td>\n\t\t\t<td>Yes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Header</td>\n\t\t\t<td>Contains header information.</td>\n\t\t\t<td>No</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Body</td>\n\t\t\t<td>Contains call, and response information.</td>\n\t\t\t<td>Yes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>Fault</td>\n\t\t\t<td>Provides information about errors that occurred while processing the message.</td>\n\t\t\t<td>No</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>SOAP as such defines just the messaging design. But SOAP is extendible and many specifications have been developed (or are being developed) to cater other issues such as security, reliability.&nbsp;</p>\n\n<h2>Comparing SOAP and REST</h2>\n\n<p>Comparing SOAP and REST is just like comparing <strong>Apples and Oranges</strong>.</p>\n\n<p>But still we can identify some differences:</p>\n\n<ul>\n\t<li>&nbsp;SOAP cannot use anything other than XML as messaging format. XML is comparatably harder to read, slower to parse.</li>\n\t<li>&nbsp;SOAP has some strong specification about web security e.g. WS-Security. For REST there are two versions of OAuth.&nbsp;</li>\n\t<li>&nbsp;REST does not expose some custom set of operations like SOAP does to make it work.</li>\n</ul>\n\n<p>&nbsp;</p>\n<style type=\"text/css\">table tr {\n    padding-top: 12px;\n    padding-bottom: 12px;\n  }\n</style>\n", "authorId": 1, "subject": "architecture", "tags": [], "img": "", "summary": "", "lastUpdated": "2024-05-01 10:14:12.322056"}