{"name":"Java Generics, Collections","id":105,"content":"<h2><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\">Java Generics</span></h2>\n\n<p><meta charset=\"utf-8\" /></p>\n\n<pre>\n<code class=\"language-java\">List&lt;Runnable&gt; list = new ArrayList&lt;Thread&gt;(); //does not even compile.\n\nList&lt;? extends Runnable&gt; list = new ArrayList&lt;Thread&gt;(); //will compile but you cannot add neither Runnable or Thread in this list.\n\n//Wildcards can be passed around but not be used to set value.\n\nList&lt;Set&lt;?&gt;&gt; sets = new ArrayList&lt;&gt;();\n\nsets.add(new HashSet&lt;String&gt;());\n\nsets.add(new HashSet&lt;Integer&gt;());\n\npublic static void list(List&lt;?&gt; list);\n\nlist(new ArrayList&lt;String&gt;());</code></pre>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">You can add a Thread to a List&lt;Runnable&gt;</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">&nbsp;</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">When to use extends and when to use super:</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">PECS: Producer Extends, Consumer Super</b></p>\n\n<pre>\n<code class=\"language-java\">&lt;T extends C &amp; I &amp; Runnable&gt; void test(T t)\n\nAccepts a class that is-a C and implements I and Runnable.</code></pre>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">&nbsp;</b></p>\n\n<p dir=\"ltr\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">Type Erasure: </b></p>\n\n<pre>\n<code class=\"language-java\">Node&lt;T&gt; {  setValue( T val);  }\n\nMyNode extends Node&lt;Integer&gt; {\n\nsetValue(Integer x){  …. }\n\n}\n\nMyNode mn = new MyNode();\n\nNode n = mn;            // A raw type - compiler throws an unchecked warning\n\nn.setValue(\"Hello\"); // Throws ClassCastException\n\n//To check why: Replace the T in Node&lt;T&gt; class with Object due to type erasure.\n\n//Now the MyNode class has method setValue(Integer x) which does not match setValue(Object x) of //superclass, so to preserve polymorphism, compiler injects a Bridge Method in MyNode:\n\nsetValue(Object x){  this.setValue( (Integer)x); }\n\n</code></pre>\n\n<p dir=\"ltr\"><b>&nbsp;</b></p>\n\n<h2 dir=\"ltr\"><span style=\"color:#8e44ad;\"><span style=\"font-family:Lucida Sans Unicode,Lucida Grande,sans-serif;\"><b id=\"docs-internal-guid-d53a3e91-dfa0-fc3a-70e2-0f1a4f5a276f\">Collections</b></span></span></h2>\n\n<p dir=\"ltr\">&nbsp;</p>\n\n<p dir=\"ltr\"><meta charset=\"utf-8\" /></p>\n\n<p dir=\"ltr\" style=\"margin-left: 40px;\">HashMap &rarr; Serialization &rarr; All fields are transient except loadFactor and threshold, just the data is written; capacity;size;key-val;key-val&hellip;&amp; so on.<br />\nA good key for HashMap: Care for equals(), hashCode() and immutability.<br />\nEquals and hashcode contract: equal objects must have equal hash code.<br />\n&nbsp;<br />\nMap is not a true collection.<br />\n&nbsp;<br />\nCollection&lt;E&gt;&nbsp;<br />\nVariances:<br />\nAllow duplicates or not.<br />\nOrdered or not, which order.<br />\nWhere the element is placed, and from where element is removed.<br />\n&nbsp;<br />\nCollections:<br />\nConvenience:<br />\nlist.addAll(Collections.nCopies(69, &quot;fruit bat&quot;));<br />\njob.values().removeAll(Collections.singleton(LAWYER));<br />\nWrappers:<br />\nAdd functionality: synchronizedXXX(), checkedXXX()<br />\n&nbsp;&nbsp; &nbsp;If you want to pass type safe collection to legacy code accepting a non-type safe collection.<br />\nRemove functionality: unmodifiableXXX()<br />\nBoxing/Unboxing is costly. So the List&lt;Integer&gt; will perform poorer than int[]<br />\n&nbsp;</p>\n","authorId":null,"subject":"notes","tags":null,"img":null,"summary":null,"lastUpdated":null}