{"name":"Multi-threading Utilities","id":153,"content":"<p>To see the discussions (some of them) around the JDK implementations of these utilities: Visit <a href=\"http://cs.oswego.edu/pipermail/concurrency-interest/\" target=\"_blank\">this site</a>.</p>\n\n<p>To see the repository of JSR-166 (for concurrent package in Java), visit <a href=\"http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/\" target=\"_blank\">this link</a>.</p>\n\n<h2>Lock Utilities</h2>\n\n<p>Mutexes (Mutual Exclusion Locks). Have the same functionality as in-built synchronization locks. But unlike in-built synchronization lock it&nbsp;can span beyond code blocks, be passed around. It also provides time version, which can be used for resource-ordering based on trial (i.e Swap locks order if did not succeed)</p>\n\n<pre>\n<code class=\"language-java\">public class Mutex implements Sync {\n    public void acquire() throws InterruptedException;\n    public void release();\n    public boolean attempt(long msec) throws InterruptedException;\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">class ListUsingMutex {\n    static class Node {\n        Object item;\n        Node next;\n        Mutex lock = new Mutex(); // each node keeps its own lock\n        Node(Object x, Node n) { item = x; next = n; }\n    }\n    protected Node head; // pointer to first node of list\n    //Use plain synchronization to protect head field.\n// (We could instead use a Mutex here too but there is no reason to do so.)\n    protected synchronized Node getHead() { return head; }\n    public synchronized void add(Object x) { // simple prepend\n        // for simplicity here, do not allow null elements\n        if (x == null) throw new IllegalArgumentException();\n// The use of synchronized here protects only head field.\n// The method does not need to wait out other traversers that have already made it past head node.\n        head = new Node(x, head);\n    }\n    boolean search(Object x) throws InterruptedException {\n        Node p = getHead();\n        if (p == null || x == null) return false;\n        p.lock.acquire(); // Prime loop by acquiring first lock.\n// If above acquire fails due to interrupt, the method will\n// throw InterruptedException now, so there is no need for further cleanup.\n        for (;;) {\n            Node nextp = null;\n            boolean found;\n            try {\n                found = x.equals(p.item);\n                if (!found) {\n                    nextp = p.next;\n                    if (nextp != null) {\n                        try { // Acquire next lock while still holding current\n                            nextp.lock.acquire();\n                        }\n                        catch (InterruptedException ie) {\n                            throw ie; // Note that finally clause will execute before the throw\n                        }\n                    }\n                }\n            }\n            finally { // release old lock regardless of outcome\n                p.lock.release();\n            }\n            if (found)\n                return true;\n            else if (nextp == null)\n                return false;\n            else\n                p = nextp;\n        }\n    }\n// ... other similar traversal and update methods ...\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>A generic lock-ordering manager for locks</p>\n\n<pre>\n<code class=\"language-java\">\nclass LockManager { // Code sketch\n    // ...\n    protected void sortLocks(Sync[] locks) { /* ... */ }\n    public void runWithinLocks(Runnable op, Sync[] locks)\n            throws InterruptedException {\n        sortLocks(locks);\n// for help in recovering from exceptions\n        int lastlocked = -1;\n        InterruptedException caught = null;\n        try {\n            for (int i = 0; i &lt; locks.length; ++i) {\n                locks[i].acquire();\n                lastLocked = i;\n            }\n            op.run();\n        }\n        catch (InterruptedException ie) {\n            caught = ie;\n        }\n        finally {\n            for (int j = lastlocked; j &gt;= 0; --j)\n                locks[j].release();\n            if (caught != null)\n                throw caught;\n        }\n    }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p>Read-Write locks</p>\n\n<pre>\n<code class=\"language-java\">interface ReadWriteLock {\n    Sync readLock();\n    Sync writelock();\n}</code></pre>\n\n<p>The idea is that readLock may be held simultaneously by many readers, but writeLock is mutually exclusive. Read-Write locks are useful in these scenarios:</p>\n\n<ul>\n\t<li>Reading is not permitted while writing methods are in progress. (If reads are permitted during writes, you may instead rely on unsynchronized read methods or copy-on-write updates</li>\n\t<li>Target applications generally have more readers than writers.</li>\n\t<li>The methods in a class can be cleanly separated into those that only access (read) internally held data and those that modify (write).</li>\n\t<li>The methods are relatively time-consuming, so it pays to introduce a bit more overhead associated with read-write locks compared to simpler techniques in order to allow concurrency among reader threads.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">abstract class ReadWrite {\n    protected int activeReaders = 0; // threads executing read\n    protected int activeWriters = 0; // always zero or one\n    protected int waitingReaders = 0; // threads not yet in read\n    protected int waitingWriters = 0; // same for write\n    protected abstract void doRead(); // implement in subclasses\n    protected abstract void doWrite();\n    public void read() throws InterruptedException {\n        beforeRead();\n        try { doRead(); }\n        finally { afterRead(); }\n    }\n    public void write() throws InterruptedException {\n        beforeWrite();\n        try { doWrite(); }\n        finally { afterWrite(); }\n    }\n    protected boolean allowReader() {\n        return waitingWriters == 0 &amp;&amp; activeWriters == 0;\n    }\n    protected boolean allowWriter() {\n        return activeReaders == 0 &amp;&amp; activeWriters == 0;\n    }\n    protected synchronized void beforeRead()\n            throws InterruptedException {\n        ++waitingReaders;\n        while (!allowReader()) {\n            try { wait(); }\n            catch (InterruptedException ie) {\n                --waitingReaders; // roll back state\n                throw ie;\n            }\n        }\n        --waitingReaders;\n        ++activeReaders;\n    }\n    protected synchronized void afterRead() {\n        --activeReaders;\n        notifyAll();\n    }\n    protected synchronized void beforeWrite()\n            throws InterruptedException {\n        ++waitingWriters;\n        while (!allowWriter()) {\n            try { wait(); }\n            catch (InterruptedException ie) {\n                --waitingWriters;\n                throw ie;\n            }\n        }\n        --waitingWriters;\n        ++activeWriters;\n    }\n    protected synchronized void afterWrite() {\n        --activeWriters;\n        notifyAll();\n    }\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">class DataRepository { // Code sketch\n    protected final ReadWriteLock rw = new RWLock();\n    public void access() throws InterruptedException {\n        rw.readLock().acquire();\n        try {\n/* read data */\n        }\n        finally {\n            rw.readLock().release();\n        }\n    }\n    public void modify() throws InterruptedException {\n        rw.writeLock().acquire();\n        try {\n/* write data */\n        }\n        finally {\n            rw.writeLock().release();\n        }\n    }\n}\n</code></pre>\n\n<h2>&nbsp;</h2>\n\n<h2>Counting Semaphores</h2>\n\n<pre>\n<code class=\"language-java\">class Pool { // Incomplete\n    protected java.util.ArrayList items = new ArrayList();\n    protected java.util.HashSet busy = new HashSet();\n    protected final Semaphore available;\n    public Pool(int n) {\n        available = new Semaphore(n);\n        initializeItems(n);\n    }\n    public Object getItem() throws InterruptedException {\n        available.acquire();\n        return doGet();\n    }\n    public void returnItem(Object x) {\n        if (doReturn(x))\n            available.release();\n    }\n    protected synchronized Object doGet() {\n        Object x = items.remove(items.size()-1);\n        busy.add(x); // put in set to check returns\n        return x;\n    }\n    protected synchronized boolean doReturn(Object x) {\n        if (busy.remove(x)) {\n            items.add(x); // put back into available item list\n            return true;\n        }\n        else return false;\n    }\n    protected void initializeItems(int n) {\n// Somehow create the resource objects\n// and place them in items list.\n    }\n}\n\n//This version is likey to run more efficiently than the implementation using wait/notify and fully synchronized put(), take()mehtods; when all threads are using the buffer; because it uses two wait sets\nclass BoundedBufferWithSemaphores {\n    protected final BufferArray buff;\n    protected final Semaphore putPermits;\n    protected final Semaphore takePermits;\n    public BoundedBufferWithSemaphores(int capacity) {\n        if (capacity &lt;= 0) throw new IllegalArgumentException();\n        buff = new BufferArray(capacity);\n        putPermits = new Semaphore(capacity);\n        takePermits = new Semaphore(0);\n    }\n    public void put(Object x) throws InterruptedException {\n        putPermits.acquire();\n        buff.insert(x);\n        takePermits.release();\n    }\n    public Object take() throws InterruptedException {\n        takePermits.acquire();\n        Object x = buff.extract();\n        putPermits.release();\n        return x;\n    }\n    public Object poll(long msecs) throws InterruptedException {\n        if (!takePermits.attempt(msecs)) return null;\n        Object x = buff.extract();\n        putPermits.release();\n        return x;\n    }\n    public boolean offer(Object x, long msecs)\n            throws InterruptedException {\n        if (!putPermits.attempt(msecs)) return false;\n        buff.insert(x);\n        takePermits.release();\n        return true;\n    }\n}\n</code></pre>\n\n<h2>&nbsp;</h2>\n\n<h2>Latches</h2>\n\n<p>Latch also have acquire() and release() operations, with one semantic difference. Here one release(), allows all past (waiting) and future acquire()&#39;s.</p>\n\n<p>Applications are:&nbsp;</p>\n\n<ol>\n\t<li><strong>Completion indicators</strong>. For example, to force a set of threads to wait until some other activity completes.</li>\n\t<li><strong>Timing thresholds</strong>. For example, to trigger a set of threads at a certain date.</li>\n\t<li><strong>Event indications</strong>. For example, to trigger processing that cannot occur until a certain packet is received or button is clicked.</li>\n\t<li><strong>Error indications</strong>. For example, to trigger a set of threads to proceed with global shut-down tasks.</li>\n</ol>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-138","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:26.252+0000"}