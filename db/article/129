{"name": "Microservices Using Java", "id": 129, "content": "<div class=\"dDoNo gsrt t0PA4d X98sZd\" style=\"margin-bottom:0;line-height:normal\">\n<div class=\"xhf7k\">\n<div style=\"font-size: smaller;\"><span data-dobid=\"hdw\">architecture</span></div>\n</div>\n</div>\n\n<div style=\"font-size: smaller;\">\n<div class=\"lr_dct_ent_ph\"><span class=\"lr_dct_ph XpoqFe\">/<span>\u02c8\u0251\u02d0k\u026at\u025bkt\u0283\u0259</span>/</span></div>\n\n<div class=\"lr_dct_ent_ph\"><span class=\"lr_dct_ph XpoqFe\">Meaning: </span><span>the complex or carefully designed structure of something.</span></div>\n</div>\n\n<p><br />\n<strong>Why do we need any architecture?</strong></p>\n\n<p>From a general perspective, in order to make things easier, maintainable and efficient. From a software perspective, to find the suitable level of <strong>Coupling</strong> (basically, it tells how interdependent &quot;<em>components&quot;&nbsp;</em>are, <em>if you change one, do you need to change other too unnecessarily</em>?) and <strong>Cohesion</strong> (basically it tells how relevant the parts of a component are to each other, <em>does this belong to this component</em>?).&nbsp;</p>\n\n<p>To minimize Coupling and increasing Cohesion, there have been many solutions SOA, Shared Libraries, Modules (OSGI implements this concept for Java, Java-9 making&nbsp;it easier).&nbsp;</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>What is the Microservice Architecture (MSA)?</strong></span></p>\n\n<p>In simple words, it&#39;s an extension to a modular architecture. To manage code better you divide the project into modules (then maven, gradle can help you manage these modules easily). Similarly to handle application you divide it into functional modules called microservices. These functional modules can be developed independently of each other, maybe in different technologies, may be deployed on different environments.</p>\n\n<p>But for the application to work, these functional modules need to talk to each other. It&#39;s better to talk in a way which keeps them independent. So we choose web-services to make this communication happen. Generally (not always) one microservice talks to&nbsp;other using webservice (mostly REST) or messaging based pattern (using JMS queues and topics).</p>\n\n<p>Microservice architecture is built upon a combination of&nbsp;Domain-driven design,&nbsp;<strong>Continuous delivery</strong>,&nbsp;On-demand <strong>virtualization</strong>,&nbsp;<strong>Infrastructure automation</strong>,&nbsp;Small autonomous teams,&nbsp;Systems at scale.</p>\n\n<h2>How To Implement Microservices?</h2>\n\n<p>Define the functional boundaries (set requirements after deciding on what functionalities should go into the particular microservice), implement them, and Just <em>expose</em> the functionality using maybe REST endpoints or maybe using messaging routes.</p>\n\n<p>You can choose <strong>Spring-Boot</strong>, DropWizard, Vert.x (if you can do fine without an application server), Spark, <span style=\"color:#27ae60;\">Scalecube</span> and <span style=\"color:#27ae60;\">Wildfly Swarm</span> if you need application server features. Java EE with micro-profile <a href=\"http://microprofile.io/\">MicroProfile</a>&nbsp; is also an option.</p>\n\n<p><a href=\"https://www.lagomframework.com/\" target=\"_blank\">Lagom Framework&nbsp;</a>&nbsp;and <a href=\"https://github.com/wso2/msf4j\" target=\"_blank\">MSF4J</a> provides a structured and organized system to help you develop microservices.</p>\n\n<h2>How Would You Decide What Should Go Into A MicroService?</h2>\n\n<p>To understand this view Monolith as a single service. And then try to convert that into multiple services.</p>\n\n<p><strong>Based on orthogonal business requirements -</strong><br />\n&nbsp; &nbsp; Microservices are a business solution, not just a technology solution. They save developers from having to waste time reinventing already solved technical problems.<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on technical requirements -</strong><br />\n&nbsp;&nbsp; &nbsp;Some parts of the systm may require a lot of concurrency e.g. batchjob processing.<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on team size -</strong><br />\n&nbsp;&nbsp; &nbsp;Teams within an organization should talk to each other via APIs in form of services. Amazon follows a rule of one service per team of 7-8 people.<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on requirement for frequent revision of functionality -</strong><br />\n&nbsp;&nbsp; &nbsp;Some parts/logic might need frequent revision, changes, and hence need to be frequently deployed<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on Transaction requirement -</strong><br />\n&nbsp;&nbsp; &nbsp;It&#39;s best to put everything that needs to be done within a transaction put in a single service.</p>\n\n<p><br />\n&nbsp;&nbsp;&nbsp; Distributed transactions are costly and are not 100% correct. <em>(But, Distributed locks and transactions aren&rsquo;t free with Monoliths, either.<br />\n&nbsp;&nbsp; &nbsp; You are already using it/dealing with such situations when you are using external services e.g. cloud storage, clud APIs, OAuth etc)</em><br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on Database Independence -</strong><br />\n&nbsp;&nbsp; &nbsp;Services should not need to perform joins across each other.<br />\n&nbsp;&nbsp; &nbsp;<br />\n<strong>Based on Reuse -&nbsp;</strong><br />\n&nbsp;&nbsp; &nbsp;If some functionality can be shared across multiple entities (teams, organizational units, applications), it should be a service.<br />\n&nbsp;&nbsp; &nbsp;</p>\n\n<p style=\"font-size: bigger;\">Remember these points while using MSA:</p>\n\n<ul>\n\t<li>What can be implemented as a monolith Monster CRUD app should be developed as monolith.<br />\n\tBe careful. Treating microservices as splitting code layers into docker-ized boxes can lead to &ldquo;death by a thousand cuts.&rdquo;</li>\n\t<li>Service should not be so huge that adding a functionality, refactoring, upgrading a library takes more time than it should.<br />\n\tWith microservices, you won&rsquo;t hear the term &ldquo;big rewrite&rdquo; or &ldquo;legacy system&rdquo; ever again because there are no big systems.</li>\n\t<li>Do not share too much libraries and dependency tree.</li>\n\t<li>Don&#39;t create microservices just to use use features like CI/CD, Docker etc. Monolith is also a service (single one) and can be scaled horizontally.<br />\n\tIt is quite possible to create scalable monoliths and unscalable microservices. It all comes down to how well you apply each&rsquo;s underlying principles.</li>\n\t<li>Remember you need good tooling for microservice environment. Fortunately there have been good engineering solutions for this. E.g. Docker, Kubernetes, Swagger, Falcor, gRPC, CI/CD Pipeline tools, PaaS, Cloud, etc..</li>\n</ul>\n\n<p>Microservices are a culmination of multiple engineering practices. They have a steep curve of learning, unlearning, and transformation.<br />\n&nbsp;</p>\n\n<h2>How is MicroService Architecture different from SOA (Service Oriented Architecture)?</h2>\n\n<p>In short, they are not so different, and we <em>can say</em> that <em>MSA is a subset of SOA</em>.&nbsp;</p>\n\n<p>Read this article for detail: <a href=\"#\" reactlink=\"/article/74\">Microservices and SOA</a>.</p>\n\n<h2>How To Make The Communication Among Microservices Happen?</h2>\n\n<p>One thing that sets micro-services (which can be viewed SOA on a finer level), is that unlike SOA they support easy to change.</p>\n\n<p>Deploy microservices (you can choose to use embedded servers e.g. Embedded Tomcat) or you can deploy using <strong>Docker</strong> and <strong>Kubernetes</strong>.</p>\n\n<p>You have to make sure that:</p>\n\n<ul>\n\t<li>Breaking down of one microservice does not bring the whole application down. Try to minimize the damage.</li>\n\t<li>The slowness of one microservice does not propagate much and make&nbsp;the whole application slow.</li>\n\t<li>The change should be easy.</li>\n\t<li>It would be better if communication is non-blocking. Using Reactive patterns</li>\n</ul>\n\n<p>Reduce the fear of platform dependency. Using Docker we can package our application+JVM+OS+other-dependencies in a single image, which we can just move forward to any production machine and go live.&nbsp;</p>\n\n<h2>Microservice Integration Technologies</h2>\n\n<p>Choices are SOAP, XML-RPC, REST, Messaging, Protocol Buffers, Thrift.</p>\n\n<p><strong>What should we look for in the options?</strong> - If I make a change in service, it should not affect existing consumers.</p>\n\n<p>You can integrate microservices using Business Process Management tools e.g. <strong>Activiti </strong>(This is orchestration, one service acting as central brain and commanding the flow)</p>\n\n<p>We can also integrate in an <strong>event-based style</strong>. One service publishes the event, and other services can act upon receiving that event.</p>\n\n<p>RPC implementations are <strong>RMI </strong>(Java-Java), <strong>SOAP</strong>(Any-Any by generating stubs based on well-defined WSDLs). With RPCs most of the network operations, network messages are hidden. It&#39;s easy to get&nbsp;started with stub based RPCs, but may be hard to debug. For low latency, Server-To-Server communication RPC may be a better option.</p>\n\n<p><strong>REST</strong> with HATEOS (Hypermedias As The Engine Of Application State)&nbsp;</p>\n\n<p>HTTP is suitable for large volumes of traffic&nbsp;but does not help with reducing the latency. Other protocols based on TCP are more efficient for low latency. An example is <strong>WebSocket</strong> it&#39;s just a wrapper around TCP connection (which has persistent connection hence lower latency).</p>\n\n<p>For <strong>Asynchronity</strong>, <strong>Event-Based integration</strong> using MOMs e.g. ActiveMQ. But many MOMs put intelligence in middleware. Middleware should be dumb and endpoints should be smart. You can create custom integration system based on ATOM specification of feeds. Consumers can constantly poll it. Reactive Extensions is another way to integrate microservices.</p>\n\n<p>There are complexities associated with Asynchronous Architectures. (Failure should not propagate e.g. suppose an event comes and an event&nbsp;consumer dies because of it, the message is put back to the queue, another consumer takes it and dies, and this continues <strong><em>Epidemic</em></strong>).</p>\n\n<p>Sometimes you might have to integrate your microservices with some existing Software over which you do not have much control. E.g CMSs, CRMs like Salesforce and&nbsp;SAP. These pose a different challenge. If the customization of a Software is very difficult, you might better build it by yourself.</p>\n\n<h2>Typical Micro-Service Scenarios</h2>\n\n<p>Suppose a service is responsible for Customer enrollment, which requires different tasks. Such as creating a record for the customer, sending a post, sending a welcome email. All these tasks are handled by services.</p>\n\n<p>Here we have two options. Customer service can itself call these services. We can use rule engines like Activiti, Drools, BPM etc. But then customer service becomes God service (too much central authority). (This is called <strong><em>Orchestration</em></strong>)</p>\n\n<p>Another way&nbsp;is to inform each service what has been done (by sending an event), and that service can decide what to do. But now an explicit view of the system does not exist, instead, we need additional work to monitor and track that right things happened. The biggest advantage here is <strong><em>Decoupling, </em></strong>which is actually the whole point of services. (This is called <strong><em>Choreography</em></strong>)</p>\n\n<p><strong><em>API Gateway</em></strong> is quite similar to orchestration if taken to extreme, in simple versions it is just for authentication and proxy for target services. Just the intention is different, it&#39;s like Facade pattern for services, to present simplified view to the consumers/clients, and to optimize performance.&nbsp;</p>\n\n<p>Read&nbsp;<a href=\"https://stackoverflow.com/questions/29117570/orchestrating-microservices\" target=\"_blank\">https://stackoverflow.com/questions/29117570/orchestrating-microservices</a></p>\n\n<p><strong>How do you make sure of transactions, handle failures, in case of multiple services?</strong></p>\n\n<p>Suppose you were trying to enroll&nbsp;customer which required to call three&nbsp;services, first service done, but second service failed. How would you ensure consistency</p>\n\n<p>Distributed transactions are slow, and do not result in 100% consistency always. In the most famous algorithm for this <strong>2PC,</strong> TransactionManager basically waits for a &#39;yes&#39; vote from each participant that whether it thinks its local transaction can go ahead (even a single no will send rollback to each participant). But there could be situations when after voting yes, the local transaction failed, or the TransactionManager goes down leaving pending transactions unfulfilled. There is problems of contention, blocking, inconsistency.</p>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Eventual_consistency\" target=\"_blank\">Eventual consistency</a> with&nbsp;<strong><a href=\"https://microservices.io/patterns/data/saga.html\" target=\"_blank\">Sagas</a> (Compensating transactions)</strong>&nbsp;is&nbsp;the best you can do. If some scenario demands ACID, then it&#39;s best to merge the services which need to be in single transactional boundaries. Customer service will create a customer record in DB and send a&nbsp;CUSTOMER_CREATED event to queue. Post service will listen to this and start its work, if it fails, it will put a POST_FAILED event, and customer service will start a compensating transaction. This is complex in implement - decide how to handle cases where compensating transaction is received but the record has already been modified before the original transaction could be reverted.</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "linked-to-137", "tags": [], "img": "", "summary": "", "lastUpdated": "2024-05-08 12:12:31.270770"}