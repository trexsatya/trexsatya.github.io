{"name":"Core Java Common Things","id":101,"content":"<p>Every String literal goes to String pool within Heap. intern() method can be used to send String objects to pool.</p>\n\n<p>String being immutable provides Performance (by allowing caching of objects, caching of hashcodes), Thread-Safety, Error-Safety and Security (important things host names, passwords would not be allowed to be modified even if object is leaked).</p>\n\n<p>Closing of precious resources should not be achieved by overriding finalize() method, as it is not guaranteed to run when it actually should (because it is run when GC runs and GC cycle is unpredictable). If you are using Java-7 even finally should not be used to close resources, you should use Automatic-Resource-Management with try-with-resources feature. Think of close() method of AutoCloseable interface being called at the last line in try block.</p>\n\n<pre>\n<code class=\"language-java\">try { return 1; } finally { return 2; } //will return 2\n\ntry { throw new RuntimeException(); } finally { return 2; } //will return 2 instead of throwing exception</code></pre>\n\n<h2><span style=\"color:#2c3e50;\"><span style=\"font-family:Tahoma,Geneva,sans-serif;\">Overloading and Overriding</span></span></h2>\n\n<p><span style=\"color:#16a085;\"><em>Method-Invocation-Conversion</em></span></p>\n\n<p>Methods <strong>must</strong> be different in argument list (size or type). Return type and access-specifiers do not matter. Exception list matters: only new and broader exceptions are allowed. Overloading can span inheritance.</p>\n\n<p>Overloading in case of widening, boxing: Java first tries to find method which can hold the parameter passed EXACTLY, then if not found it uses whichevery type that can hold the value. It consults types in increasing order of capacity. e.g. an int is passed to method, but no method is available which uses an int as argument, but if there is a method with long as argument, that will be used.</p>\n\n<p>Compiler will use a method with wrapper type if exact type not found. In case both widening and boxing options are available, compiler chooses widening. Boxing came later into picture from Java-5.</p>\n\n<p>Widening also beats Varargs.</p>\n\n<p>Method invocation conversion is not capable of Widening-Then-Boxing, but it is capable of Boxing-Then-Widening. Because due to inheritance Java is capable of holding a value in wider (parent) type.</p>\n\n<p>You may sometimes falsely see a method as being overridden when in fact it is overloading. Remember overriding will happen only if method is available in child class, a private method with same name in parent is not inherited.</p>\n\n<p>Two methods can not have same signature in the same class, however a method can have same signature as of an inherited one, then rules of overriding apply.</p>\n\n<p>While overriding you cannot introduce new&nbsp;checked exception(s), can not replace by super-exception but only more-specific-exception (Because if it were, it will break the existing code and thrown exception will go uncaught). Runtime exceptions are allowed without any rule.</p>\n\n<p>Compiler looks for <font color=\"#16a085\"><i>MOST-SPECIFIC-METHOD-INVOCATION</i></font></p>\n\n<pre>\n<code class=\"language-java\">void fn(Object a){ }\nvoid fn(String a){ }\n//This is the case of overloading\n\nfn(null); //Will call second method, because compiler can see that it is most-specific method invocation\n//But if we have another method like this\nvoid fn(StringBuilder a){ }\n\n//Now compiler will be confused, because there are two methods at same level-of-inheritance and compiler can't decide which one is most-specific\n</code></pre>\n\n<pre>\n<code class=\"language-java\">void method(Object a, String b){ }\n\nvoid method(String a, Object b){ }\n\nmethod(null, null); //This will confuse compiler</code></pre>\n\n<h2><span style=\"color:#8e44ad;\"><span style=\"font-family:Georgia,serif;\">Wrappers (Primitive Types as objects)</span></span></h2>\n\n<p>Wrappers may throw NullPointerException (when auto-boxing/auto-unboxing is happening and value is null), look out for them.</p>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"color:#8e44ad;\"><span style=\"font-family:Georgia,serif;\">Inner Classes</span></span></h2>\n\n<p>Non-static Inner class can not have static member.</p>\n\n<h2><span style=\"color:#8e44ad;\"><span style=\"font-family:Georgia,serif;\">Serialization and Deserialization</span></span></h2>\n\n<p>The purpose of serialization is to save object, purpose of Deserialization is to retrieve object, so while deserializing it does not make sense to call constructor if the object was already saved, however constructor of first non-serializable parent will be called as it was not saved because it was non-serializable.</p>\n\n<p>When serializing, JVM serializes the whole object graph and throws NotSerializableException if some non-transient-and-non-static-member is not marked Serializable.</p>\n\n<h2><span style=\"color:#8e44ad;\"><span style=\"font-family:Georgia,serif;\">Enums (special classes meant to be used as constants)</span></span></h2>\n\n<p>Enums are implicitly static final.</p>\n\n<p>Can implement interfaces. At least one enum constant is required, if you treat enums like class i.e. declare members.&nbsp;</p>\n\n<p>Enum constructor is implicitly private and it can not be declared protected or public.&nbsp;</p>\n\n<p>Enum can be abstract.</p>\n\n<p>Enum can not be inside method body.</p>\n\n<p>Just like classes, you have to provide default constructor if you are providing any constructor.</p>\n\n<p>clone(), equals(), finalize(), hashCode() all are implicitly final for enums.</p>\n\n<p>&nbsp;</p>\n\n<p>Is Java pass-by-value, or pass-by-reference?</p>\n\n<p>A Funny view on this: Java is pass-by-woodoo-doll. When you call a method, you actually get a woodoo doll, using which you can control the actual being, but can&#39;t replace the being altogether.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"notes","tags":null,"img":null,"summary":null,"lastUpdated":null}