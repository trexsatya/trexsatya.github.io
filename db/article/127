{"name": "Messaging Systems", "id": 127, "content": "<h2>Objective</h2>\n\n<p>To give short but complete overview of systems/tools/frameworks used to facilitate asynchronous messaging among applications (running on different servers). There are 2+ ways in Java:</p>\n\n<ol>\n\t<li>JMS&nbsp;</li>\n\t<li>Kafka</li>\n</ol>\n\n<p><em>The fundamental requirement is that I should be able to place my message somewhere, and hope that someone else would pick the message and take action (and maybe place a message for me). You would definitely want to have control over who can pick the message. Things get more complicated when we use a distriibuted system for this, the load of messages is high.</em></p>\n\n<p>Java Messaging Service (JMS) is an API provided by standard Java. Note that it is just an API, not the implementation. It is just a contract. The actual work described by this API is done by implementation libraries from JMS Providers (a.k.a <b>Message-oriented middleware</b>&nbsp;(<b>MOM</b>)).</p>\n\n<p>There are many implementation libraries e.g. <strong>ActiveMQ</strong>, RabbitMQ, WebsphereMQ, OracleAQ etc.</p>\n\n<p>We will look at the following:</p>\n\n<ol>\n\t<li><em>How to program with JMS API</em></li>\n\t<li><em>What are the concepts in JMS API?</em></li>\n\t<li><em>How to use JMS implementation ActiveMQ</em></li>\n</ol>\n\n<p><strong>What is JMS?</strong></p>\n\n<p>JMS is a specification. Different MOM products implement this specification. You do not directly use MOM products in your application, instead, connect using JMS. Otherwise, you will have a hard time replacing the library you have used in your project,&nbsp;in favor of more efficient library in the future.</p>\n\n<p><strong>What JMS is Not?</strong></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\"><br />\nJMS does not specify a distributed version of the Java event model.<br />\n<br />\nJMS is not <strong>intelligent</strong>. Publishers do not get to know whether there is any subscriber or not, which would have been helpful so that publisher publishes only if there is any subscriber. Some MOM products might have this feature, but it&#39;s not part of JMS.<br />\n<br />\nJMS does not specify the protocol for <strong>secure</strong> access and <strong>message format</strong>.<br />\n<br />\nJMS is <strong>almost-real-time</strong> enough for general purpose requirements.<br />\n&nbsp;</div>\n\n<p>&nbsp;</p>\n\n<p>What to strive for while implementing/using a messaging system.</p>\n\n<h2><br />\nBut Why Do We Need This?</h2>\n\n<p>When two applications want to communicate, and they cannot talk directly (might be because they are built on different technology stacks, or because they are not authorized to talk directly, in other words, you do not have access to their API either using JAR or using REST endpoints), MOM acts as a middleman. MOM (Message Oriented Middleware) may act as an intelligent router.</p>\n\n<p>This communication can be in Point-To-Point (one-to-one and many-to-one) or Publish-Subscribe style (many-to-many).</p>\n\n<p><img alt=\"\" src=\"/images/jms_queue_topic.png\" style=\"width: 600px; height: 408px;\" /></p>\n\n<p><strong>What do we mean by Point-To-Point?</strong></p>\n\n<p>&quot;<em>I want to send this message only to a particular queue (receiver) through MOM</em>&quot;. - This is Point-to-point.</p>\n\n<p><strong>What do we mean by Publish-Subscribe?</strong></p>\n\n<p>&quot;<em>I want to send the message to everybody who is interested in receiving it through MOM</em>&quot; - This is Pub-Sub.</p>\n\n<p>Any application can act as producer (which creates a message and puts it on the queue or topic), and any application can act as Consumer (who listens to the incoming messages). Instead of saying Application-x we generally say Client-x because the client could be anything a standalone application, or a microservice, or a simple java program.</p>\n\n<h2>Concepts</h2>\n\n<p><strong>Messag</strong><strong>e Queues</strong>: are a collection of messages on MQ Servers or MOMs. Mostly FIFO based queue. There can be multiple consumers attached to a queue waiting for a message. When the message arrives on queue, the queue delivers it to one (and only one) of the consumers attached, and the&nbsp;message is then removed from the&nbsp;queue. The message itself contains the information about the destination queue.</p>\n\n<p>In the case of Publish-Subscriber setup, the message will be delivered to multiple consumers attached to the Topic. There is no guarantee of the order in which messages are delivered.&nbsp;</p>\n\n<h2>How to use JMS API?</h2>\n\n<p style=\"margin-left: 160px;\"><img alt=\"\" src=\"/images/jms_api.png\" style=\"width: 500px; height: 291px;\" /></p>\n\n<p>This is the basic code structure for the basic flow of JMS. Using ActiveMQ implementation.&nbsp;</p>\n\n<p>(1) Get the <strong>ConnectionFactory</strong> object:</p>\n\n<ul>\n\t<li>Create one programmatically&nbsp;\n\t<pre>\n<code class=\"language-java\">String url = \u201ctcp://localhost:61616\u201d\nConnectionFactory factory = new ActiveMQConnectionFactory(url);</code></pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n\t<li>Create one using Admin console of MOM provider / application-server, and then use JNDI to get it into your program/application.\n\t<pre>\n<code class=\"language-java\">InitialContext jndiContext = new InitialContext();\nConnectionFactory cf = jndiContext.lookup(connectionfactoryname);</code></pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n</ul>\n\n<p>(2) Create Session using your ConnectionFactory: Session is basically program&#39;s view of Connection.</p>\n\n<pre>\n<code class=\"language-java\">//create a connection\nConnection connection = cf.createConnection();\n//create a session\nSession session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);</code></pre>\n\n<p>(3) Get the destination (Queue or Topic)</p>\n\n<ul>\n\t<li>You can either create one programmatically&nbsp;\n\t<pre>\n<code class=\"language-java\">Topic topic = session.createTopic(\u201cTestTopic\u201d);</code></pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n\t<li>Or, create using Admin console of MOM / application-server and use that through JNDI\n\t<pre>\n<code class=\"language-java\">Destination queue = (Queue) jndiContext.lookup(\u201c/jms/myQueue\u201d); </code></pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n</ul>\n\n<p>(4) Create Producer in one application, send the message</p>\n\n<pre>\n<code class=\"language-java\">MessageProducer producer = session.createProducer(topic);\n// Create and send the message\nTextMessage msg = session.createTextMessage();\nmsg.setText(\u201cHello JMS World\u201d);\nproducer.send(msg);</code></pre>\n\n<p>Create Consumer in maybe another application, listen for messages</p>\n\n<pre>\n<code class=\"language-java\">MessageConsumer consumer = session.createConsumer(topic);\n// Listen for arriving messages asynchronously\nMessageListener listener = new MessageListener() {\npublic void onMessage(Message msg) { /* do something */ }\n};\nconsumer.setMessageListener(listener);\nconnection.start();\n\n//You can also get message in synchronous way\nMessage m = consumer.receive();</code></pre>\n\n<p><strong>What is a Broker?</strong></p>\n\n<p>The Broker is a service on the network or&nbsp;<a href=\"http://activemq.apache.org/how-do-i-embed-a-broker-inside-a-connection.html\" shape=\"rect\">embedded in the same JVM</a>&nbsp;which provides the message provider. So think of the ConnectionFactory as the client API for sending and receiving messages and the broker is a server-side implementation.</p>\n\n<p>JMS does not allow multiple receivers in P2P style, it will throw the exception <span style=\"color:#c0392b;\"><em>&quot;JMSException: Unable to create a receiver for the queue as it is already in use. Please close this object and try again.&quot;</em></span></p>\n\n<ul>\n\t<li>The session object acts a factory for creating message producers and message consumers.</li>\n\t<li>The session object also acts as a factory for creating messages.</li>\n\t<li>The session object defines a serial order for the messages it consumes and produces.</li>\n\t<li>The session object retains messages it consumes until they have been acknowledged.</li>\n\t<li>The session object serializes execution of message listeners registered with it.</li>\n\t<li>The session object supports a single series of transactions that combine work spanning that session&rsquo;s producers and consumers into atomic units that can either be committed or rolled back.</li>\n</ul>\n\n<h2>JMS Application using Spring Boot &amp; ActiveMQ:</h2>\n\n<p>As always Spring Boot makes it easy to work with anything. Go to&nbsp;<a href=\"https://start.spring.io/\" target=\"_blank\">https://start.spring.io/</a> select the Web and JMS as dependencies. Generate the skeleton project. Import in your IDE (IntelliJ, or other).</p>\n\n<p>How To Use ActiveMQ in an application?</p>\n\n<ul>\n\t<li>Spring provides a JMS Template, which you can/should use to send and receive messages on queues.</li>\n\t<li>Spring wraps JMS Exceptions into runtime exceptions.</li>\n\t<li>Spring provides easy configuration to connect with a running ActiveMQ instance, it even provides an embedded ActiveMQ instance if you do not have an explicit one (but use this only for development/testing purpose).</li>\n\t<li>Provide an ActiveMQConnectionFactory which requires ActiveMQ server&#39;s URL, username and password.</li>\n\t<li>Provide <code>DefaultJmsListenerContainerFactory</code> which requires a <code>ActiveMQConnectionFactory</code>, this is so that consumer/receivers become active.</li>\n\t<li>You will also need to provide MessageConverter. There are many types: <code>MappingJackson2MessageConverter</code>, <code>SimpleMessageCoverter</code>, <code>MessagingMessageConverter </code>etc.</li>\n</ul>\n\n<p>Spring will wire up these beans where needed e.g. the JMSTemplate provided by Spring will use your provided MessageConverter automatically.</p>\n\n<p>&nbsp;</p>\n\n<h3><strong>What happens if Consumer is sleeping/down/not-listening while Producer sends a message?</strong></h3>\n\n<p>It depends on what kind of subscription the Consumer has taken. If it is <strong><em>durable</em></strong>&nbsp;then all the messages missed by Consumer will be delivered to it when Consumer&nbsp;becomes active again, otherwise, those messages will be lost.</p>\n\n<h3><strong>What happens if the Broker crashes or restarts?</strong></h3>\n\n<p>JMS specifies 2 types of delivery modes for messages:&nbsp;<strong>persistent</strong> and <strong>non-persistent</strong>.&nbsp;JMS specification mandates that a provider must deliver a non-persistent message zero or one time at most.</p>\n\n<p>The JMS specification mandates that a provider must deliver a persistent message once&minus;and&minus;only&minus;once.&nbsp;</p>\n\n<p>Persistence != Reliability:&nbsp;Retention of a message at the destination until its receipt is acknowledged is not guaranteed by a persistent delivery mode, instead it is an administrative setting.</p>\n\n<h2><strong>Transactions and Redelivery</strong></h2>\n\n<p>If a failure occurs while execution of message receiver code, then the message is automatically redelivered.</p>\n\n<p>When calling&nbsp;<code>connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</code>&nbsp;you have other options in place of&nbsp;<code>Session.AUTO_ACKNOWLEDGE</code>&nbsp;</p>\n\n<p><code>(1) Session.DUPS_OK_ACKNOWLEDGE</code> just like&nbsp;<code>Session.AUTO_ACKNOWLEDGE</code>&nbsp;but duplicates allowed (which happens in rare scenarios). <strong>Gives more throughput</strong>.</p>\n\n<p>(2)&nbsp; <code>Session.CLIENT_ACKNOWLEDGE</code>: in this mode client (message reciever ) has to acknowledge that it has received the message by calling <code>acknowledge()</code> on the <code>Message</code>. Once the client&nbsp;acknowledges a particular message acknowledges all prior messages the session receives. <strong>Adds code complexity</strong>.</p>\n\n<p><strong>What happens to messages that are in the session but never acknowledged?</strong></p>\n\n<p>The messages remain at the destination until they expire or forever if they lack an expiration date. Message redelivery is not automatic, but messages are redelivered under certain circumstances:-</p>\n\n<p>(1) Calling the&nbsp;<code>Session</code>&nbsp;class&#39;s&nbsp;<code>recover()</code>&nbsp;method recovers the session. Invoking the&nbsp;<code>recover()</code>&nbsp;method causes the redelivery of all unacknowledged messages</p>\n\n<p>(2) The receiving application (client) restarts, causing the session to restart. Restarting the session causes all unacknowledged messages to be redelivered.</p>\n\n<p><br />\nTo create transactional sessions: Use&nbsp;<code>connection.createSession(true)</code>&nbsp;</p>\n\n<p>The client (receiver application) creates transacted session, calls <code>commit()</code>&nbsp;when message processing has been successful, otherwise calls <code>rollback()</code>.&nbsp;</p>\n\n<p><strong>What happens to the rolled-back messages?&nbsp;</strong></p>\n\n<p>The JMS provider automatically redelivers these messages so the application can reprocess them. We can customize how this redlivery logic in case of transaction rollback is handled.</p>\n\n<ul>\n\t<li><em>Redelivery count</em>: The number of times to redeliver a message. You do not want to crash&nbsp;the system by allowing infinite redeliveries.</li>\n\t<li><em>Exception destination</em>: What happens to a message that is redelivered redelivery-count times? The JMS provider can do any of the following:\n\t<ul>\n\t\t<li>Log the message</li>\n\t\t<li>Forward the message to an exception or error destination</li>\n\t\t<li>Lose the message</li>\n\t</ul>\n\t</li>\n\t<li><em>Time to redeliver</em>: An application that has just rolled back messages might not be ready to reprocess the same messages. This parameter specifies the time to wait before redelivering the message. This delay lets the JMS provider and the application recover to a stable state.</li>\n</ul>\n\n<p>The redelivered messages maintain its original timestamp. So when they get back to the queue for redelivery, they go to the front of the queue (by default strategy of time-based delivery).</p>\n\n<p><strong>Okay, so you have configured redelivery model, and now have a loosely coupled system of Producer application(s) and Consumer application(s). But what if the MOM broker itself goes down?</strong></p>\n\n<p>ActiveMQ (and other MOMs) supports broker clustering. So even if one broker goes down, others can take up the task of redelivering the message. ActiveMQ supports it by Master-Slave configuration and Replicated-Message-Stores configuration.</p>\n\n<p>For detail visit:&nbsp;<a href=\"http://activemq.apache.org/clustering.html\" target=\"_blank\">http://activemq.apache.org/clustering.html</a></p>\n\n<p>&nbsp;</p>\n\n<p>Read this:</p>\n\n<p><a href=\"https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13\" target=\"_blank\">https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13</a></p>\n\n<p>Summary of the linked article:</p>\n\n<p>This is what happens in Pub-Sub model. There&#39;s a TOPIC to which many queues subscribe. When a service pushes a Message to the topic, the topic sends a copy to each of the queues and then flushes the Message. Consuming services listen to the queues, and consume the message from the queue.</p>\n\n<p>The benefit is that &quot;publisher of the message knows nothing about consumers of the message, the system is decoupled&quot;. <strong><em>Is that so?</em></strong>&nbsp;You&rsquo;re not going to let just anybody subscribe to a topic. You would be checking some permissions, onboard the subscribers. What if you develop a mechanism of registering the interested consumers directly to the producer service? If you are in a cloud-based&nbsp;environment like AWS, it could save you much cost (you will save the cost incurred by message sitting there in the topic until every consumer picks up a copy).</p>\n\n<p>The thing is that the knowledge of consumers, their list, is pushed to another component <em>Topic</em>. But ultimately you own the topic and you are responsible for granting access to it.&nbsp;</p>\n\n<p>So, where are the queues useful? - On the consumer side, it will allow parallel processing, throttling etc. The cost of storing a message is now pushed to the consumers. But be careful with it, as now you have to send a copy of the message to everyone interested by yourself. (The cost associated with it will probably be cancelled out by the cost incurred by making sure that the consumer is valid (security)).&nbsp;<br />\nAlso, be careful as not to reinvent the wheel by creating your own topic implementation. (Like when you start implementing the requirements like guaranteed delivery (what if a consumer is down), retry logic (what if a consumer is slow), backpressure), fault tolerance (keeping a fast-changing service highly available is more difficult than keeping a dedicated broker up).&nbsp;</p>\n\n<p>And you really need to calculate how much cost you actually save.</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "programming", "tags": [], "img": "/images/messaging.jpg", "summary": "JMS provides you a standard way in which you can interconnect different systems which talk to each other in an asynchronous way.", "lastUpdated": "2021-06-06 10:08:58.494911"}