{"name":"Microservices and SOA","id":74,"content":"<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;box-shadow: -5px 0 5px 0 blue;\">Suppose you had written your system/application in your favorite technology. Everything was going great until times changed, clients started demanding new <em>functionality</em> of a kind which you had not thought earlier. Is your architecture prepared to handle this kind of scenario? This is the question of Service based Architecture.&nbsp;<br />\n<span style=\"color:#27ae60;\"><em>How gracefully can you add a functionality to your existing system, without going through a lot of changes, a lot of testing the whole application, and without compromising with technologies?</em></span></div>\n\n<p><br />\nThe evolution of software architecture began&nbsp;with <em>Monoliths</em>, they were huge programs running on huge computers. Even today, some banks run monoliths on Mainframes.&nbsp;</p>\n\n<p>But the world today is very dynamic and growing, so if you want to grow at all, you have to get&nbsp;rid of <em>Monoliths, </em>mainly because they are very hard to maintain, change&nbsp;and turn out to be costlier nowadays.</p>\n\n<p>Read this great article:&nbsp;<a href=\"https://www.infoworld.com/article/3080611/application-development/learning-from-soa-5-lessons-for-the-microservices-era.html\" target=\"_blank\"><span style=\"color:#8e44ad;\">https://www.infoworld.com/article/3080611/application-development/learning-from-soa-5-lessons-for-the-microservices-era.html</span></a></p>\n\n<p>When trying to get rid of monoliths, you realize that system should be built as a&nbsp;<strong>set of applications</strong> which need to work in coordination with each other. And most of the times these applications have some common logic and common data.&nbsp;</p>\n\n<blockquote>\n<p>A service-oriented architecture (SOA) is a style of multitier computing that helps organizations share logic and data among multiple applications and usage modes.</p>\n</blockquote>\n\n<p>All distributed systems including SOA-based and MicroServices-based, come with additional issues and associated costs:&nbsp;</p>\n\n<ul>\n\t<li>Service Contracts (includes format of data transfer, contract versioning etc)</li>\n\t<li>Additional delay introduced due to remote calls</li>\n\t<li>Choosing right protocol to make remote calls (REST, SOAP, JMS, AMQP, RMI/IOP, Thrift etc)</li>\n\t<li>Dealing with unresponsive or unavailable services (Circuit-Breaker pattern deals with this)</li>\n\t<li>Distributed transactions (XA-Transactions deal with this but very costly, Eventual Consistency is a a trade-off for this and is applicable in most business scenarios)</li>\n</ul>\n\n<p><strong>Services</strong>&nbsp;are way/mechanism for accessing (business) capabilities of a system. They can be encapsulated and classified based on many different parameters. There could be <em>business specific services</em> by role e.g. Trade Capturing, Trade Processing, Reporting to Warehouse, Settlement etc (These are common in financial institutions).&nbsp;</p>\n\n<p style=\"margin-left: 40px;\">There could be non-business services <em>Infrastructure Services</em>: Logging service, Auditing Service, Auth Service etc</p>\n\n<p><strong>Service Classification</strong>:</p>\n\n<p>In Microservices these two types of classification are enough. Functional Services and Infrastructure Services</p>\n\n<p>In SOA there are other aspects of classification:&nbsp;</p>\n\n<p><img alt=\"\" src=\"/images/soa_services.png\" style=\"width: 500px; height: 350px;\" />&nbsp;</p>\n\n<p><em>Business Services</em> are very abstract, they generally just specify the name, input and output expressed in form of WSDL, BPEL files.<br />\n<em>Enterprise Services</em> are concrete implementation or could be an aggregation of Application Services. ESes are used across different parts of an organization. Examples include <code>GetInventory</code> service, <code>GetCustomer</code> service.<br />\nApplication Services are very specific and fine-grained implementations.</p>\n\n<p><strong>Granularity (Size) of Services:</strong></p>\n\n<p>The name itself implies that MicroServices are more fine-grained than SOA services.</p>\n\n<p><strong>Component Sharing</strong>:</p>\n\n<p>Microservices philosophy is <em>&quot;share as little as possible&quot;</em>. SOA has opposite philosophy <em>&quot;Share as much as possible&quot;. </em>Enterprise Services are commonly shared.</p>\n\n<p>Microservices advert that you should a service and its associated data be encapsulated and should have minimal dependency on other service or data. This is called Domain Driven <em>Bounded Context</em>.&nbsp;</p>\n\n<p>SOA favors Service <strong><em>Orchestration</em></strong> (Mediator pattern), while Microservices favor Service <strong><em>Choreography</em></strong> (Service Chaining, inter-service communication). In <em>Orchestration</em>, a mediator is required which will help get the result from different services and combine them such as Mule, Camel, Spring Integration etc. This middle layer is known as <em>Middleware</em>, <em>Enterprise Service Bus</em> or <em>Integration Hub</em>.</p>\n\n<p>In <strong><em>Choreography</em></strong>, one service calls another which in turn calls the third one and so forth. However there could be an API layer/gateway which is between consumer and services, but this middle layer is not <em>intelligent</em>. In SOA middle layer is intelligent.</p>\n\n<p>The API Layer/<em>Gateway</em> in Microservices is rather dumb, it just knows the location of services to call. So that clients are not coupled to locations of internal services. It just performs <em>Routing</em>.</p>\n\n<p>The Middleware in SOA performs <em>Routing</em> plus <em>Message Enhancement</em>, <em>Message Transformation</em>, <em>Protocol Transformation</em> etc.</p>\n\n<p>Actually, SOA can use both Orchestration and Choreography.</p>\n\n<p>Although both SOA and Microservices are free to choose and use any communication protocol, both of them have their favorites. Microservices favorite protocol is REST, JMS and SOA&#39;s favorite is SOAP, JMS. However, Middleware is also SOA&#39;s favorite which encourages you to use heterogeneous protocols.</p>\n\n<p><strong>Usage Scope</strong>:</p>\n\n<p>SOA is well suited for large-scale enterprise systems, in which its easy to find candidates for Business Services, shared Enterprise Services. Where you need to combine multiple heterogeneous small systems.</p>\n\n<p>Microservices are suitable for small-scale, not-enterprise-level web applications.</p>\n\n<p>SOA became popular with the arrival of the concept of <em>Web Services.&nbsp;</em></p>\n\n<p><em>ESBs (Enterprise Service Bus)&nbsp;</em>started as integration pattern and went on to become Middleware products. ESBs were to replace <em>EIP (Enterprise Application Integration)</em> brokers which has similar issues as with monoliths.EIP broker companies&nbsp;rebranded their products as ESB products.&nbsp;</p>\n\n<p>The ESB gave the SOA championing enterprise architects a foothold in the application environments they were tasked with transforming. They used this foothold for two new purposes: control and consistency. A set of WS-* standards was created which is still growing.</p>\n\n<p>With the technological template, the prescriptive standards, and the centralized culture of command and control, the would-be lightweight alternative to EAI had become heavier and heavier. SOA had lost its way.</p>\n\n<p>The original promise of SOA was to speed up project delivery, increase IT agility, and reduce integration costs. However, SOA adopters -- i.e., adopters of what SOA had become by this point -- found that it actually increased complexity and introduced bottlenecks, and the costs of implementing an SOA infrastructure (based on the ESB, registry, and service platform template) were excessive.</p>\n\n<p>SOA worked on SOAP web services. It&#39;s difficult to work with SOAP in an agile environment.</p>\n\n<p>Meanwhile, people developed a lightweight alternative to SOAP services, called <em>RESTful web services.</em></p>\n\n<p><em>Microservices </em>are same as SOA, at least in principle, Microservice architecture focusses on scalable micro-services. This micro word is very crucial in success (and also some nuances, which people somehow get around one way or other). Microservices architecture is complemented by some latest technologies like REST, Docker containers, Cloud,&nbsp; and technologies for DevOps. All these combined give seamless system integration in an agile environment.</p>\n\n<p><a href=\"https://martinfowler.com/articles/microservices.html#CharacteristicsOfAMicroserviceArchitecture\" target=\"_blank\">https://martinfowler.com/articles/microservices.html#CharacteristicsOfAMicroserviceArchitecture</a></p>\n\n<p><a href=\"https://www.linkedin.com/pulse/microservices-digital-transformation-case-studies-erp-yerramsetti/\" target=\"_blank\"><span style=\"color:#8e44ad;\">https://www.linkedin.com/pulse/microservices-digital-transformation-case-studies-erp-yerramsetti/</span></a></p>\n\n<h2>Microservice Patterns</h2>\n\n<p><a href=\"http://microservicepatterns.org/\" target=\"_blank\">http://microservicepatterns.org/</a></p>\n\n<p><a href=\"http://microservices.io/patterns/\" target=\"_blank\">http://microservices.io/patterns/</a></p>\n\n<p><a href=\"https://www.oreilly.com/ideas/microservices-antipatterns-and-pitfalls\" target=\"_blank\">https://www.oreilly.com/ideas/microservices-antipatterns-and-pitfalls</a></p>\n\n<p><strong>Challenges in the microservice world</strong></p>\n\n<p>Inefficient inter-process communications, overarching monitoring, management, and governance, and consistent state. (<em>Note that high-efficiency inter-process communications frameworks are very available now (gRPC, Avro, Hystrix, Finagle) so this isn&rsquo;t a long-term concern. Rather, it should be something to flag. If you plan to do microservices, raw HTTP/ JSON or XML will eventually become too inefficient for the pattern at high scale.</em>)</p>\n\n<p>PROBLEM:<br />\nCoarse-grained services are too difficult to change without side effects, and the monolithic nature of traditional architecture is &ldquo;holding the teams back.&rdquo;<br />\nSOLUTION:<br />\nBreak up services into finer-grained pieces, which reduces the scope of any given change, allowing it to happen more easily.</p>\n\n<p>APPLICATION:<br />\nServices are broken up into finer-grained microservices, typically each with a single purpose.<br />\nImpacts:<br />\n◆ Traffic increases.<br />\n◆ The number of services managed becomes large.<br />\n◆ Traditional monitoring solutions become insufficient.<br />\n◆ The automation of integration, testing, and deployment become critical.<br />\n◆ The orchestration of microservices becomes necessary.<br />\n◆&nbsp;The ability to change rapidly is improved</p>\n\n<h2>How do I design Microservices?</h2>\n\n<p>Very simple rules: Define boundaries of functionality. Keep every microservice simple and independent as much as possible.</p>\n\n<p>Read this:&nbsp;<a href=\"https://cloudncode.blog/2016/07/22/msa-getting-started/\" target=\"_blank\">https://cloudncode.blog/2016/07/22/msa-getting-started/</a></p>\n\n<p>Here&#39;s the summary of this article:-</p>\n\n<p>Refrain from being crazy about the micro part of the microservice. GetUserById, GetUser are nano-services not micro-services. (They might be suitable in serverless programming after proper consideration).</p>\n\n<p>Load balancers and HA proxy are an option for services, but they are another pain point (adding latency, failure point, management overhead of DNS switches in case of multi-region deployment etc). Service Discovery is a good option, however, it adds more learning curve.&nbsp;&nbsp;Basically, the load-balancer technique can be seen as <strong><em>Server-Side Discovery</em></strong>, and the other option is called <strong><em>Client-Side Discovery</em></strong>.&nbsp;</p>\n\n<p>Service Discovery couples the clients with the registery service. This can be eliminated by&nbsp;frameworks like <strong>Zuul</strong>.&nbsp;</p>\n\n<p>With lots of services, management, coordination becomes difficult. Use something like OpenAPI (with Swagger).</p>\n\n<p>Multiple deployments, frequent deployments problem. Use something like Gitlab, Jenkins.</p>\n\n<p>One service fails, other services dependent fail. Or one service delays, the delay grows with downstream (dependent) services. Use Circuit-Breaker pattern with something like <a href=\"https://github.com/Netflix/Hystrix\" target=\"_blank\">Hystrix</a>.</p>\n\n<p>Database per service, Schema per service, Tables per service are three options. First one is best. However, you might need to rethink how you tackle the problems in your system. You don&#39;t get cross-service transactions by default. Your best option then is eventual consistency.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"architectures","tags":null,"img":"/images/msvssoa.jpg","summary":"SOA and Microservices are both talk about \"Services\". But their use case is different, and it's not just about size of the service. See how.","lastUpdated":"2018-07-22T15:46:18.124+0000"}