{"name":"All about HTTPS in Java World","id":26,"content":"<p>When you are trying to access an a web service protected by HTTPS, you might get error if you do not prove yourself as a legit consumer of the service, in other words, the server does not trust you!</p>\n\n<p>Also, Java does not allow a connection until unless it trusts the URL it is connecting to.</p>\n\n<p><span style=\"font-size:16px;\"><span style=\"color:#8e44ad;\"><strong>So how do you make Java trust some URL? </strong></span></span></p>\n\n<p>If you&#39;re connecting using the Java SE SSL/TLS classes (e.g.&nbsp;<code>SSLSocket</code>&nbsp;or&nbsp;<code>SSLEngine</code>), you&#39;re using the&nbsp;<a href=\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html\" rel=\"nofollow noreferrer\">Java Secure Socket Extension (JSSE)</a>.</p>\n\n<p>Java will verify the remote party&#39;s certificate according to the&nbsp;<code>SSLContext</code>&nbsp;that was used to create this&nbsp;<code>SSLSocket</code>&nbsp;or&nbsp;<code>SSLEngine</code>.</p>\n\n<p>This&nbsp;<code>SSLContext</code>&nbsp;will be initialised with&nbsp;<a href=\"http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/TrustManager.html\" rel=\"nofollow noreferrer\"><code>TrustManager</code></a>&nbsp;that dictate how trust should be established.</p>\n\n<p>You can also create an&nbsp;<code>X509TrustManager</code>&nbsp;based on a custom keystore programmatically and use it in a specific&nbsp;<code>SSLContext</code>&nbsp;that doesn&#39;t affect the default one.</p>\n\n<p>&nbsp;If you&#39;re using your own protocol, you&#39;ll need to verify that the certificate you&#39;ve obtained matches the host name you were looking for (see RFC 6125). Typically, you can look for the subject alternative name in the&nbsp;<code>X509Certificate</code>&nbsp;you get (get the first peer certificate in the chain from the&nbsp;<code>SSLSession</code>), failing that, look for the&nbsp;<code>CN</code>&nbsp;RDN in the Subject Distinguished Name</p>\n\n<p>&nbsp;</p>\n\n<p>You need to add public certificate provided by that URL to Java&#39;s trust-store. If the connection is trusted by default&nbsp;&nbsp;CA certificates bundled with the JRE (usually&nbsp;<code>cacerts</code>&nbsp;file, see JSSE Reference guide), you can just use the default trust manager, you don&#39;t have to do anything special. Otherwise you have to add certificate to the keystore and trustore for Java. You can do it in many ways.</p>\n\n<p>(1) Permanently add using keystore tool supplied with JDK.</p>\n\n<p>(2) Specify using JVM parameters</p>\n\n<pre>\n<code class=\"language-java\">//Option-1: Permanently add to JRE (the one which is being used) system, using keytool\n//Remember a certificate (.cer file) is a public key with extra information such as company name, etc.\nkeytool -importcert -file certificate.cer -keystore keystore.jks -alias \"Alias\"\n\n//Option-2: Specify using JVM parameters, using command line or using Java code at startup.\n-Djavax.net.ssl.keyStoreType=pkcs12\n-Djavax.net.ssl.trustStoreType=jks\n-Djavax.net.ssl.keyStore=clientcertificate.p12\n-Djavax.net.ssl.trustStore=gridserver.keystore\n-Djavax.net.debug=ssl # very verbose debug\n-Djavax.net.ssl.keyStorePassword=$PASS\n-Djavax.net.ssl.trustStorePassword=$PASS\n\n\n\n</code></pre>\n\n<p>(3) Use custom implementation of connection.</p>\n\n<p>Essentially, get hold of the default trust manager, create a second trust manager that uses your own trust store. Wrap them both in a custom trust manager implementation that delegates call to both (falling back on the other when one fails).</p>\n\n<pre>\n<code class=\"language-java\">\nTrustManagerFactory tmf = TrustManagerFactory\n    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n// Using null here initialises the TMF with the default trust store.\ntmf.init((KeyStore) null);\n\n// Get hold of the default trust manager\nX509TrustManager defaultTm = null;\nfor (TrustManager tm : tmf.getTrustManagers()) {\n    if (tm instanceof X509TrustManager) {\n        defaultTm = (X509TrustManager) tm;\n        break;\n    }\n}\n\nFileInputStream myKeys = new FileInputStream(\"truststore.jks\");\n\n// Do the same with your trust store this time\n// Adapt how you load the keystore to your needs\nKeyStore myTrustStore = KeyStore.getInstance(KeyStore.getDefaultType());\nmyTrustStore.load(myKeys, \"password\".toCharArray());\n\nmyKeys.close();\n\ntmf = TrustManagerFactory\n    .getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(myTrustStore);\n\n// Get hold of the default trust manager\nX509TrustManager myTm = null;\nfor (TrustManager tm : tmf.getTrustManagers()) {\n    if (tm instanceof X509TrustManager) {\n        myTm = (X509TrustManager) tm;\n        break;\n    }\n}\n\n// Wrap it in your own class.\nfinal X509TrustManager finalDefaultTm = defaultTm;\nfinal X509TrustManager finalMyTm = myTm;\nX509TrustManager customTm = new X509TrustManager() {\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        // If you're planning to use client-cert auth,\n        // merge results from \"defaultTm\" and \"myTm\".\n        return finalDefaultTm.getAcceptedIssuers();\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain,\n            String authType) throws CertificateException {\n        try {\n            finalMyTm.checkServerTrusted(chain, authType);\n        } catch (CertificateException e) {\n            // This will throw another CertificateException if this fails too.\n            finalDefaultTm.checkServerTrusted(chain, authType);\n        }\n    }\n\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain,\n            String authType) throws CertificateException {\n        // If you're planning to use client-cert auth,\n        // do the same as checking the server.\n        finalDefaultTm.checkClientTrusted(chain, authType);\n    }\n};\n\n\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, new TrustManager[] { customTm }, null);\n\n// You don't have to set this as the default context,\n// it depends on the library you're using.\nSSLContext.setDefault(sslContext);\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>For prototyping you solutions, you can disable SSL verification altogether.</p>\n\n<pre>\n<code class=\"language-java\"> public static void disableCertificateValidation() {\n    // Create a trust manager that does not validate certificate chains\n    TrustManager[] trustAllCerts = new TrustManager[] { \n      new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() { \n          return new X509Certificate[0]; \n        }\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n    }};\n\n    // Ignore differences between given hostname and certificate hostname\n    HostnameVerifier hv = new HostnameVerifier() {\n      public boolean verify(String hostname, SSLSession session) { return true; }\n    };\n\n    // Install the all-trusting trust manager\n    try {\n      SSLContext sc = SSLContext.getInstance(\"SSL\");\n      sc.init(null, trustAllCerts, new SecureRandom());\n      HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n      HttpsURLConnection.setDefaultHostnameVerifier(hv);\n    } catch (Exception e) {}\n  }</code></pre>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"color:#8e44ad;\">Using Apache HTTP Client</span></h2>\n\n<p>If you have a proxy server which can be used to authenticate yourself to the server.&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">//Apache HTTP client 3.x\nHttpClient httpclient = new HttpClient();\n  httpclient.getHostConfiguration().setProxy(\"myproxyhost\", 8080);\n  httpclient.getState().setProxyCredentials(\"my-proxy-realm\", \" myproxyhost\",\n  new UsernamePasswordCredentials(\"my-proxy-username\", \"my-proxy-password\"));\n\n//Using custom SSLFactory\nclass X implements SecureProtocolSocketFactory { ... }\n\nProtocol authhttps = new Protocol(\"https\", new X(new URL(\"file:my.keystore\"), \"mypassword\",new URL(\"file:my.truststore\"), \"mypassword\"), 443); \nHttpClient client = new HttpClient();\nclient.getHostConfiguration().setHost(\"localhost\", 443, authhttps);\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"color:#8e44ad;\">Some General Confusions regarding Terminologies</span></h2>\n\n<p><strong>TrustStore</strong> and <strong>Keystore</strong><br />\n<em>&nbsp; &nbsp;</em>►<em>&nbsp;javax.net.ssl.keyStore and&nbsp;javax.net.ssl.trustStore both are used to specify keystores, but for different purposes.</em></p>\n\n<p><strong>Java TrustManager:</strong>&nbsp;determines whether remote authentication credentials (and hence the connection) should be trusted.</p>\n\n<p><strong>Java KeyManager:</strong> determines which authentication credentials should the client send to remote.</p>\n\n<p><strong>&nbsp;Keystore:</strong> is a database/store of key materials which are used for authentication and data integrity. <strong><em>PKCS12</em></strong> and <strong><em>JKS</em></strong> are types of keystores. A Key entry &nbsp;can be of two types:</p>\n\n<ol>\n\t<li>EntryID + public Key</li>\n\t<li>EntryID + private Key</li>\n</ol>\n\n<p>TrustStore contains key entries of type-1 only.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>PKCS#12</strong> and <strong>PKCS#11</strong></p>\n\n<p>&nbsp; ► PKCS#12 is a file format, PKCS#11 is an interface. PKCS#11 is a standard, an API to create and manipulate cryptographic tokens &nbsp;such as&nbsp;<a href=\"https://en.wikipedia.org/wiki/Hardware_security_module\" title=\"Hardware security module\">hardware security modules</a>&nbsp;(HSM) and&nbsp;<a href=\"https://en.wikipedia.org/wiki/Smart_cards\" title=\"Smart cards\">smart cards</a>.&nbsp;</p>\n\n<p>Encryption/Decryption: Confusion between Symmetric and Asymmetric key. Symmetric (secret key) Asymmetric (public key).</p>\n\n<p>Certificate: can be self signed or signed by CA e.g. Verisign<br />\nHandshake: Series of messages exchanged for key agreement (establish a common key).<br />\nKey exchange: One side generates a key and encrypts it using public key(generally RSA), sends it to peer, which then decrypts it using their corresponding private key. Public key and private key are cryptographic inverses, what one can encrypt only the other can decrypt.</p>\n\n<p>&nbsp;Problem in Symmetric Cryptography: A middleman who finds out the key, can pose as both the peers.<br />\n&nbsp;Problem in Asymmetric Cryptography: A middleman who finds out the public key, can read the message. But it can be used to guarantee that sender is the one who is supposed&nbsp; to be. Also, Asymmetric is slow.</p>\n\n<p>&nbsp;</p>\n","authorId":null,"subject":"linked-to-139","tags":[""],"img":null,"summary":null,"lastUpdated":"2020-03-16T12:51:37.930+0000"}