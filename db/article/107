{"name": "Spring 101", "id": 107, "content": "<p><cite>Spring is a framework that can be used as a middleware in your software systems.</cite></p>\n\n<p><strong>By the way, what is a Framework?</strong></p>\n\n<p>A Framework is basically a set of code structures (classes, functions, files, configurations etc) which is organized in a pre-defined way. And your system/application can use the framework by linking them together. You are required to follow some conventions, and it works like a magic.</p>\n\n<h2><span style=\"\"><span style=\"font-family:Georgia,serif;\">So what does Spring Framework offer, that&nbsp;can benefit your application?</span></span></h2>\n\n<p>The most important things that Spring can provide you are:</p>\n\n<ol>\n\t<li>Inversion of Control (or Dependency Injection)</li>\n\t<li>Centralizing a concern across many components of the application - Cross-Cutting Concerns <strong>(Aspect Oriented Programming)<br />\n\t&nbsp;</strong>In simple words, if something needs to be done for each service/class/method / etc.. you can put that logic in one place.</li>\n\t<li>Implementation of Dispatcher pattern to handle web requests - which simplifies things<br />\n\tIn simple words, it makes it easy to create web applications</li>\n\t<li>(Easy) Support for REST architecture implementation</li>\n\t<li>Implementation of Transaction Handling</li>\n\t<li>Nice Integration with DB Technologies in an Object-oriented way with efficient Design patterns</li>\n</ol>\n\n<h2><span style=\"\">Spring Architecture&nbsp;</span></h2>\n\n<p><span style=\"\">Spring is a huge framework, we will see its architecture in pieces, one by one.</span></p>\n\n<p><strong><span style=\"\">Spring Core Architecture</span></strong></p>\n\n<p>We will see how we can use Spring for simple use cases:</p>\n\n<ul>\n\t<li>Creating objects and configuring their dependencies in a flexible way</li>\n\t<li>Implementing Singleton pattern</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/images/container-magic.png\" style=\"width: 450px; height: 267px;\" /></p>\n\n<p><strong>What are Beans?</strong></p>\n\n<p><strong>Beans&nbsp;</strong>are simple Java objects, and once they are registered with Spring, the framework keeps track of them (<em>when they are created, when they are destroyed</em>). The framework also allows you to configure them, set their dependencies (requirements) in a flexible way (<em>just tell Spring that &#39;Car&#39; object needs &#39;Wheel&#39; object, it will find them and set in the car automatically</em>).</p>\n\n<p>The central thing in the Spring framework is Spring <strong><em>Container</em></strong>, which is represented by the interface&nbsp;<code>BeanFactory</code>. This basically presents a client&#39;s view of the Spring framework.&nbsp;You should see the Javadoc for this class which is quite explanatory in itself.&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html\" target=\"_blank\">Official Documentation Of BeanFactory</a></p>\n\n<p>The purpose here is to implement <strong>Dependency Injection</strong> and allow the most flexible way to create and use objects.</p>\n\n<p>&nbsp;</p>\n\n<p>What kind of flexibility are we talking here? - The flexibility of loading definitions (<em>configurations</em>) from XML file, properties file, etc. The flexibility of reloading bean definitions (Refreshable contexts).&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><code>ApplicationContext</code> interface adds some more capabilities in the Spring framework in addition to those provided by <code>BeanFactory</code>. Read the Javadoc for it:&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html\" target=\"_blank\">Official Documentation Of ApplicationContext</a></p>\n\n<p>You will generally be dealing with <code>ApplicationContext</code>&#39;s instead of in&nbsp;<code>BeanFactory</code> your applications.&nbsp;</p>\n\n<p>Spring provides many ways to define <em>(i.e. telling what type of bean, how to identify it)</em> and configure <em>(i.e. telling what other beans does this bean require, what is the lifecycle of it etc)</em> beans:</p>\n\n<ul>\n\t<li>Using XML config files</li>\n\t<li>Using Java classes</li>\n\t<li>Using Java annotations</li>\n</ul>\n\n<p><u>We will be looking at third option primarily.</u></p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">\n<p>Here&#39;s what you need to do to use Spring&#39;s DI (core) module in your application.</p>\n\n<ol>\n\t<li>Add Spring JARs to your project&#39;s classpath. [<span style=\"color:#8e44ad;\"><em>It&#39;s wise to do this with the help of some build tool e.g. Maven or Gradle.</em></span>]</li>\n\t<li>Create a Spring container. [<span style=\"color:#8e44ad;\"><em>By directly creating some implementation of ApplicationContext, or by adding a line in web.xml if your project is a web-project based on some web-container e.g. Tomcat, JBoss etc.</em></span>]</li>\n\t<li>Tell Spring container which classes you intend to use as Beans. [<span style=\"color:#8e44ad;\"><em>Using applicationContext.xml file, or using @Configuration and @Bean annotations.</em></span>]</li>\n\t<li>Tell Spring container which Beans you need to inject and in which places in your application. [<span style=\"color:#8e44ad;\"><em>Using @Autowire/ @Inject/ @Resource etc.</em></span>]</li>\n</ol>\n\n<p>That&#39;s pretty much it on a high-level.<br />\n<br />\nSee an example of this on Github:&nbsp;<a href=\"https://github.com/spring-by-example/spring-by-example/tree/master/core/basic-dependency-injection\" target=\"_blank\">Github Spring By Example DI</a><br />\nThe above example is focussed on XML-based configuration. In that example:&nbsp;<a href=\"https://github.com/spring-by-example/spring-by-example/blob/master/core/basic-dependency-injection/src/main/java/org/springbyexample/di/app/MessageRunner.java\" target=\"_blank\">MessageRunner.java</a>&nbsp;shows you how ApplicationContext can be used to load bean definitions from an XML file.<br />\n<a href=\"https://github.com/spring-by-example/spring-by-example/blob/master/core/basic-dependency-injection/src/main/resources/application-context.xml\" target=\"_blank\">applicationContext.xml</a>&nbsp;shows you how you can tell Spring which classes should act as Beans, what will be their name/id.&nbsp;<br />\n<a href=\"https://github.com/spring-by-example/spring-by-example/blob/master/core/basic-dependency-injection/src/test/java/org/springbyexample/di/xml/ConstructorMessageTest.java\" target=\"_blank\">ConstructorMessageTest.java</a>&nbsp;shows you how you can just tell Spring (<em>using @Autowire</em>) that you need a Bean of some type, and use it (<em>without even constructing it</em>).</p>\n</div>\n\n<p><br />\nTo configure and use beans without XML, we will use,<code>@Configuration</code><code>@ComponentScan</code>, and class&nbsp;<code>AnnotationConfigApplicationContext.</code>&nbsp;</p>\n\n<p>See an example of this on Github: <a href=\"https://github.com/trexsatya/examples/tree/master/springcore\" target=\"_blank\">Spring Core Example Java Based Configuration</a></p>\n\n<p>Read the documentation:&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html\" target=\"_blank\">Spring Official Documentation of @Configuration</a>. Here&#39;s the summary:-</p>\n\n<ul>\n\t<li>Declare configuration using @Configuration, and @Bean<br />\n\t&nbsp;- You can compose the declaration using @Import, @ImportResource<br />\n\t&nbsp;- You can nest declarations<br />\n\t&nbsp;- You can make declaration <em>profile-specific </em>(in easy words, you can have different bean definitions for different environments such as dev, qa, production).</li>\n\t<li>Trigger (bootstrap) the loading of this declaration (using XML, programatical registration, or component scanning)</li>\n\t<li>Using externalized values (maybe config parameters) from a properties file, or environment variables</li>\n</ul>\n\n<p><strong>Component-Scanning</strong>:</p>\n\n<p>Spring&nbsp;can automatically look for bean definitions and process them (<em>register</em> them with <em>the container</em>). You can tell where to look specifically if you want to help it and make this process of discovery fast. You can also tell what to exclude from discovery, what to include, some pattern to look for.<br />\nThe process of discovery of beans can be highly customized if you need so (which is not generally the case).</p>\n\n<p>See the documentation:&nbsp;<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html\" target=\"_blank\">Official Documentation Of ComponentScan</a></p>\n\n<pre>\n<code class=\"language-java\">//1. Create ApplicationContext object; \n   //You can explicitly create an ApplicationContext object \n   //For example springContainer = new ClassPathXmlApplicationContext();\n\n   //Or, you can register ContextLoaderListener provided by spring framework, this listener creates an application context (you can configure the implementation type of ApplicationContext it using context parameter with name 'contextClass'. Use AnnotationConfigWebApplicationContext if you want to see the magic of Spring\n\n//2. Declare one(more) java class as configuration class\n@Configuration\nclass ConfigOne{ }\n\n//3. Inside config classes, declare beans(the classes Spring Framework to manage and you want to use)\n@Bean\nSomeServiceForExample createIt(SomeDependency someDependency){  return new SomeServiceForExample(someDependency); }\n\n//4. Spring does the wiring/connecting of dependencies\n//5. Now you can magically get the bean, wherever you want it e.g. in class as a field, in method as a parameter\n@Autowire SomeService service;\n</code></pre>\n\n<h2><br />\n<span style=\"\"><span style=\"font-family:Georgia,serif;\">What is Inversion Of Control a.k.a. Dependency Injection?</span></span></h2>\n\n<p>Actually, &quot;control&quot; is a wrong word used here, it should be replaced by &quot;responsibility&quot;.</p>\n\n<p><em>&quot;Inversion of Responsibility&quot;</em>&nbsp;means that it is no longer your responsibility to create (actually <strong>&quot;shape-up&quot;</strong> ) something. It is the responsibility of the framework to give you the <strong>shaped-up</strong>&nbsp;object to you when you ask for it.</p>\n\n<p>There are many ways to ask for it.</p>\n\n<pre>\n<code class=\"language-java\">//Need a mail sender? Just ask for it!\n\n@Autowired\nMailSender mailSender;\n\n//There is another way that perform same task, but in a different fashion \n//and it has nothing to do with Spring, it is available in JSR-330 Jar\n@Inject\nMailSender mailSender;\n\n//Or\n//Available in JSR-250 Jar\n@Resource\nMailSender mailSender;\n\n/** WHATS THE DIFFERENCE AMONG THESE\n* \n* The difference is in how they select a bean from possible candidates\n* @Autowired will first look for beans of type MailSender, if there is single such bean, No Problem\n* But if there are multiple beans of type MailSender, it tries to filter one by name\n* If no match is found based on Bean name, it throws eception.\n*     You can tell Spring which bean name you are looking for using @Qualifier(\"desiredBeansName\") annotation\n*\n* @Inject does the same thing in same fashion. But unlike @Autowired, it does not allow you to specify optional dependencies. e.g You can say @Autowired(required=false) \n*    But you can't say @Inject(required=false)\n* Also, @Inject allows you to use Provider&lt;MailSender&gt; which will be used to get() desired MailSender\n*\n* @Resource will try to find single bean by name first, then if there are zero or multiple candidates, it tries to find/filter by type of the bean. You can use @Qualifier here also.\n*\n**/\n\n</code></pre>\n\n<p>The term &quot;Autowire&quot; clearly tells that <strong>&quot;mailSender&quot;&nbsp;</strong>will be <em>Automatically Wired-In </em>inside your class&#39;s object. Spring will scan all the beans <strong>registered </strong>to it and will wire-in one that matches.&nbsp;If more of the beans match (i.e. there are more than one bean instances of type MailSender) then Spring will get confused and will throw an exception.</p>\n\n<p>Notice the term <strong>&quot;register&quot;&nbsp;</strong>in the above line. You see Spring beans are just normal Java class objects. So you have to tell Spring that which Java obejct should be treated as a Spring bean.</p>\n\n<pre>\n<code class=\"language-java\">ConfigurableListableBeanFactory beanFactory = ((ConfigurableApplicationContext) applicationContext).getBeanFactory();\nbeanFactory.registerSingleton(yourJavaObject.getClass().getCanonicalName(), yourJavaObject);</code></pre>\n\n<p>There is another way to register beans.</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\nclass ThisClassWillRegisterAllBeansRequired{\n   @Bean\n   YourJavaClass anything(){\n     //Create YourJavaClass anyhow\n     return new YourJavaClass()\n   }\n}</code></pre>\n\n<p>There is another way to register bean.</p>\n\n<pre>\n<code class=\"language-java\">@Component\npublic class YourJavaClass {\n\n}\n\n//And then tell Spring to automatically find all the Java classes having @Component annotation and create an object of that class, and register it as a Spring bean.\n\n</code></pre>\n\n<p><strong>But how would you tell Spring to find all the @Component classes, create an instance and register them as a bean?</strong></p>\n\n<p>There are two ways to do that:</p>\n\n<p><strong>XML Way</strong>: Use an ApplicationContext instance to read your xml files, which define which classes might possibly have this @Component annotation</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext context = new FileSystemXmlApplicationContext(\"c:/beans-defined-here.xml\");\n\nApplicationContext context = new ClassPathXmlApplicationContext(\"beans-defined-here.xml\");\n\n//The second context instance will look for this file on the classpath, even inside JAR files.\n\n//And inside \"beans-defined-here.xml\" file\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt;\n\n\t&lt;context:component-scan base-package=\"x.y.z\" /&gt;\n&lt;!-- The package which might contain Java classes with @Component annotation --&gt;\n\n&lt;/beans&gt;\n\n\n</code></pre>\n\n<p><span class=\"marker\"><big><strong>Java Way:</strong> Use an ApplicationContext instance to read your Java classes which define&nbsp;which classes might possibly have the&nbsp;@Component annotation</big></span></p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext context = new AnnotationConfigApplicationContext(x.y.ThisClassDefinesSpringConfigurations.class);\n\n//and\n\n@ComponentScan(basePackages={\"a.b.c\", \"x.y.z\"})\n//If no package is specified the package containing this class itself is considered\nclass ThisClassDefinesSpringConfigurations {\n\n}\n//There are many ways to control this, like which class should be ignored by Spring while it is searching for classes in the packages specified etc.</code></pre>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"\"><span style=\"font-family:Georgia,serif;\">So what does Spring do when you give it the responsibility of creating beans and managing them?</span></span></h2>\n\n<p>When you give the responsibility of managing a bean to Spring it does the following:</p>\n\n<p>(1) Create the bean instance&nbsp;</p>\n\n<p>(2) Injects values and bean references which are available.</p>\n\n<p>(3) Fills the bean object with all the details that you want ( you tell this by implementing some interfaces e.g. if you want bean ID&nbsp;or name (both are same thing) inside your beans object, then implment <code>BeanNameAware</code> )</p>\n\n<p>&nbsp; &nbsp; Similarly there are <code>BeanFactoryAware</code>, <code>ApplicationContextAware</code> interfaces, however, you can get the same thing by <code>@Autowire</code>&#39;ing them inside bean class.</p>\n\n<p>(4) Again, at this step before the initialization completes, you can command Spring to do something to beans constructed so far, Spring&nbsp;processes <code>BeanPostProcessor</code> interface if available and calls its <code>postProcessBeforeInitialization()</code> method</p>\n\n<p>(5) Till now all the initialization tasks have been done by Spring, so Spring now gives you a chance to do some extra initialization work. Spring will call&nbsp;<code>afterPropertiesSet()</code> method of&nbsp;InitializingBean interface if available and/or init method specified (specified either in XML configuration file or using a <code>@PostConstruct</code> method in bean class)</p>\n\n<p>(6) Now the initialization task has been done by Spring, it calls&nbsp;<code>postProcessAfterInitialization()</code> method of&nbsp;<code>BeanPostProcessor</code> if available.</p>\n\n<p>(7) Finally, when the context is being destroyed, Spring calls <code>destroy()</code> method <code>DisposableBean</code> interface if available, and/or <code>@PreDestroy</code>&nbsp;method inside bean class.</p>\n\n<p>So if all the interfaces are available Spring proceeds in this flow:</p>\n\n<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">create-instance &nbsp;<strong>&rArr;</strong>&nbsp;inject values and references <strong>&rArr;</strong>&nbsp;set bean name, application-context, bean-factory <strong>&rArr;</strong>&nbsp;processBeforeInitialisation <strong>&rArr;</strong>&nbsp;init, PostConstruct <strong>&rArr;</strong>&nbsp;processAfterInitialisation <strong>&rArr;</strong>&nbsp;destroy, PreDestroy</div>\n\n<h2><br />\n<span style=\"color:#2c3e50;\"><span style=\"font-family:Georgia,serif;\">Will Spring give you&nbsp;same bean instance every time you&nbsp;ask for it?</span></span></h2>\n\n<p>So far what you have discovered is that Spring creates a bean instance, stores it in the container, and gives you the instance after searching it. Yes, it will give you same bean instance everytime you ask for it IF you don&#39;t do anything about it.</p>\n\n<p>You can change this behavior by using a different scope while declaring your bean configuration.</p>\n\n<pre>\n<code class=\"language-java\">@Bean\n@Scope(\"prototype\")\nMailSender mailSender;\n\n\n@Scope(\"prototype\")\n@Component\nclass MailSender { .. }\n\n//Now, whenever you ask for a mailSender, you will get a new instance of MailSender</code></pre>\n\n<p>There are other four&nbsp;scopes: Request-scope,&nbsp;Session-scope, Global-Session-Scope, and Application-Scope; but these are relevant only in case of a web-application. That is when you use WebApplicationContext instead of ApplicationContext</p>\n\n<p>Spring also allows you to create custom scopes.</p>\n\n<p>There is another problem /scenario regarding scopes. What happens when a higher-scope bean requires a lower-scope bean e.g. a <em>Request-scoped bean is required in a Session-scoped bean</em> or a <em>Session-scoped bean in a Singleton-scoped bean</em> etc. For Example: when a singleton bean is initialized by Spring which requires a session scoped bean, at that time session scope bean would not have been created (it would not be created unless a user comes and starts a session). So, to solve this Spring makes a Proxy and injects that proxy instead of required dependency. This proxy will allow you to do everything that required bean is capable of.</p>\n\n<pre>\n<code class=\"language-java\">@Bean\n@Scope(\n      value=WebApplicationContext.SCOPE_SESSION, \n      proxyMode=ScopedProxyMode.INTERFACES)\npublic ShoppingCart cart() { .. }</code></pre>\n\n<h2><br />\nHow can we customize Spring&#39;s behavior?</h2>\n\n<p>Spring provides many extension points.</p>\n\n<ul>\n\t<li>You can have lifecycle methods inside beans (@<code>PostConstruct</code>, @<code>PreDestroy</code>, init, destroy), defaul-init, default-destroy methods for all beans.</li>\n\t<li>You can have <code>BeanPostProcessor</code>s. (Spring itself uses many BeanPostProcessors to enhance it&#39;s capabilities e.g. <code>RequiredAnnotationBeanPostProcessor, AutowiredAnnotationBeanPostProcessor, MockitoPostProcessor</code>)</li>\n\t<li>You can have&nbsp;<code>BeanFactoryPostProcessor</code>s, which can be used to customize the bean configuration metadata that is used to create beans. (Spring itself uses many of these to enhance its functionalities e.g. <code>ConfigurationClassPostProcessor</code> )</li>\n\t<li>You can implement&nbsp;<code>FactoryBean</code>&nbsp;</li>\n</ul>\n\n<h2>Can We Make Classpath Scanning Faster?</h2>\n\n<p><strong>Yes</strong>, To make classpath scanning faster:</p>\n\n<ul>\n\t<li>Use filters</li>\n\t<li>Generate a static index of candidates at compile time.</li>\n</ul>\n\n<p>You will need to add this dependency to your project:&nbsp;</p>\n\n<pre>\n<code data-lang=\"groovy\">org.springframework:spring-context-indexer:5.1.0.RELEASE</code></pre>\n\n<p>That process generates a&nbsp;<code>META-INF/spring.components</code>&nbsp;file that is included in the jar file.&nbsp;The index is enabled automatically when a&nbsp;<code>META-INF/spring.components</code>&nbsp;is found on the classpath. If an index is partially available for some libraries (or use cases) but could not be built for the whole application, you can fallback to a regular classpath arrangement (as though no index was present at all) by setting&nbsp;<code>spring.index.ignore</code>&nbsp;to&nbsp;<code>true</code>, either as a system property or in a&nbsp;<code>spring.properties</code>&nbsp;file at the root of the classpath.</p>\n\n<h2>What are Profile and Environment useful for?</h2>\n\n<p>Can we register different beans for different environments?</p>\n\n<p><strong>Yes.</strong> Bean definition profiles provide a mechanism in the core container that allows for registration of different beans in different environments. The word, &ldquo;environment,&rdquo; can mean different things to different users, and this feature can help with many use cases, including:</p>\n\n<ul>\n\t<li>\n\t<p>Working against an in-memory datasource in development versus looking up that same datasource from JNDI when in QA or production.</p>\n\t</li>\n\t<li>\n\t<p>Registering monitoring infrastructure only when deploying an application into a performance environment.</p>\n\t</li>\n\t<li>\n\t<p>Registering customized implementations of beans for customer A versus customer B deployments.</p>\n\t</li>\n</ul>\n\n<p>Environment basically provides a seamless API to workf with profiles and properties (there could be different ways to configure properties:&nbsp;properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc&nbsp;<code>Properties</code>&nbsp;objects,&nbsp;<code>Map</code>&nbsp;objects, and so on.)</p>\n\n<pre>\n<code class=\"language-java\" data-lang=\"java\">@Configuration\npublic class AppConfig {\n\n    @Bean(\"dataSource\")\n    @Profile(\"development\") \n    public DataSource standaloneDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.HSQL)\n            .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n            .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n            .build();\n    }\n\n    @Bean(\"dataSource\")\n    @Profile(\"production\") \n    public DataSource jndiDataSource() throws Exception {\n        Context ctx = new InitialContext();\n        return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n    }\n}</code></pre>\n\n<p>We can then activate the desired profile:</p>\n\n<ul>\n\t<li>Programmatically <code>appContext.getEnvironment().setActiveProfiles(&quot;..&quot;)</code></li>\n\t<li><em>spring.profiles.active</em> (in a properties file, environment variable,&nbsp;JVM system properties,&nbsp;servlet context parameters in,<code>web.xml</code> or even as an entry in JNDI)</li>\n\t<li><em>spring.profiles.default </em> property if no other profiles are activated</li>\n</ul>\n\n<p><code data-lang=\"java\">@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)</code> can be used to add properties to Spring&#39;s Environment.</p>\n\n<h2>Can we inject non-Spring POJOs in Spring beans?</h2>\n\n<p><strong>Yes</strong>, we can have this feature with two extra steps.&nbsp;</p>\n\n<ol>\n\t<li>Declare which POJO classes need to be managed&nbsp;</li>\n\t<li>Use AspectJ library to make this work</li>\n</ol>\n\n<pre>\n<code class=\"language-java\">@Configurable(autowire=Autowire.BY_NAME, \n   dependencyCheck=true, //to check that all properties have been injected\n   preConstruction=true  //If you want to use autowired properties inside constructor\n)\npublic class Account {\n    // ...\n}</code></pre>\n\n<p>Simply declaring this annotation does nothing. You will&nbsp;need&nbsp;<code>AnnotationBeanConfigurerAspect</code> in action which is available in spring-aspects.jar.&nbsp;</p>\n\n<p>For this to work, the annotated types must be woven with the AspectJ weaver. You can either use a build-time Ant or Maven task to do this (see, for example, the&nbsp;<a href=\"https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html\">AspectJ Development Environment Guide</a>) or load-time weaving (see&nbsp;<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-aj-ltw\">Load-time Weaving with AspectJ in the Spring Framework</a>). The&nbsp;<code>AnnotationBeanConfigurerAspect</code>&nbsp;itself needs to be configured by Spring (in order to obtain a reference to the bean factory that is to be used to configure new objects).&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\n@EnableSpringConfigured //Equivalent to &lt;context:spring-configured/&gt;\npublic class AppConfig {}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p>For further details, visit official documentation:&nbsp;<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans\" target=\"_blank\">Official Documentation Spring Core IoC</a></p>\n\n<p>&nbsp;</p>\n\n<h2>Spring Transactions</h2>\n\n<p>https://codete.com/blog/author/michal-marciniec</p>\n", "authorId": 1, "subject": "linked-to-136", "tags": [], "img": "", "summary": "", "lastUpdated": "2021-06-16 19:38:11.269530"}