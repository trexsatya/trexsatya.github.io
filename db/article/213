{"name":"Java 8 Marvels","id":213,"content":"<h2>Overview</h2>\n\n<p>Java 8 offers some radical changes, which change the way we write programs (from pure object-oriented style to functional style). We will be looking at following new features added in Java 8:</p>\n\n<ol>\n\t<li><strong>Default Methods</strong> - You will now have less classes to write.<br />\n\t(Remember default methods bring back <a href=\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\" target=\"_blank\">Diamond Problem</a> into Java)</li>\n\t<li><strong>Lambdas and Functional Interfaces</strong> - You will now have to write less code.</li>\n\t<li><strong>Optionals</strong> - you will now have less headache dealing with NullPointerException&#39;s.</li>\n\t<li><strong>Streams</strong> (for bulk data processing) - you will now have less headache adding concurrency support while processing datastructures.</li>\n</ol>\n\n<h2><br />\n(1) Default Methods in interfaces:</h2>\n\n<p><strong><span style=\"color:#8e44ad;\">What does it look like?</span></strong><br />\n&nbsp;</p>\n\n<pre>\n<code class=\"language-java\"> interface MyService{\n   default void somethingWhichCanHaveDefaultImplementation(){\n     //implement here\n   }\n\n   void otherInterfaceMethods();\n}</code></pre>\n\n<p><br />\n<span style=\"color:#8e44ad;\"><strong>What&#39;s the benefit?&nbsp;</strong></span></p>\n\n<p>There are two main benefits of default methods in interfaces:</p>\n\n<ol>\n\t<li>You can make your library backward compatible. Because adding default methods do not require you to implement them in all the existing implementer classes.<br />\n\t<a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\" target=\"_blank\">From Oracle website</a>:&nbsp;<cite>Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces. <em>So you do not have to modify the implmentation classes when you are adding a default method.&nbsp;</em></cite><br />\n\tJDK itself has added many methods using this for example forEach(..) method in Collection interface.<br />\n\t&nbsp;</li>\n\t<li>You do not have to write adapter classes which just served the purpose of providing convenient adapter to large interfaces. For example:\n\t<pre>\n<code class=\"language-java\">//Suppose you are building a GUI using Java AWT.\nbutton.addMouseListener(new MouseAdapter(){\n    public void mouseClicked(Event e){ \n        //....\n    }\n})</code></pre>\n\n\t<p><br />\n\tHere &#39;MouseAdapter&#39;&nbsp;class is nothing but a skeleton abstract class which provides default implemention of&nbsp;all the methods of interface &#39;MouseListener&#39;&nbsp;etc. With Java 8, it is no longer necessary, you can provide default implementation in MouseListener interface itself.</p>\n\t</li>\n</ol>\n\n<p>Without even using abstract classes you can now have convenient methods, can implement template pattern.&nbsp;</p>\n\n<h2><br />\n(2) Lambdas And Functional Interfaces</h2>\n\n<p>You know about interfaces, right? So whats so special about functional interfaces?</p>\n\n<p>Not much in the looks:</p>\n\n<pre>\n<code class=\"language-java\">interface MyFunctionalInterface {\n  Y doSomething(X x);\n}</code></pre>\n\n<p><br />\nThe above is a functional interface. Does it look different from any normal interface?&nbsp;NO. But it has just one function which is not defined. Any interface which has one and only one <em>UNIMPLEMENTED</em>&nbsp;function is a functional interface. Why this name? Maybe because it indicates that this interface is meant for one &quot;function&quot; (one piece of work).</p>\n\n<p>Earlier before Java 8 if you wanted to implement this interface, you would have to do something like this:</p>\n\n<pre>\n<code class=\"language-java\">class MyImplOfFunction implements MyFunctionalInterface{\n  Y doSomething(X x){ ... }\n}</code></pre>\n\n<p><br />\nBut in Java 8, you don&#39;t have to do that, you can implement it in this way:</p>\n\n<pre>\n<code class=\"language-java\">MyFunctionalInterface myImplOfFunction = x -&gt; new Y();\n//Or\nMyFunctionalInterface myImplOfFunction = x -&gt; { Y y = new Y(); return y; }\n</code></pre>\n\n<p><br />\nThe above is called lambda expression.<br />\n&nbsp;</p>\n\n<p><strong><span style=\"color:#8e44ad;\">More on How does lambda look like?</span></strong></p>\n\n<pre>\n<code class=\"language-java\">Runnable task = ()-&gt; System.out.println(\"A simple task to print\");\n\nCallable&lt;String&gt; taskWhichReturnsSomething = ()-&gt; {\n    System.out.println(\"Do the task and\");\n    return \"Something\";\n}\n\nnew Thread(task).start();\nnew Thread(taskWhichReturnsSomething).start();</code></pre>\n\n<p><br />\n<span style=\"color:#2980b9;\"><strong>What&#39;s the benefit?</strong></span></p>\n\n<p>Apart from looking beautiful, passing the behavior is now easier. Implementing command pattern, strategy pattern is easier. Want to learn more about patterns? <a href=\"#\" reactlink=\"/article/69\">Click</a>.</p>\n\n<p><strong><span style=\"color:#8e44ad;\">How does it internally work?</span> </strong><a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\" target=\"_blank\">See here</a></p>\n\n<pre>\n<code class=\"language-java\">new Thread( ()-&gt; doSomeTask()).start();\n\nbutton.addEventListener( event -&gt; { ... });</code></pre>\n\n<p><br />\nThere might be scenarios where it&#39;s not easy to write lambdas. Because the type of lambda is determined from the&nbsp;context.</p>\n\n<p><strong>Method Reference</strong>s further simplify lambdas, when there is only one statement in lambda body and that is just a method invocation, you can use method reference instead of lambda.</p>\n\n<pre>\n<code class=\"language-java\">Arrays.asList(1,2,3).forEach( x -&gt; System.out.println(x))\n//Replace with Method reference\nConsumer&lt;Object&gt; print = System.out::println; //Can be reused in many places\n\nArrays.asList(1,2,3).forEach( x -&gt; print) //x will be passed automatically\nprint.apply(12); //can also be passed explicitly\n</code></pre>\n\n<h2><br />\n(3) Supplier, Predicates, Functions etc</h2>\n\n<p>Supplier, Predicate, Function, BiFunction are nothing but some simple functional interfaces which JDK provides you already so that you are saved from writing your own functional interfaces for typical use cases.</p>\n\n<pre>\n<code class=\"language-java\">//Supplier; When you want to get data, supplier supplies it without asking for anything.\njava.util.Supplier numberSupplier = () -&gt; 5;\n//To get data, you just need to ask\nnumberSupplier.get(); //returns 5\n</code></pre>\n\n<p><br />\nA Predicate is a function to which you pass something and it returns true or false.</p>\n\n<pre>\n<code class=\"language-java\">//When you want to put some data/object to test, e.g. you want to validate it\nPredicate&lt;String&gt; isValid = x -&gt; x.isEmpty();\n//Now you can test any string using this\nisValid.test(\"str\"); //returns false</code></pre>\n\n<p><br />\nThis is a very simple thing, you could do with just an ifelse, but predicate provide you more power, e.g.</p>\n\n<pre>\n<code class=\"language-java\">isValid.negate().test(\"str\"); //returns true\nisValid.or(someOtherPredicate).and(yetAnotherPredicate)\n\n//You can chain many predicates\n//You might also think that this could also be done with ifelse and logical operators, but predicates allow you to store this testing behavior, and pass it around to other method/classes.</code></pre>\n\n<p><br />\n<strong>Functions</strong></p>\n\n<pre>\n<code class=\"language-java\">Function&lt;String,Integer&gt; toInteger = s -&gt; Integer.parseInt(s);\n\n//Now you can use this function to transform string into number, you can also pass it to some other class/method which wants to use this functionality.\ntoInteger.apply(\"1\"); //returns 1\n\n//Just like predicates function also allows chaining\nFunction&lt;Integer,Integer&gt; increaseByTwo = x -&gt; x+2;\n\ntoInteger.andThen(increaseByTwo).apply(\"1\"); //returns 3</code></pre>\n\n<p><br />\nIs there any benefit from this?</p>\n\n<p>Apart from looking cool, all the benefits are debatable. One benefit is that it enforces (not completely&nbsp;but to some extent) Functional Programming approach which makes software&nbsp;less prone to bugs. (How? try to modify something from inside function definition, it will not allow; only final variables are allowed <q>Error:: local variables referenced from a lambda expression must be final or effectively final</q>. Although you can easily work around this and be able to modify the state. But it clearly does not want you to. One of the primary flavours of Functional Programming approach is that it stops you from modifying state, which makes software&nbsp;less susceptible to errors and bugs. Learn more about functional programming here: <u><a href=\"#\" reactlink=\"/article/68\">Functional Programming</a></u>.&nbsp;</p>\n\n<h2><br />\n(4) Optionals</h2>\n\n<p><strong>How does it look like?</strong></p>\n\n<pre>\n<code class=\"language-java\">Optional.ofNullable(a).flatMap(nullableA -&gt; nullableA.getB()).flatMap(nullableB -&gt; nullableB.getC()).map(nullableC -&gt; nullableC.getD());\n\n//The whole chaining is null safe.</code></pre>\n\n<p><br />\nYou must have seen code like this:</p>\n\n<pre>\n<code class=\"language-java\">User user = getUser();\nif(user != null){\n   if(user.getContactInfo() != null) {\n     ContactInfo info = user.getContactInfo();\n     if(info != null) {\n       Address address = info.getAddress();\n       if( address != null) {\n         String city = address.getCity();\n       }\n     }\n   }\n}</code></pre>\n\n<p><br />\n<strong>Whats wrong with this code?</strong></p>\n\n<p>Nothing, but just to get city name, we had to go through so many null-checks. And also someone could easily forget to put null-check ( <em>if (x != null)</em> ), and the code will break. Java 8 provides you with a better way to handle these kinds of scenarios.</p>\n\n<p>If I have Optional&lt;String&gt; name; It clearly indicates that name can be null. Also optional is helpful by reducing the amount of code that we have to write when we chain multiple method calls.</p>\n\n<pre>\n<code class=\"language-java\">class A{ B b; }\nclass B{ C c; }\nclass C{ String name; }\n\nnew A().b.c.name;\n//To prevent from NullPointerException we have to null-check all of these references.\n//like if(a.b != null &amp;&amp; a.b.c != null ) print(a.b.c.name);\n\n//If instead we had\nclass B{ Optional&lt;C&gt; c = Optional.empty();}\nclass C{ Optional&lt;String&gt; name = Optional.empty();}\nclass A{ Optional&lt;B&gt; b = Optional.empty();}\n\n//This will never throw NullPointerException\n\nOptional&lt;A&gt; optA = Optional.of(a);\nOptional&lt;String&gt; name = optA.flatMap(xa -&gt; xa.b).flatMap(xb -&gt; xb.c).flatMap(xc -&gt; xc.name);\nSystem.out.println(name);\n\n//What flatMap does? It converts Optional&lt;Optional&lt;...&lt;T&gt;..&gt; into Optional&lt;T&gt;\n\n</code></pre>\n\n<h2><br />\n(5) Streams</h2>\n\n<p><strong>How does it look like?</strong></p>\n\n<pre>\n<code class=\"language-java\">//Readable and fluent API\nstream(1,2,3,4,5,6,7).filter(oddNumbers)\n    .map(doubleIt).forEach(print);\n\n//Easy to do some operations in parallel(you don't even need to use threads here)\nasList(values).stream().\n    .filter(relevant)\n    .parallel()\n    .map(callAPI)\n    .collect(toList())</code></pre>\n\n<p><br />\n<strong>When to use?</strong></p>\n\n<p>&nbsp; Whenever you are dealing with collections (lists, sets, map etc) you can use streams. Streams provide you easy, fluent way to process data. Normally data processing involves three tasks:&nbsp;</p>\n\n<ol>\n\t<li>Filtering based on some condition (using <em><strong>filter</strong></em>&nbsp;pipeline)</li>\n\t<li>Transforming the filtered data (using <em><strong>map</strong></em> pipeline)</li>\n\t<li>Collecting the transformed data into a new datastructure (using <em><strong>collect</strong></em> method)</li>\n</ol>\n\n<p>We are saying <em>pipeline</em>&nbsp;not method, because when you call .filter(relevant), you are not actually filtering the data at that time, the stream will just remember that you want to filter data using passed predicate. The actual filtering will be done when you call <em><strong>collect</strong></em> method. collect and similar methods are called Terminal operations (in the pipeline, they end the pipeline and give output).&nbsp;</p>\n\n<p><img alt=\"\" src=\"/images/streams.png\" style=\"text-align: center; width: 407px; height: 207px;\" /></p>\n\n<p>Streams provide you a simple way to do all these and also you can perform any of this using multiple threads taking benefit of parallel processing without even writing a single thread. Streams API will handle concurrency for you automatically.</p>\n\n<p><strong>What&#39;s the benefit?</strong></p>\n\n<p><span style=\"color:#2980b9;\">&nbsp; - Declarative style, readable, expressable&nbsp;code</span></p>\n\n<p><span style=\"color:#2980b9;\">&nbsp; - Streams derive the benefits of functional coding. Although they do not enforce immutability, but still they encourage it.</span></p>\n\n<p><strong>How to create streams?</strong></p>\n\n<pre>\n<code class=\"language-java\">//Examples:\nanyCollection.stream();\nStream.of(1,2,3);\nArrays.stream(new int[]{1,2}, 3);\nStream.generate(() -&gt; \"a\").limit(10); //stream with 10 a's \nStream.iterate(10, n -&gt; n+2).limit(20); //10,12,14,...\nIntStream.range(1,3);\nIntStream.rangeClosed(1,3)\nPattern.compile(\"\").splitAsStream(\"abc\"); //a,b,c\nFiles.lines(Paths.get(locationOfFile)).reduce((a,b)-&gt; a+\"\\n\"+b); //reads text from file\n\n//controls\nlimit(n)\nskip(n)\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Data Processing With Streams</strong></p>\n\n<pre>\n<code class=\"language-java\">createStream().\n   //...pipelines\n   .collect(averagingInt(..)) //or\n   .collect(summingInt(..))\n   .collect(summarizingInt(..))\n\n   .collect(groupingBy(Type::getter)\n   .collect(groupingBy(Type::getter, toSet())\n   .collect(groupingBy(Type::getter, groupingBy(Type::anotherGetter))\n   .collect(groupingBy(Type::getter, maxBy(cmparingInt(Type::intGetter)))\n   .collect(groupingBy(Type::getter, mapping(Type::getter, joining(...)))\n\n   .collect(toMap(streamItemToKeyFunction, streamItemToValueFunction, functionToSelectWhenTwoValuesMapToSameKey, supplierWhichGivesMapInstance))\n</code></pre>\n\n<h2><br />\nRefactor your existing code to Java-8</h2>\n\n<p>Replace&nbsp; Variable-ForLoop-IfElse-Continue-Break pattern</p>\n\n<pre>\n<code class=\"language-java\"> Article matchingOne = null;\n for (Article article : articles) {\n   if (article.getTags().contains(\"Java\")) {\n     matchingOne = article;\n     break;\n   }\n }\n\n// can become:\n articles.stream().filter(article -&gt; article.getTags().contains(\"Java\"))\n        .findFirst();\n// by extracting some code from inside, it could become more readable\n articles.stream().filter(articlesTaggedWith(\"Java\"))\n        .findFirst();\n\n Predicate&lt;Article&gt; articlesTaggedWith(String s){\n   return article -&gt; article -&gt; article.getTags().contains(s);\n }\n\n//This readability is not solely because of Java 8, even before Java 8 you could extract/refactor code and make code more readable but Java 8 helps in this process</code></pre>\n\n<p><br />\nReplace List-ForLoop-IfElse pattern</p>\n\n<pre>\n<code class=\"language-java\">List&lt;Article&gt; result = new ArrayList&lt;&gt;();\n\nfor (Article article : articles) {\n\tif (article.getTags().contains(\"Java\")) {\n\t\tresult.add(article);\n\t}\n}\n\n//can become\narticles.stream()\n    .filter(articlesTaggedWith(\"Java\"))\n    .collect(Collectors.toList());</code></pre>\n\n<p><br />\nReplace Map-ForLoop-IfElse&nbsp;pattern</p>\n\n<pre>\n<code class=\"language-java\">//arrange all articles written by some author\nMap&lt;String, List&lt;Article&gt;&gt; result = new HashMap&lt;&gt;();\n\nfor (Article article : articles) {\n\tif (result.containsKey(article.getAuthor())) {\n\t\tresult.get(article.getAuthor()).add(article);\n\t} else {\n\t\tArrayList&lt;Article&gt; articles = new ArrayList&lt;&gt;();\n\t\tarticles.add(article);\n\t\tresult.put(article.getAuthor(), articles);\n\t}\n}\n\n//can become\narticles.stream()\n        .collect(Collectors.groupingBy(Article::getAuthor));\n\n//assign a unique random id to each article\narticles.stream()\n        .collect(Collectors.toMap(x -&gt; uuid.nextUUId(), x -&gt; x));\n</code></pre>\n\n<p><br />\nReplace List-ForLoop-List-Break pattern</p>\n\n<pre>\n<code class=\"language-java\">//Get all tags used in all articles\nSet&lt;String&gt; result = new HashSet&lt;&gt;();\nfor (Article article : articles) {\n\tresult.addAll(article.getTags());\n}\n\n//can be replaced by\narticles.stream()\n  .flatMap(article -&gt; article.getTags().stream())\n  .collect(Collectors.toSet());</code></pre>\n\n<p><br />\nSometimes replacing with Java 8 code makes code harder to read</p>\n\n<pre>\n<code class=\"language-java\">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);\n \nfor (Integer i : list)\n   for (int j = 0; j &lt; i; j++)\n       System.out.println(i * j);\n//can be, but should not be replaced with this\nlist.forEach(i -&gt; {\n    IntStream.range(0, i).forEach(j -&gt; {\n        System.out.println(i * j);\n    });\n}); \n\n//but there is a better way\nlist.forEach(number_i -&gt; {\n    numbersLessThan(number_i).forEach(j -&gt; {\n        System.out.println(number_i * j);\n    });\n});\nIntStream numbersLessThan(int i){ return IntStream.range(0, i); }</code></pre>\n\n<p>&nbsp;</p>\n\n<p><input type=\"hidden\" value=\"nhbj\" /></p>\n","authorId":null,"subject":"programming","tags":["prity=2"],"img":null,"summary":"Java 8 changes the way you program. It also tries to forces you into thinking new approach of solving a problem (functional programming approach).","lastUpdated":"2020-06-09T10:01:06.760+0000"}