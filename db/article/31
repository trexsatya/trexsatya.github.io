{"name": "Mastering GIT as Version Control System", "id": 31, "content": "<div style=\"background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;\">Note: This article is a summary. There is a lot in GIT to master. Follow this link to learn more:&nbsp;<a href=\"https://services.github.com/on-demand/\" target=\"_blank\">https://services.github.com/on-demand/</a></div>\n\n<p><br />\n<span style=\"color:#8e44ad;\"><u>Purpose and Problems that GIT solves:</u></span></p>\n\n<ul>\n\t<li>Save your work (using git commit command), you can come back to this saved work any time in future (using git checkout)</li>\n\t<li>Maintain many versions of your work simultaneously (using branches)</li>\n\t<li>Upload your work (using push), Share your work. There will be many copies of your work once other people download (using pull) your work on their machines.</li>\n\t<li>Do all this in efficient manner, using less storage as possible.</li>\n</ul>\n\n<p><span style=\"color:#8e44ad;\"><u>GIT Terminologies:</u></span></p>\n\n<p><strong>Stage</strong>: You have to tell which files that you modified, should be considered for saving when you commit, this is called <em>staging</em>.</p>\n\n<p><strong>Commit</strong>: Git commit command saves your work (specifically the files staged) and gives you a unique hash ID for this savepoint.</p>\n\n<p><strong>Repository</strong>: Collection of commits, and branches and tags to identify commits.</p>\n\n<p><strong>Tag</strong>: just a reference to a particular commit.</p>\n\n<p><strong>Working Tree</strong>: tree of actual checked out files</p>\n\n<p><strong>Branch and head</strong>: Just a label which points to a commit, head of branch tracks the latest commit in branch. Branch by default is only local to your repository.</p>\n\n<p><strong>Cache/index</strong>: Collection of files in working tree with stat information in form of objects.&nbsp;</p>\n\n<p><strong>Checkout</strong>: update the working tree (partly or fully), using a tree object/blob from object database (.git folder). I also updates index and HEAD if whole working tree has been pointed to a new branch.</p>\n\n<p><strong>Detached HEAD</strong>: when HEAD does not point to tip of any branch, but instead points to some commit in history.</p>\n\n<p><strong>Fetch</strong>: Get branches head ref from remote repository to find out which objects are missing from local object database and get them too.</p>\n\n<h2>Typical GIT Usage Scenario</h2>\n\n<p>Using GIT Command Line:</p>\n\n<pre>\n<code class=\"language-javascript\">git init folder-name\ncd folder-name\n//create files\ngit add -A //Stage files\ngit commit -m\"initial commit\"\n\ngit status //It will show that you are on master branch, and git has added your files in its object database\n\ngit branch -b feature-1 //Creates a branch in which you will make changes regarding some work ex. new feature\n\n//You can have many such feature branches\n\n//Once your feature is complete, you are satisfied with implementation,  you will want to merge that into master branch and then delete feature branch.\ngit checkout master\ngit merge feature-x\n\ngit branch -D feature-x //Delete branch if you are sure\n\n//You want to make your code available to others, but you also want to make sure that you have the changes that others have worked on\ngit fetch master\ngit merge master //Might cause conflict in some cases\n\n//Sometimes you have messed up, and want to clean things up and you don't care about local works that you have done\ngit fetch --all\ngit reset --hard origin/master\n\n//But still, make sure to stash local changes so you can grab them back, just in case\ngit stash --include-untracked\n\ngit stash list //to check stashed things\ngit stash drop stash@{0} //To drop selectively\ngit stash clear //to clear\n\ngit stash apply stash@{5} //to grab back\n\n\ngit commit --amend --no-edit. //To append to previous commit without a new message\n//If you try to push after this, you'd be shown message to pull before that, in that case you need to do force push otherwise you'll have 2 git commits\n\ngit commit --amend -m\"\" //Change previous commit message\n\n\n//Squashing\ngit rebase -i HEAD~3 //Go back to commits you want to include\n\n</code></pre>\n\n<p>Resolving conflicts:</p>\n\n<p>Conflicts may arise when you merge your work with others&#39; work. Specifically while running &#39;git pull&#39; or &#39;git merge&#39; commands.</p>\n\n<p>Conflicts occur if the same line of a file has been modified by you and someone else, and git cannot figure out which one it should keep.</p>\n\n<p>Something like this shows up in files which have conflict:</p>\n\n<pre>\n<code class=\"language-javascript\">If you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question in IRC.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a\n</code></pre>\n\n<p>Decide if you want to keep only your branch&#39;s changes, keep only the other branch&#39;s changes, or make a brand new change, which may incorporate changes from both branches. Delete the conflict markers&nbsp;<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>,&nbsp;<code>=======</code>,&nbsp;<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>&nbsp;and make the changes you want in the final merge.&nbsp;</p>\n\n<p>After this, you have to stage the changes and commit them.</p>\n\n<h2>Rebasing vs Merging</h2>\n\n<p>Rebasing works when you think: &quot;<em>I wish I had not created this branch earlier, I wish all the commits in branch automatically come on the top of master now</em>&quot;. In such scenarios, You can rebase your branch on master.</p>\n\n<p>&nbsp;</p>\n\n<h2>GIT Reset</h2>\n\n<p>Move HEAD to some commit, e.g. to undo merge, git reset --hard &lt;prior commit by default&gt;</p>\n\n<h2>Internal Working</h2>\n\n<p>GIT stores every detail inside single folder &quot;.git&quot; inside folder, where you ran command &#39;git init&#39;.</p>\n\n<p>When you first run &#39;git add&#39; and &#39;git commit&#39; command, master branch is automatically created. See inside .git/refs/heads/master.</p>\n\n<p>If you manually create these directories:</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.git/refs/heads, .git/objects ;</p>\n\n<p>objects directory contains key-value data, key will be first digits of has calculated from file contents. Essentially there will be directory named with first some digits of hash calculated. Inside that there will be files named with rest of the hash. These hash named files store blobs, i.e. content of staged files.</p>\n\n<p>Branch =~ Ref heads</p>\n\n<p>Staging Area =~ Index</p>\n\n<p>GIT basically functions using Blobs &lt;-&nbsp;Tree &lt;-&nbsp;Commits all stored as objects.</p>\n\n<p>&nbsp;</p>\n\n<h2>Some Special GIT Commands</h2>\n\n<p>git checkout HEAD -- filename.txt //Pulls single file</p>\n\n<p>git reflog -- shows the changes done to commits, e.g by mergin, rebasing, or resetting.</p>\n\n<pre>\n<code class=\"language-python\"># Discard uncommitted changes in a specific file\ngit checkout file_name\n\n# Clear everything not in repo\ngit checkout -- .\n\n# Forgot to change something\ngit commit -m 'initial commit'\nedit file\ngit commit -a --amend\n\n</code></pre>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "devops", "tags": ["basic"], "img": "/images/git.png", "summary": "See how Git works, its terminologies and some common use-case scenarios.", "lastUpdated": "2021-06-14 20:24:25.719716"}