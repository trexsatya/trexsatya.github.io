{"name":"Better Concurrency / Asynchronisity in Easier Ways","id":109,"content":"<p>Reactive programming basically leverages Event-Driven pattern or Observer-Pattern you can say.</p>\n\n<p>BUT WHY DO WE NEED THIS: Because you do not want to waste time waiting for someone&#39;s response. Just ask for a response and go ahead, whenever the asked party replies, you will be told.</p>\n\n<p>In Java, there are many libraries to achieve this.</p>\n\n<h2>RxJava</h2>\n\n<p>RxJava is combination of Observer-Pattern, Iterator-Pattern and Functional Programming</p>\n\n<p>There are some typical scenarios for which RxJava provides excellent solutions:</p>\n\n<p>&nbsp; &nbsp; &nbsp;Do This, Then That,.... When Everything Done... Every part of this pipeline can be done synchronously or asynchronously.</p>\n\n<p>&nbsp; &nbsp; &nbsp;Combine results of two pipelines (both may be synch/async)</p>\n\n<p>&nbsp; &nbsp; &nbsp;Retry if some error occurs, retry delay etc.</p>\n\n<p>&nbsp; &nbsp; &nbsp;Apply back-pressure if not able to keep up with the producer.</p>\n\n<p>&nbsp; &nbsp;&nbsp;</p>\n\n<p>Parties involved in RxJava are: <strong>Observable : </strong>Are source&nbsp;of data</p>\n\n<p><strong>Subscriber</strong>: listen to the observables</p>\n\n<p>Basically there are two types of sources: Flowable&lt;T&gt; and Observable&lt;T&gt;&nbsp;</p>\n\n<pre>\n<code class=\"language-java\">observable = Observable.create( oneWhoWantsData -&gt; {\n     data = generateData()\n\n     //You can call this many times\n     give(data).to(oneWhoWantsData) //oneWhoWantsData.onNext(data)\n\n     tell(oneWhoWantsData).thatThereIsNoMoreData() //oneWhoWantsData.onComplete()\n})\n\n\ndisposable = observable.subscribe(thingsToDoWhenDataArrives, thingsToDoWhenErrorOccurs);\n\ndisposable.dispose()\n</code></pre>\n\n<pre>\n<code class=\"language-java\">//Cool API of RxJava\n//Variations of map, flatMap and reduce are available \n\nObservable.interval(1, TimeUnit.SECONDS)\n          .take(200)\n          .flatMap( nthInterval -&gt; Observale&lt;T&gt; ) //because of flatMap instead of map, you can perform asynchronous task here to generate result\n\n//          .toBlocking() //This will cause the current thread to wait for data to become available\n//          .forEach( result -&gt; )\n           \n           .scan( reducer ) //Reduction\n           .subscribe( result -&gt; , error -&gt; ) \n\n\n//Data sources (i.e. Observables ) can be merged\n//zip -&gt; to make pairs from two lists\n//merge -&gt;\n</code></pre>\n\n<p>&nbsp;</p>\n\n<h2>Reactor - very much inline with Reactive-Streams specification</h2>\n\n<p>Publisher (source of data) and Subscriber</p>\n\n<p>In Reactor , concept of Backpressure is implemented right from the beginning of this library</p>\n\n<p>There are two types of data-sources in Reactor: Flux&lt;T&gt; and Mono&lt;T&gt;</p>\n\n<pre>\n<code class=\"language-java\">interface NonBlockingRepository {\n  Mono&lt;Void&gt; save(Publisher&lt;T&gt; dataSource );\n  Flux&lt;T&gt; findAll()\n  Mono&lt;T&gt; findFirst()\n  Mono&lt;T&gt; findById(String id)\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"\"><span style=\"font-family:Georgia,serif;\">Can We Achieve All That Using Just CompletableFuture ?</span></span></h2>\n\n<p>Scenario: Do this (synchronously/asynchronously) - Then Do This (synchronously/asynchronously)-......</p>\n\n<pre>\n<code class=\"language-java\">CompletableFuture.supplyAsync(supplier, defaultExecutor = ForkJoinPool.commonPool())\n    .thenApply()  //like map()\n    .thenCompose()//like flatMap()\n\n//By using xxxAsync() version of these methods, you perform those tasks on different thread, all asynchronously\n//At any stage of pipeline you can use whenComplete() method\n \n</code></pre>\n\n<p>Scenario: Do this...Do That....combine result of both</p>\n\n<pre>\n<code class=\"language-java\">completableFutureOne.thenCombine(completableFutureTwo, (first, second)-&gt; combined)</code></pre>\n\n<p>Scenario: Get from here, or get from there</p>\n\n<pre>\n<code class=\"language-java\">completableFutureOne.applyToEither(completableFutureTwo, (received)-&gt; changed)</code></pre>\n\n<p>These cover almost all scenarios we require, BUT ALL THIS WORKS ONLY FOR SINGLE PUSH (from Supplier), CAN&#39;T PUSH STREAM OF DATA in a fluent manner.</p>\n","authorId":null,"subject":"linked-to-138","tags":null,"img":null,"summary":null,"lastUpdated":"2018-07-01T13:59:24.960+0000"}