{"name": "Multithreading Basics", "id": 82, "content": "<p><strong>What is Multi-threading?</strong></p>\n\n<p><u>Overview</u>: If your software/program has capability to perform two different tasks simultaneously, then it is called multithreading. Suppose you have written a program which identifies facial structures from the image, like the image is given to the system and it highlights where the nose is, and where the eyes are etc. If your program can perform the task of identifying nose and identifying eyes simultaneously, then its multi-threaded.</p>\n\n<p>How is it possible? Performing two tasks simultaneously is possible because there are more than 1 CPU cores inside computers now a days. Well, this situation is also called <strong>Parallelism</strong>. Sometimes people get confused among <em>Multithreading</em> and <em>Parallelism</em>. The scenario in above examples shows <em>Parallelism</em>, but parallelism is achieved by using multithreading only.</p>\n\n<p>So what&#39;s the difference between Parallelism and Multithreading? Well, not much. Just remember the fact that multithreading can be achieved on single core CPU also. And in that case, you get an illusion that two or more tasks are being performed simultaneously. <a href=\"http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html\" target=\"_blank\">See this article</a>.</p>\n\n<p>Multi-Threading: is the ability of CPU to execute multiple threads (lightweight processes) concurrently.&nbsp;</p>\n\n<p><u>Scenario based&nbsp;Explaination</u>: We will take most common use of multithreading, <em>web servers.</em>&nbsp;Suppose a user logs into the system, and his profile is being loaded from disk. Now at the same time, another user logs in and wants to see his profile. Now what happens is that, until the data of first user is loaded from disk, converted into appropriate format and shown to the first user, second user would have to wait. But this is not what we want..So in order to solve this we can use <em>Threads</em>, two different threads can run for two users and they can both simultaneously ( parallely if multiple cores are there) load data from disk, convert the data and show to the users.&nbsp;</p>\n\n<p><strong><span style=\"\">What&#39;s the benefit?</span>&nbsp;</strong></p>\n\n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>If there are multiple cores, it&#39;s obvious that we are able to achieve parallelism, which increases efficiency. In case of single core CPUs also multithreading can benefit... The core reason is that, while performing any task (as simple as adding two numbers), CPU is not busy at every moment. It needs to wait for different events like loading from memory, writing to memory etc...Multithreading makes it possible to utilize that idle time.</p>\n\n<p style=\"margin-left: 40px;\">The benefit is that CPU resources (the computing units, the&nbsp;<a href=\"https://en.wikipedia.org/wiki/CPU_cache\" title=\"CPU cache\">CPU caches</a>, and the&nbsp;<a href=\"https://en.wikipedia.org/wiki/Translation_lookaside_buffer\" title=\"Translation lookaside buffer\">translation lookaside buffer</a>&nbsp;(TLB).) would be shared, and hence their utilization will increase. If a thread cannot use all the computing resources of the CPU (because instructions depend on each other&#39;s result), running another thread may prevent those resources from becoming idle. It minimizes the idle time that CPU resources enjoy.&nbsp;</p>\n\n<p style=\"margin-left: 40px;\">Using this, same task can be done simultaneously by different threads. One thread might utilize the ideal time caused by&nbsp;other thread which is waiting for something to happen e.g. getting data from network.</p>\n\n<p style=\"margin-left: 40px;\">But different kinds of problems arise when something is shared among multiple threads.</p>\n\n<p><span style=\"\"><strong>When should you use multi-threading?</strong></span>&nbsp;</p>\n\n<p style=\"margin-left: 40px;\">One scenario is when your program contains some logic which is taking a lot of time waiting for something to happen (e.g. waiting for user to input some data), at the same time some part of your program can be run independently of that. Then you will benefit from multi-threading (wait in one thread, do other computations in another thread). Same is case while implementing servers, each server thread can wait for a socket connection to be bound.</p>\n\n<p>Multi-threading in single core CPUs comes at a cost. Because there is just one core in CPU, it implements capability of multi-threading using <a href=\"https://en.wikipedia.org/wiki/Context_switch\">Context-Switching</a>.( Basically store all the information regarding current thread, loading the saved state/or new state for other thread). This is time consuming.</p>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"\">Problems with Multi-threading</span></h2>\n\n<p>When data is shared among threads, there can be many problems in multi-threaded scenario namely, Race Condition, Deadlock, Livelock, Starvation. All the problems arise due to the fact that when two/more threds run some code block simultaneously, the order of execution is not guaranteed.&nbsp;</p>\n\n<p><strong>Race Condition:&nbsp;</strong></p>\n\n<p>Suppose you write a simple program as this, and there are two threads which will be running this simultaneously.</p>\n\n<pre>\n<code class=\"language-java\">1. x = 5; //x and y are the values which are somehow shared among the threads (means all threads can access x and y).\n2. if (x == 5) // The \"Check\"\n3. {\n4.   y = x * 2; // The \"Act\"\n5. }</code></pre>\n\n<p>In ideal scenario (single threaded program) you would expect this program to set value of y = 10&nbsp;, in multithreading, when another thread has access to <strong><em>x</em></strong> and <em><strong>y,</strong>&nbsp;</em>the following scenario may arise:&nbsp;</p>\n\n<p>&nbsp; &nbsp;Thread-1 executes line 2, then some other thread comes and changes the value of x to 6, then thread-1 comes and execute line 4. And the value of y is now wrongly set.</p>\n\n<p>This scenario is called <em>Race Condition</em>, because the threads are <em>racing</em>&nbsp;to access and change the data, and in this race anyone could be winner, so the result is unpredictable.</p>\n\n<p><strong>Deadlock:</strong></p>\n\n<p>There are numerous daily life example for deadlock in real-life e.g.</p>\n\n<ul>\n\t<li>Two cars crossing a single-lane bridge from opposite directions.</li>\n\t<li>A person going down a ladder while another person is climbing up the ladder.</li>\n\t<li>Two trains traveling toward each other on the same track</li>\n\t<li>Being stuck in a traffic, or like in situations where somebody cannot get job until they have experience, and cannot get experience until they get the job.</li>\n</ul>\n\n<p>In Java, deadlock occurs only if you are holding the synchronization</p>\n\n<p>Example for deadlock:</p>\n\n<pre>\n<code class=\"language-java\">package com.satya.logtool;\n\nclass Person{\n    int exp = 0;\n    int jobsDone = 0;\n}\npublic class DeadlockExample {\n    static void addExp(Person person){\n        while (person.jobsDone == 0);\n        System.out.println(\"Increasing experience\");\n        person.exp += 1;\n    }\n\n    static void addJobs(Person person){\n        while (person.exp == 0);\n        System.out.println(\"Increasing job count\");\n        person.jobsDone += 1;\n    }\n\n    public static void main(String[] args) {\n        Person person = new Person();\n        new Thread(()-&gt; addExp(person)).start();\n        new Thread(()-&gt; addJobs(person)).start();\n    }\n}\n</code></pre>\n\n<p>But this is not something&nbsp;we typically implement, here we are clearly looping until some condition is satisfied. In the below example, the same thing is hidden. Run this program many times, and by luck you will be able to see the Deadlock situation, when nothing gets transferred to anybody.</p>\n\n<pre>\n<code class=\"language-java\">package com.satya.logtool;\n\nclass Account {\n    double balance;\n\n    void withdraw(double amount){\n        balance -= amount;\n    }\n\n    void deposit(double amount){\n        balance += amount;\n    }\n\n    static void transfer(Account from, Account to, double amount){\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        synchronized (from){\n            synchronized (to){\n                from.withdraw(amount);\n                to.deposit(amount);\n                System.out.println(\"Transferred \"+amount+ \" from \"+from+\" \"+to);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Account account1 = new Account();\n        Account account2 = new Account();\n\n        new Thread(()-&gt; Account.transfer(account1, account2, 10)).start();\n        new Thread(()-&gt; Account.transfer(account2, account1, 10)).start();\n    }\n}</code></pre>\n\n<p>In programs, deadlock can occur even if not blocked by other threads, this (Self-Deadlock/Recursive-Deadlock) happens when a block secured by a lock calls (directly, or indirectly) another block that is protected by same lock. <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html\">ReentrantLock</a> in Java avoids this.</p>\n\n<p>Deadlock&nbsp;in situations where for example, A is waiting on B, and B is waiting on A, lock ordering (lock hierarchy) can help. But,&nbsp;just because you use a lock hierarchy discipline correctly within the code you control, a separately authored module or plug-in that you link with won&#39;t necessarily know anything about your lock hierarchy unless you somehow inform them about your layers and how they should fit into the hierarchy.</p>\n\n<p>The idea of a lock hierarchy is to assign a numeric level to every mutex in the system, and then consistently follow two simple rules:</p>\n\n<ul>\n\t<li>Rule 1: While holding a lock on a mutex at level&nbsp;<code>N</code>, you may only acquire new locks on mutexes at lower levels&nbsp;<code>&lt;N</code>.</li>\n\t<li>Rule 2: Multiple locks at the same level must be acquired at the same time, which means we need a &quot;lock-multiple&quot; operation such as<code>&nbsp;lock( mut1, mut2, mut3, ... ).</code>&nbsp;This operation internally has the smarts to make sure it always takes the requested locks in some consistent global order. [1] Note that any consistent order will do; for example, one typical strategy is to acquire mutexes at the same level in increasing address order.</li>\n</ul>\n\n<p>It is possible to just start trying to acquire the locks in some randomly selected order using try_lock operations, and if we can&#39;t acquire them all just back-off (unlock the ones already acquired) and try a different order until we find one that works. Surprisingly, this can be more efficient than taking the locks in a hard-coded global order, although any backoff-and-retry strategy has to take care that it doesn&#39;t end up prone to livelock problems in-stead.</p>\n\n<p>Deadlock (Starvation) due to scheduling can be avoided by cleverly using <code>yield</code> method&nbsp;to make threads share time as you require.</p>\n\n<p>Do not use multiple synchronization objects if one synchronization object is sufficient. Avoid the case where two threads wait for each other to terminate. Instead, use a third thread to wait for both threads to terminate.</p>\n\n<p>&nbsp;</p>\n\n<h2><span style=\"\">Typical Multi-threading Scenarios Implemented In&nbsp;Java</span></h2>\n\n<p><span style=\"color:#8e44ad;\"><strong>Run threads&nbsp;alternatively.</strong></span> <u>Problem</u>: Suppose you have two threads one which prints even numbers and the other which prints odd numbers, how can you print this sequence 1,2,3,4,5,....?</p>\n\n<pre>\n<code class=\"language-java\">volatile int threadWhichShouldRunNext  = ODD;\nObject lock = this;\n\nThread oddThread = new Thread(){\n        int count = 1;\n        @Override\n        public void run() {\n            while (count &lt; 50) {\n                waitForTurn(lock, 1);\n                println(count);\n                count += 2;\n                allowNextThread(lock, () -&gt; threadWhichShouldRunNext = EVEN);\n            }\n        }\n};\n//Similarly create evenThread; you can refactor the code to create a single Runnable and pass the parameter to tell whether it would print even number of odd number\n\nprivate void waitForTurn(Object lock, int turn){\n        try {\n            synchronized (lock) {\n                while (threadWhichShouldRun != turn) lock.wait();\n                // if (threadWhichShouldRun != turn) lock.wait(); will be wrong here.\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n}\n\nprivate void allowNextThread(Object lock, Runnable o) {\n        synchronized (lock) {\n            o.run();\n            lock.notifyAll();\n        }\n}</code></pre>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Wait For Thread To Finish.</strong>&nbsp;</span> <u>Problem</u>: You have hit the REST call to server using a thread, but you cannot proceed without the result, how would you wait for the result?</p>\n\n<pre>\n<code class=\"language-java\">Thread thread = startThread();\n//Do something\n\n//Now we need for some result which will be computed by thread\nthread.join(); //Execution will not go beyond this unless 'thread' completes.</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong><span style=\"color:#8e44ad;\">Stop The Execution For Some Time</span></strong></p>\n\n<pre>\n<code class=\"language-java\">//Current thread will be stopped from running for specified time, but this will not release the resources acquired (including locks)\nThread.sleep(timeInMilliseconds);\n\n//someLock.wait() does not send the thread to waiting/sleeping state, instead current thread will be added to waiting-list of 'someLock', it releases the resources acquired.\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Stop The Thread</strong></span></p>\n\n<pre>\n<code class=\"language-java\">//Method-1: Using volatile flag\npublic void run(){\n   while(flag){\n\n   } //Automatically exit when flag becomes false\n}\n\n//But in above implementation, if thread is involved in some blocking operation which sends the thread to WAITING state, e.g. waiting on network IO above method will not make the thread terminate immediately, instead it will terminate after that blocking operation is finished.\npublic void run(){\n    while (!Thread.currentThread().isInterrupted()) {\n       // cleanup and stop execution\n       // for example a break in a loop\n       \n    }\n}\n//Then to stop it, call thread.interrupt();\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong><span style=\"color:#8e44ad;\">Create A Lot Of Threads</span></strong></p>\n\n<p>Do not create a lot of threads explicitly/manually, use thread pools. It will keep your system resource utilization under control. Since threads will be reused once their task has been finished.</p>\n\n<pre>\n<code class=\"language-java\">Executor executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -&gt; print(\"\");\n\nExecutorService executorService = Executors.newFixedThreadPool(10);\nFuture&lt;String&gt; future = executorService.submit(() -&gt; \"\");\n\n//Future is something that will hold result in future, and can be cancelled on demand, methods are provided for checking completion, cancelling, etc\n\nThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n\nThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();\n\nScheduledExecutorService scheduler = Executors.newScheduledThreadPool(5);\nscheduler.schedule(() -&gt; print(\"..\"), 500, TimeUnit.MILLISECONDS));\n\n</code></pre>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color:#8e44ad;\"><strong>Producer Consumer</strong></span></p>\n\n<p style=\"margin-left: 40px;\">One (or more) thread is producing the items and adding it to some data structures, but only if there is space for new item, other thread(s) is pulling item from that data structure, but only if there is item in that structure.</p>\n\n<p style=\"margin-left: 40px;\">Essentially the producer should give turn to consumer(s) if there is no space left for new item, and consumer should give their turn to produer(s) if there is no item left.</p>\n\n<pre>\n<code class=\"language-java\">lock = new ReentrantLock(fair);\nnotEmpty = lock.newCondition();\nnotFull =  lock.newCondition();\n\npublic void put(E e) throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == items.length)\n                notFull.await();\n            enqueue(e);\n        } finally {\n            lock.unlock();\n        }\n}\n\npublic E take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            while (count == 0)\n                notEmpty.await();\n            return dequeue();\n        } finally {\n            lock.unlock();\n        }\n}\n\nprivate E dequeue() {\n        final Object[] items = this.items;\n        E x = (E) items[takeIndex];\n        items[takeIndex] = null;\n        if (++takeIndex == items.length)\n            takeIndex = 0;\n        count--;\n        notFull.signal();\n        return x;\n}</code></pre>\n\n<p style=\"margin-left: 40px;\">&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>Concurrency is composition of independently executing processes. The characteristic is that even if these processes are executed out of order, or in partial order the result will be same.</p>\n\n<p>&nbsp;</p>\n", "authorId": 1, "subject": "linked-to-138", "tags": ["medium"], "img": "", "summary": "", "lastUpdated": "2021-01-19 12:22:28.719625"}