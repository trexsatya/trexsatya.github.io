{"name":"Gradle to release","id":76,"content":"<pre>\n\nimport groovy.json.*\n\nimport java.util.concurrent.CountDownLatch\n\ngroup &#39;enablements&#39;\nversion &#39;1.0-SNAPSHOT&#39;\n\napply plugin: &#39;java&#39;\n\nsourceCompatibility = 1.8\n\nrepositories {\n&nbsp; &nbsp; mavenCentral()\n}\n\ndependencies {\n&nbsp; &nbsp; testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.11&#39;\n}\n\n\ntask checkoutFromStash{}\ntask fixDependencies {}\ntask buildAll {}\ntask runJavaProjects{}\ntask runELK {}\n\ndef uiProjects = []\n\ndef javaProjects = []\n\ndef baseDir = &quot;C:/Dev&quot;\ndef (uiProjectsDir, javaPojectsDir) = [ new File(baseDir, &quot;UI&quot;), new File(baseDir, &quot;EbalementsAPI&quot;) ].collect { if(!it.exists()) it.mkdirs(); return it}\n\nString username = System.properties[&#39;user.name&#39;]\ndef localhost = InetAddress.getLocalHost().getHostName();\n\ncheckoutFromStash.doLast {\n&nbsp; &nbsp; uiProjects. findAll {! new File(uiProjectsDir.absolutePath, it).exists()}.each { project -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; exec {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workingDir uiProjectsDir.absolutePath\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandLine &quot;git&quot;, &quot;clone&quot;, &quot;https://kumatye@../${project}.git&quot;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; javaProjects.findAll {! new File(javaPojectsDir.absolutePath, it).exists()}.each { project -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; exec {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workingDir javaPojectsDir.absolutePath\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandLine &quot;git&quot;, &quot;clone&quot;, &quot;http://...${project}.git&quot;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; //Clone other dependencies\n&nbsp; &nbsp; if(! new File(uiProjectsDir.absolutePath, &quot;..&quot;).exists())\n&nbsp; &nbsp; exec {\n&nbsp; &nbsp; &nbsp; &nbsp; workingDir uiProjectsDir.absolutePath\n&nbsp; &nbsp; &nbsp; &nbsp; commandLine &quot;git&quot;, &quot;clone&quot;, &quot;https://...git&quot;\n&nbsp; &nbsp; }\n}\n\n//Repalace in files\n\nfixDependencies.doLast{\n&nbsp; &nbsp; def json = new JsonSlurper().parse( new File(uiProjectsDir, &quot;../dependencies.json&quot;))\n\n&nbsp; &nbsp; json.routes = routes\n\n&nbsp; &nbsp; println(new JsonBuilder(json).toPrettyString())\n}\n\nrunJavaProjects.doLast{\n\n&nbsp; &nbsp; String mavenPath = &quot;${projectDir}/maven/apache-maven-3.5.0/bin&quot;\n&nbsp; &nbsp; def projectsToRun = []\n\n&nbsp; &nbsp; waitToFinishAll(\n&nbsp; &nbsp; &nbsp; &nbsp; projectsToRun.collect{ project -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [&quot;$mavenPath/mvn.cmd&quot;, &quot;-f&quot;, &quot;${javaPojectsDir}/$project/pom.xml&quot;, &quot;clean&quot;, &quot;install&quot;, &quot;--settings&quot;, &quot;settings-enab.xml&quot;, &quot;exec:java&quot;,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#39;-Dexec.mainClass=&quot;com.rbs.amservices.server.container.ContainerBootstrap&quot;&#39;, &#39;-Dexec.args=&quot;%modulepath&quot;&#39;].execute()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .waitForProcessOutput(new FileOutputStream(new File(&quot;logs&quot;,&quot;${project}.log&quot;)), new FileOutputStream(new File(&quot;logs&quot;,&quot;${project}_error.log&quot;)))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println(&quot;Finished Running project $project&quot;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; )\n\n}\n\nrunELK.doLast {\n&nbsp; &nbsp; waitToFinishAll([\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def out = new FileOutputStream(new File(&quot;logs&quot;,&quot;elasticsearch.log&quot;))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;${projectDir}/ELK/elasticsearch-5.4.0/elasticsearch-5.4.0/bin/elasticsearch.bat&quot;.execute()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .waitForProcessOutput(out, out)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def out = new FileOutputStream(new File(&quot;logs&quot;,&quot;logstash.log&quot;))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [&quot;${projectDir}/ELK/logstash-5.4.0/logstash-5.4.0/bin/logstash.bat&quot;, &quot;--conf&quot;, &quot;$projectDir/ELK/test.conf&quot;].execute()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .waitForProcessOutput(out, out)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def out = new FileOutputStream(new File(&quot;logs&quot;,&quot;elasticsearch.log&quot;))\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;${projectDir}/ELK/kibana-5.4.0-windows-x86/kibana-5.4.0-windows-x86/bin/kibana.bat&quot;.execute()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .waitForProcessOutput(out, out)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; ])\n}\n\n\nbuildAll.doLast{\n&nbsp; &nbsp; String mavenPath = &quot;${projectDir}/maven/apache-maven-3.5.0/bin&quot;\n\n&nbsp; &nbsp; def projectsInOrderToBuild = []\n\n&nbsp; &nbsp; def rootLogFolder = new File(&quot;logs/buildlogs&quot;)\n\n&nbsp; &nbsp; projectsInOrderToBuild.each {\n&nbsp; &nbsp; &nbsp; &nbsp; def file = new File(rootLogFolder,&quot;${it}_build.log&quot;)\n&nbsp; &nbsp; &nbsp; &nbsp; if(file.exists()) file.delete()\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; def wasSuccessful = {\n&nbsp; &nbsp; &nbsp; &nbsp; return new File(rootLogFolder, &quot;${it}_build.log&quot;).text.contains(&quot;BUILD SUCCESS&quot;)\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; projectsInOrderToBuild.collect { project -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; return {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [&quot;$mavenPath/mvn.cmd&quot;, &quot;-f&quot;, &quot;${javaPojectsDir}/$project/pom.xml&quot;, &quot;clean&quot;, &quot;install&quot;, &quot;--settings&quot;, &quot;settings.xml&quot;].execute()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .waitForProcessOutput(new FileOutputStream(new File(rootLogFolder,&quot;${project}_build.log&quot;)), new FileOutputStream(new File(rootLogFolder,&quot;${project}_build_error.log&quot;)))\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println(&quot;Finished building project $project ${if(wasSuccessful(project)) &quot;Build Succeeded&quot; else &quot;Build Failed&quot;}&quot; )\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }.each { it() }\n}\n\ndef waitToFinishAll(actions){\n&nbsp; &nbsp; def latch = new CountDownLatch(actions.size())\n&nbsp; &nbsp; actions.each { action -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; new Thread({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latch.countDown()\n&nbsp; &nbsp; &nbsp; &nbsp; }).start()\n&nbsp; &nbsp; }\n&nbsp; &nbsp; latch.await()\n}\n\nimport org.eclipse.jgit.api.ListBranchCommand.ListMode\nimport com.jcraft.jsch.*\nimport com.sun.jmx.snmp.IPAcl.Host\nimport groovy.json.JsonSlurper\nimport groovy.transform.Field\nimport groovy.xml.StreamingMarkupBuilder\nimport groovy.util.XmlNodePrinter\nimport org.apache.http.HttpHost\nimport org.apache.http.client.methods.CloseableHttpResponse\nimport org.apache.http.client.methods.HttpGet\nimport org.apache.http.client.protocol.HttpClientContext\nimport org.apache.http.conn.ssl.NoopHostnameVerifier\nimport org.apache.http.impl.client.HttpClients\nimport org.apache.http.ssl.SSLContextBuilder\nimport org.apache.http.ssl.TrustStrategy\nimport org.codehaus.groovy.tools.xml.DomToGroovy\nimport groovy.xml.XmlUtil\nimport org.eclipse.jgit.errors.TransportException\nimport org.eclipse.jgit.util.FS\nimport org.jfrog.artifactory.client.Artifactory\nimport org.jfrog.artifactory.client.ArtifactoryClient\nimport org.jfrog.artifactory.client.model.RepositoryType\nimport org.jfrog.artifactory.client.ArtifactoryRequest\nimport org.jfrog.artifactory.client.impl.ArtifactoryRequestImpl\nimport org.eclipse.jgit.lib.*\nimport org.eclipse.jgit.storage.file.*\nimport org.eclipse.jgit.api.*\nimport groovy.json.JsonBuilder\nimport org.eclipse.jgit.transport.*\nimport org.eclipse.jgit.api.ResetCommand.ResetType\nimport org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode\nimport groovy.xml.dom.*\nimport groovy.xml.*\n\ndef printInColor(text, color, background = &quot;white&quot;) {\n    def Colors = [blue: &quot;\\u001B[34m&quot;, purple: &quot;\\u001B[35m&quot;, reset: &quot;\\u001B[0m&quot;, green: &quot;\\u001B[32m&quot;, cyan: &quot;\\u001B[36m&quot;, red: &quot;\\u001B[31m&quot;, white: &quot;\\u001B[37m&quot;, yellow: &quot;\\u001B[33m&quot;]\n    def bgColors = [black: &quot;\\u001B[40m&quot;, red: &quot;\\u001B[41m&quot;, green: &quot;\\u001B[42m&quot;, yellow: &quot;\\u001B[43m&quot;, blue: &quot;\\u001B[44m&quot;, purple: &quot;\\u001B[45m&quot;, cyan: &quot;\\u001B[46m&quot;]\n\n    println(&quot;${bgColors[background] ?: &quot;&quot;}${Colors[color]}${text}${Colors.&#39;reset&#39;}&quot;)\n}\n\napply plugin: &#39;groovy&#39;\napply plugin: &#39;java&#39;\n\nbuildscript {\n    repositories {\n        maven { url &quot;https://artifactory-1.dts.fm.rbsgrp.net/artifactory/ratesservices-all-repos&quot; }\n\n        maven { url &quot;https://artifactory-1.dts.fm.rbsgrp.net/artifactory/odc-all-repos&quot; }\n\n        jcenter()\n    }\n\n    dependencies {\n        // https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit\n        classpath group: &#39;org.eclipse.jgit&#39;, name: &#39;org.eclipse.jgit&#39;, version: &#39;4.6.0.201612231935-r&#39;\n        classpath group: &#39;org.codehaus.groovy&#39;, name: &#39;groovy-all&#39;, version: &#39;2.4.10&#39;\n        classpath group: &#39;org.codehaus.groovy&#39;, name: &#39;groovy-json&#39;, version: &#39;2.4.10&#39;\n        classpath &#39;org.jfrog.artifactory.client:artifactory-java-client-services:+&#39;\n    }\n}\n\ndependencies {\n    compile &#39;org.codehaus.groovy:groovy-all:2.4.10&#39;\n}\n\ntask prepare {}\n\nprepare.doLast {\n    configureSSH()\n\n    String specifiedReleaseVersion = project.properties[&#39;releaseVersion&#39;]\n    def versions = calculateVersions(specifiedReleaseVersion)\n\n//    setTeamcityParameters(versions.release, versions.dev)\n\n    def git = openExistingRepo()\n    def alreadyAGitRepo = git?.getRepository()?.objectDatabase?.exists()\n\n    if(!alreadyAGitRepo){\n        throw new Exception(&quot;Not a valid GIT repo. Please ensure that you are using client side checkout on Teamcity.&quot;)\n    }\n\n    changeReleaseVersionsAndPush(git, specifiedReleaseVersion, versions)\n\n    changeDevelopmentVersionsAndPush(git, specifiedReleaseVersion, versions)\n}\n\ndef  changeDevelopmentVersionsAndPush(git, specifiedReleaseVersion, versions){\n    def releaseVersions = versions.release, devVersions = versions.dev\n\n    println &quot;Changing next development versions \\n   ${gitStatus(git)}&quot;\n\n    boolean toCreateOrNot = git.branchList().call().find { it.name == &quot;refs/heads/develop&quot; } == null\n\n    def bc = git.checkout()\n            .setCreateBranch(toCreateOrNot)\n            .setUpstreamMode(SetupUpstreamMode.SET_UPSTREAM)\n            .setName(&quot;develop&quot;)\n//            .setStartPoint(&quot;origin/develop&quot;)\n            .call()\n\n    def files = updatePomVersions(devVersions)\n\n    commitFiles(git, &quot;Commiting next development versions&quot; , files)\n\n    println &quot;Pushing new versions $devVersions into develop branch.&quot;\n\n    def pushStatus = git.push()\n//            .setRefSpecs(new RefSpec(&quot;refs/remotes/origin/develop:develop&quot;))\n            .setTransportConfigCallback(transportCallback).setRemote(&quot;origin&quot;).call()\n\n    pushStatus.forEach { result -&gt; println result.messages }\n}\n\ndef changeReleaseVersionsAndPush(Git git, specifiedReleaseVersion, versions){\n    def releaseVersions = versions.release, devVersions = versions.dev\n\n    println gitStatus(git)\n\n    def branchName = &quot;release/$specifiedReleaseVersion&quot;\n\n    boolean toCreateOrNot = git.branchList().call().find { it.name == &quot;refs/heads/$branchName&quot; } == null\n\n    println(&quot;should create new branch: $toCreateOrNot &quot;)\n\n    printAllRefs(git)\n\n    def bc = git.checkout()\n            .setCreateBranch(toCreateOrNot)\n            .setUpstreamMode(SetupUpstreamMode.SET_UPSTREAM)\n            .setName(branchName)\n            .setStartPoint(&quot;origin/develop&quot;)\n            .call()\n\n    println &quot;Release Branch creation: $bc \\n&quot;\n    printAllRefs(git)\n\n    def files = updatePomVersions(releaseVersions)\n\n//    commitAllFiles(git, &quot;Commiting specified release versions&quot;)\n\n    commitFiles(git, &quot;Commiting specified release versions&quot; , files)\n\n    println &quot;Pushing new versions $releaseVersions into release branch $branchName&quot;\n\n    def pushStatus = git.push()\n//            .setRefSpecs(new RefSpec(&quot;refs/heads/$branchName:refs/heads/origin/$branchName&quot;))\n            .setTransportConfigCallback(transportCallback).setRemote(&quot;origin&quot;).call()\n\n    pushStatus.forEach { result -&gt; println result.messages }\n}\n\ndef updatePomVersions(versions){\n    versions = versions.collectEntries { [(it.artifact): it.version] }\n    println &quot;update pom versions $versions&quot;\n\n    def projectFolders = []\n    def modifiedFiles = []\n\n    projectFolders.collect {\n        def projectPom = new File(containingFolder(), &quot;$it/pom.xml&quot;)\n\n        modifiedFiles &lt;&lt; &quot;$it/pom.xml&quot;\n\n        println &quot;modifying pom file $projectPom&quot;\n\n        modifyAndSaveXmlFile(projectPom, {root-&gt;\n            root.version[0].value = versions[root.artifactId.value]\n        })\n    }\n\n    modifiedFiles\n}\n\ndef gitCheckout(Git git, String branch){\n    def checkout = git.checkout().setName(branch).call()\n\n    println(&quot;Checkout: ${checkout}&quot;)\n}\n\ndef calculateVersions(releaseVersion) {\n\n    def projectFolders = []\n\n    def slurper = new XmlSlurper(false, false)\n    def projectVersions = projectFolders.collect {\n        def project = slurper.parse(new File(containingFolder(), &quot;$it/pom.xml&quot;))\n        return [artifact: project.artifactId.toString(), version: project.version.toString()]\n    }\n\n    def releaseVersions = projectVersions.collect {\n        def k = it.artifact, v = it.version\n        //if (releaseVersion) return [artifact: k, version: releaseVersion]\n        //Remove SNAPSHOT\n        v = v - &quot;-SNAPSHOT&quot;\n        return [artifact: k, version: v]\n    }\n\n    def incVersionByOne = { String v -&gt;\n        def res = []\n        def parts = v.split(&quot;\\\\.&quot;).collect { if (it.isNumber()) it.toInteger() else it }\n        res &lt;&lt; parts\n        res = res.flatten()\n\n        if (parts.size() == 3) {\n            res[-1] += 1\n        } else {\n            res &lt;&lt; 1\n        }\n        return res.join(&quot;.&quot;)\n    }\n\n    def devVersions = releaseVersions.collect {\n        return [ artifact: (it.artifact), version: incVersionByOne(it.version)+&quot;-SNAPSHOT&quot; ]\n    }\n\n    return [release: releaseVersions, dev: devVersions]\n}\n\ndef setTeamcityParameters(releaseVersions, devVersions) {\n\n    releaseVersions.each {\n        def project = it.artifact, version = it.version\n        exec {\n            commandLine &quot;echo&quot;, &quot;##teamcity[setParameter name=&#39;${project}_ReleaseVersion&#39; value=&#39;${version}&#39;]&quot;\n        }\n    }\n\n    devVersions.each {\n        def project = it.artifact, version = it.version\n        exec {\n            commandLine &quot;echo&quot;, &quot;##teamcity[setParameter name=&#39;${project}_ReleaseVersion&#39; value=&#39;${version}&#39;]&quot;\n        }\n    }\n\n}\n\ndef gitInit(){\n    println &quot;Git init&quot;\n    Git git = Git.init().setDirectory( containingFolder() ).call()\n\n    StoredConfig config = git.getRepository().getConfig();\n    config.setString(&quot;remote&quot;, &quot;origin&quot;, &quot;url&quot;, &quot;ssh://git@stash.dts.fm.rbsgrp.net/fb/services.git&quot;);\n\n    config.save();\n    return git\n}\n\ndef fetchAll(Git git){\n    println &quot;Git fetch &quot;\n    def fetch = git.fetch().setRemote(&quot;origin&quot;)\n            .setRefSpecs(new RefSpec(&quot;+refs/heads/develop:refs/remotes/origin/develop&quot;))\n            .setProgressMonitor(new TextProgressMonitor(new PrintWriter(System.out)))\n            .call()\n\n    println &quot;Git fetch Result ${fetch.messages} \\nAdvertised refs names: ${fetch.advertisedRefs.collect { it.name }.join(&quot;,&quot;)}&quot;\n\n}\n\ndef overwriteAll(Git git){\n    def reset = git.reset().setMode(ResetType.HARD).setRef(&quot;origin/develop&quot;).call()\n\n    println &quot;Overwrite develop branch: $reset&quot;\n}\n\ndef gitStatus(Git git){\n    def status = git.status().call()\n    &quot;&quot;&quot;Git status:\n            Currently on branch: ${git.repository.fullBranch}\n            Changed: ${status.changed}\n            Added: ${status.added}\n            Modified: ${status.modified}\n            Conflicting: ${status.conflicting}\n&quot;&quot;&quot;\n\n}\n\ndef openExistingRepo(){\n    def projectDir = project.rootDir.parentFile\n    Git git\n    try{ git = Git.open( projectDir ); } catch (e){}\n    git\n}\n\ndef commitAllFiles(git, message){\n    println &quot;Before Commiting changes: ${gitStatus(git)}&quot;\n    git.add().addFilepattern(&quot;.&quot;).call()\n    git.commit().setMessage(message).call()\n    println &quot;After Commiting changes: ${gitStatus(git)}&quot;\n}\n\ndef commitFiles(git, message, files){\n    println &quot;Before Commiting changes: ${gitStatus(git)}&quot;\n    files.each { git.add().addFilepattern(it).call() }\n    git.commit().setMessage(message).call()\n    println &quot;After Commiting changes: ${gitStatus(git)}&quot;\n}\n\n@Field\nTransportConfigCallback transportCallback = { transport -&gt;\n    SshTransport sshTransport = ( SshTransport )transport;\n    sshTransport.setSshSessionFactory( configureSSH() );\n}\n\n\ndef configureSSH(){\n    SshSessionFactory sshSessionFactory = new JschConfigSessionFactory() {\n        @Override\n        protected void configure(OpenSshConfig.Host host, Session session) {\n            java.util.Properties config = new java.util.Properties();\n            config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);\n            config.put(&quot;user&quot;, &quot;cameron&quot;);\n            session.setConfig(config);\n\n        }\n\n        @Override\n        protected JSch createDefaultJSch( FS fs ) throws JSchException {\n            JSch defaultJSch = super.createDefaultJSch( fs );\n            defaultJSch.addIdentity( &quot;${project.projectDir}/id_rsa&quot; );\n            return defaultJSch;\n        }\n\n    };\n\n    SshSessionFactory.setInstance(sshSessionFactory)\n    return sshSessionFactory\n}\n\ndef printAllRefs(Git git){\n    println &quot;Refs: ${git.repository.allRefs.collect {it}.join(&quot;\\n&quot;)}&quot;\n}\n\ndef containingFolder(){ project.projectDir.parentFile }\n\ntask testScript{}\n\ntestScript.doLast {\n    def xmlText = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n\\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n\\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\\t&lt;groupId&gt;com.rbs.futures&lt;/groupId&gt;\n\\t&lt;artifactId&gt;&lt;/artifactId&gt;\n\\t&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;\n\\t&lt;description&gt;\n\\t\\tShared code for the micro services, see https://confluence.dts.fm.rbsgrp.net/display/RSERV/ServiceFoundation\n\\t&lt;/description&gt;\n\\t&lt;name&gt;name&lt;/name&gt;\n\n\\t&lt;dependencies&gt;\n\\t\\t&lt;!-- ================================================== --&gt;\n\\t\\t&lt;!-- RBS --&gt;\n\\t\\t&lt;!-- ================================================== --&gt;\n\n\\t\\t&lt;!-- ================================================== --&gt;\n\\t\\t&lt;!-- 3rd Party --&gt;\n\\t\\t&lt;!-- ================================================== --&gt;\n\\t\\t&lt;dependency&gt;\n\\t\\t\\t&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n\\t\\t\\t&lt;artifactId&gt;commons-csv&lt;/artifactId&gt;\n\\t\\t\\t&lt;version&gt;1.4&lt;/version&gt;\n\\t\\t&lt;/dependency&gt;\n\n\\t\\t&lt;!-- ================================================== --&gt;\n\\t\\t&lt;!-- RS --&gt;\n\\t\\t&lt;!-- ================================================== --&gt;\n\\t\\t&lt;!-- Test ============================================= --&gt;\n\n\\t&lt;/dependencies&gt;\n\n&lt;/project&gt;\n&quot;&quot;&quot;\n\n    modifyAndSaveXmlFile( new File(&quot;test.xml&quot;),{ root -&gt;\n        root.version[0].value = &quot;sdafa&quot;\n    })\n\n}\n\ndef modifyXml(xml, closure){\n    def document = DOMBuilder.parse(new StringReader(xml))\n    def root = document.documentElement\n    use(DOMCategory) {\n        // manipulate the XML here, i.e. root.someElement?.each { it.value = &#39;new value&#39;}\n        closure(root)\n    }\n\n    XmlUtil.serialize(root)\n}\n\ndef modifyAndSaveXmlFile(file, closure = {it} ){\n    if(!File.isCase(file)) file = new File(file)\n\n    def result = modifyXml(file.text, closure)\n\n    file.withWriter { w -&gt; w.write(result) }\n}</pre>\n","authorId":null,"subject":"hidden","tags":null,"img":null,"summary":null,"lastUpdated":null}