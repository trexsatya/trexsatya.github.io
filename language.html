<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <script src="/jquery.js"></script>
    <script></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script type="text/javascript" src="/fabric.min.js"></script>
    <script type="text/javascript" src="/pagination.min.js"></script>
    <script type="text/javascript" src="/algo.visual.toolbox.js"></script>
    <script type="text/javascript" src="/rx.all.min.js"></script>
    <script type="text/javascript" src="/bootstrap.min.js"></script>
    <link href="/index.css" rel="stylesheet"/>
    <script type="text/javascript" src="/jquery.lettering.js"></script>
    <script type="text/javascript" src="/jquery.fittext.js"></script>
    <script type="text/javascript" src="/rulez.min.js"></script>
    <script type="text/javascript" src="/mediaelement.js"></script>
    <script type="text/javascript" src="/mediaelement-plugins/speed/speed.min.js"></script>
    <script type="text/javascript" src="/mediaelement-plugins/speed/speed-i18n.js"></script>
    <!-- <script type="text/javascript" src="/treant.js"></script> -->
    <link rel="stylesheet" href="/animate.css">
    <link rel="stylesheet" href="/treant.css">
    <script src="/vendor/raphael.js"></script>

    <!-- <script src="../../vendor/jquery.min.js"></script> -->
    <script src="../../vendor/jquery.easing.js"></script>

    <script type="text/javascript" src="/jquery.textillate.js"></script>
    <!--    <script src="/typed.min.js"></script>-->

    <script type="text/javascript" src="/diff-match-patch.js"></script>
<!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>-->
    <link href="/select2.min.css" rel="stylesheet"/>
    <link href="/pagination.css" rel="stylesheet"/>
    <link href="/bootstrap.min.css" rel="stylesheet"/>
    <link href="/bootstrap-grid.min.css" rel="stylesheet"/>

    <script src="/select2.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/velocity-animate@2.0/velocity.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/velocity-animate@2.0/velocity.ui.min.js"></script>
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_SVG">
    </script>
    <script src="/ace/src-noconflict/ace.js" type="text/javascript" charSet="utf-8"></script>
    <script src="/lodash.js"></script>
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript">
      Array.prototype.max = function () {
        return Math.max.apply(null, this);
      };
    </script>
    <style>

    </style>

    <script src="/play.js"></script>
    <!--    <script src="/play2.js"></script>-->
    <link rel="stylesheet" href="/play.css">
    <link rel="stylesheet" href="/fontawesome-all.css">

    <script>
      function togglePlay(el) {
        if (window.playingVideo) {
          if (ytPlayer.getPlayerState() === 2) {
            ytPlayer.playVideo()
          } else if (ytPlayer.getPlayerState() === 1) {
            ytPlayer.pauseVideo()
          }
        } else {
          if (player.paused) {
            player.play()
          } else {
            player.pause()
          }
        }
      }
    </script>
    <style>
      #playBtn {
        border-radius: 50%;
        height: 5em;
        width: 5em;
        cursor: pointer;
      }

      .play-btn {
        background: blue;
        color: white;
      }

      .pause-btn {
        background: red;
        color: white;
      }

      body {
        touch-action: manipulation;
      }
    </style>
    <style>
      .btn {
        cursor: pointer;
      }

      .Comment {
        border-left: 1px solid black;
        padding-left: 4px;
      }

      .btn:hover {
        background-color: cyan;
      }

      .highlight, .highlighted-selection {
        background-color: yellow;
      }

      .srt-line.selected {
        background-color: cyan;
      }

      .main-line {
        color: blue;
      }

      .secondary-line {
        color: grey;
      }

      .info {
        color: grey;
      }
    </style>
</head>

<body style="padding: 0.5em;">

<div>

    <!--    Subtitles: <input type="file" onChange="loadSubtitle(this.files[0])" title="Subtitles" accept="application/JSON">-->
    <!--    <br>-->
    <!--    <br>-->
    <!--    Audio: <input id="video-file" type="file" title="Video"/>-->

    <label for="mp3Choice">Select Media:</label>
    <select id="mp3Choice" style="width: 100%">
        <option value="">-</option>
    </select>

    <span class=""><a href="" target="_blank" id="youtube-link" style="display: none;">Search on Youtube</a></span>
    <div style="padding-top: 1em;">
        <input type="text" id="searchText" placeholder="Search text"
               onchange="fetchSRTs(this)"
        >
        <input type="number" id="numberOfFindingsToShow" placeholder="Show X items" value="2">
        <button onclick="$('#result').toggle()">Toggle Search Results</button>
        <div id="result" style="overflow: scroll; height: 300px;">
        </div>
    </div>
    <audio id="video" src="" width="700" height="500"></audio>

    <div style="width: 100%;">
        <div id="player" style="display:none; margin-top: 2em;"></div>
        <div style="min-height: 150px;float: right;">
            <div id="subtitle-container">
                <br>
                <br>
                <div id="sv-sub" style="font-weight: bold; font-size: large; color: blue"></div>
                <br>
                <br>
                <div id="en-sub" style="display: none;"></div>
                <div style="margin-top: 2em;">
                    <span class="btn btn-secondary" id="toggleEnSubBtn" onclick="$('#en-sub').toggle()"> Toggle English Subtitles </span>
                </div>
            </div>
            <div style="margin-top: 8em; width: 30%; position: absolute; bottom: 4em; right: 4em;" id="controls">

                <div class="">
                    <div>
                        <div class="controlgroup" id="speed-control">
                            <label for="speed-1">0.5</label>
                            <input type="radio" name="speedOption" id="speed-1" data-speed="0.5">
                            <label for="speed-2">0.7</label>
                            <input type="radio" name="speedOption" id="speed-2" data-speed="0.7">
                            <label for="speed-3">0.8</label>
                            <input type="radio" name="speedOption" id="speed-3" data-speed="0.8">
                            <label for="speed-4">1.0</label>
                            <input type="radio" name="speedOption" id="speed-4" checked data-speed="1.0">
                        </div>
                        <label for="speed-control">x Speed</label>
                    </div>
                    <br>
                    <div class="form-check form-switch" style="display: none;">
                        <label class="form-check-label" for="loopSwitch">Loop </label>
                        <input class="form-check-input" type="checkbox" role="switch" id="loopSwitch">
                    </div>

                </div>
                <div style="text-align: center; margin-top: 2em;">
                    <div id="pagination"></div>
                    <br>
                    <button id="rewindBtn"
                            style="font-weight: bolder;font-size: larger; margin-right: 3em;width: 3em;height: 2em;"
                            onclick="rewind()"> <
                    </button>
                    <button onclick="togglePlay(this)" id="playBtn" class="play-btn" disabled>Play</button>
                </div>
            </div>
        </div>
    </div>
</div>
<br/>
<div style="color: grey;" id="player-info">
    Current Page: <span id="currentNumber"></span> <span id="currentTime" style="padding-left: 1em;"></span> <span
        id="currentSpeed" style="padding-left: 1em;"></span>
</div>

<div id="message" style="display: none"></div>

<script>
  function toSeconds(str) {
    str = str + ""
    let splits = str.split(":")
    let hour = 0, mins = 0, secs = 0
    if (splits.length === 2) {
      mins = splits[0]
      secs = splits[1]
    }
    if (splits.length === 3) {
      hour = splits[0]
      mins = splits[1]
      secs = splits[2]
    }
    return parseInt(hour) * 3600 + parseInt(mins) * 60 + parseInt(secs)
  }

  function fromSeconds(number) {
    let _pad = x => x.length < 2 ? '0' + x : x;
    let hrs = Math.floor(number / 3600) + ''
    let mins = Math.floor((number % 3600) / 60) + ''
    let secs = Math.floor((number % 3600) % 60) + ''


    return `${_pad(hrs)}:${_pad(mins)}:${_pad(secs)}`
  }

  let URL = window.URL || window.webkitURL
  let displayMessage = function (message, isError) {
    let element = document.querySelector('#message')
    element.innerHTML = message
    element.className = isError ? 'error' : 'info'
  }

  let player = new MediaElement(document.querySelector('audio'), {
    defaultSpeed: 1.0,
    features: ['speed'],
    success: function (mediaElement, originalNode) {
      console.log('Media element', mediaElement, originalNode)
    }
  });

  window.player = player
  window.marginStartSubtitle = -0.1
  window.marginEndSubtitle = 1

  const isIOS = () => {
    const iosQuirkPresent = function () {
      const audio = new Audio();

      audio.volume = 0.5;
      return audio.volume === 1;   // volume cannot be changed from "1" on iOS 12 and below
    };

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isAppleDevice = navigator.userAgent.includes('Macintosh');
    const isTouchScreen = navigator.maxTouchPoints >= 1;   // true for iOS 13 (and hopefully beyond)

    return isIOS || (isAppleDevice && (isTouchScreen || iosQuirkPresent()));
  };

  if (isIOS()) {
    window.marginStartSubtitle = -1
    window.marginEndSubtitle = 0
  }

  window.marginStartSubtitle = 0
  window.marginEndSubtitle = 0

  function pauseVideo() {
    window.player.pause()
    $('#playBtn').html('Play')
  }

  let currentVideoTime = () => {
    return parseFloat(parseFloat(player.getCurrentTime() + '').toFixed(2))
  }
  let clearSubtitles = () => {
    $('#sv-sub').html('')
    $('#en-sub').html('')
  }

  let renderSubtitles = (currentSub) => {
    if(!currentSub) return;
    if (window.renderedSub === currentSub.number) {
      return
    }

    console.log("Rendering subtitle for ", currentSub)

    window.renderedSub = currentSub.number

    $('#currentNumber').html(currentSub.number)
    $('#currentTime').html(fromSeconds(currentVideoTime()) + ' / [' + currentSub.ts_o + '-' + currentSub.te_o + ']')
    $('#currentSpeed').html(player.getPlaybackRate() + ' / ' + currentSub.speed)

    $('#sv-sub').html('')
    currentSub.sv.replaceAll("\n", " ").split(" ").map(it => it.trim()).filter(it => it.length > 0).forEach(word => {
      let sanitizedWord = word
      if (['-', '–', '!', '.', ','].some(it => sanitizedWord.startsWith(it))) {
        sanitizedWord = sanitizedWord.substr(1)
      }

      if (['-', '–', '!', '?', '.', ','].some(it => sanitizedWord.endsWith(it))) {
        sanitizedWord = sanitizedWord.substr(0, sanitizedWord.length - 1)
      }

      let wordLink = $(`<span> <a href="https://sv.wiktionary.org/wiki/${encodeURIComponent(sanitizedWord)}" target="_blank">${word}</a></span>`);
      wordLink.click(e => {
        pauseVideo()
      })
      $('#sv-sub').append(wordLink)
    })

    $('#en-sub').html(currentSub.en)
  }

  async function seekToYoutubeTime(t) {
    console.log("Seek request, target=", fromSeconds(t), "currentTime=", fromSeconds(window.ytPlayer.getCurrentTime()))
    window.ytPlayer.seekTo(t)
    window.seekRequestProcessing = true
    let leeway = Math.max(6, Math.abs(window.ytPlayer.getDuration() - t))
    window.ytPlayer.seekTo(t-4)

    return new Promise((resolve, reject) => {
      let interval = null
      interval = setInterval(() => {
        let delta = 0
        if (Math.abs(window.ytPlayer.getCurrentTime() - t) < leeway) {
          clearInterval(interval)
          console.log("Seek request completed", fromSeconds(t), "currentTime=", fromSeconds(window.ytPlayer.getCurrentTime()))
          window.ytPlayer.seekTo(t)
          resolve()
          window.seekRequestProcessing = false
          window.proxyYoutubeCurrentTime = t
        } else {
          window.ytPlayer.seekTo(t - delta)
          delta += 1
        }
      }, 10)
    })
  }

  let prepareSubsForPage = async (pageNumber, setTime, manualHandling) => {
    pageNumber = parseInt(pageNumber)

    pageNumber = window.pageDataSource[pageNumber - 1]
    let allSubs = window.subtitles

    //Reset
    let subs = [allSubs.find(it => it.id + "" === pageNumber + "")].flatMap(sub => [
      // {...sub, speed: 0.6}
      // , {...sub, speed: 0.8}
      {...sub, speed: 1.0}
    ])

    let currentSub = subs.shift()
    console.log("Preparing subs for page", pageNumber, currentSub)

    if (setTime) {
      let newTime = Math.max(currentSub.ts + window.marginStartSubtitle, 0);
      if (window.playingVideo) {
        await seekToYoutubeTime(newTime - (manualHandling ? 2 : 0))
        if (manualHandling) {
          ytPlayer.seekTo(newTime)
        }
        // ytPlayer.playVideo(newTime)
      } else {
        player.setCurrentTime(newTime)
      }
    }

    // if(!window.rewindData)
    // player.setPlaybackRate(currentSub.speed)

    // player.play()

    window.subs = subs
    window.currentSub = currentSub
    window.pageNumber = pageNumber

    if(manualHandling) {
      renderSubtitles(currentSub)
    }

    // $('#playBtn').html('Pause')
  }

  let $mp3Choice = $('#mp3Choice');

  function fixSectionBox() {
    $mp3Choice.select2();

    let optgroupState = {};

    $("body").on('click', '.select2-container--open .select2-results__group', function () {
      $(this).siblings().toggle();
      let id = $(this).closest('.select2-results__options').attr('id');
      let index = $('.select2-results__group').index(this);
      optgroupState[id][index] = !optgroupState[id][index];
    })

    $mp3Choice.on('select2:open', function () {
      $('.select2-dropdown--below').css('opacity', 0);
      setTimeout(() => {
        let groups = $('.select2-container--open .select2-results__group');
        let id = $('.select2-results__options').attr('id');
        if (!optgroupState[id]) {
          optgroupState[id] = {};
        }
        $.each(groups, (index, v) => {
          optgroupState[id][index] = optgroupState[id][index] || false;
          optgroupState[id][index] ? $(v).siblings().show() : $(v).siblings().hide();
        })
        $('.select2-dropdown--below').css('opacity', 1);
      }, 0);
    })
  }

  $(document).ready(function () {
    fixSectionBox()
  });

  async function fetchCategorisation() {
    let categorisation = await fetch("https://raw.githubusercontent.com/trexsatya/trexsatya.github.io/gh-pages/db/srts/categorisation.txt")
    categorisation = await categorisation.text()
    categorisation = categorisation.split("\n")
    let categories = {}
    categorisation.forEach(it => {
      let l = it.split(" || ")
      let c = '        '
      if (l.length === 4) {
        c = l[0]
      }
      categories[l[l.length - 1]] = c
    })
    return categories
  }

  function populateAllLinks() {
    let $mp3Choice = $('#mp3Choice');
    $mp3Choice.html('').append($(`<option>-</option>`).attr('value', ''))
    let srts = window.srts
    let srtLinks = Array.from(new Set(window.srts.map(it => it.link)));

    let categories = window.categories
    srtLinks = _(srtLinks).chain()
      .sortBy(link => getCategory({link}))
      // .sortBy(function(link) {
      //     let srt = srts.find(it => it.link === link)
      //     return srt.name.split(" || ")[0];
      // })
      .reverse()
      .value()

    let ogs = {}
    let getOptgroup = category => {
      if (!ogs[category]) {
        let label = category
        let filter = it => it === category

        if (category === 'Okategoriserad') {
          filter = it => it.trim().length === 0
        }

        let cnt = Object.values(window.categories).filter(filter).length
        label += " (" + cnt + ")"
        ogs[category] = $(`<optgroup label="${label}">`)
      }
      return ogs[category]
    }
    srtLinks.forEach(link => {
      let item = srts.find(it => it.link === link)
      let $opt = $(`<option>${item.name.replace(".en.srt", "").replace(".sv.srt", "")}</option>`).attr('value', item.link)
      getOptgroup(getCategory(item)).append($opt)
    })

    Object.values(ogs).forEach(it => $mp3Choice.append(it))
    return srts;
  }

  async function loadAllSubtitles() {
    let srts = await fetch("https://raw.githubusercontent.com/trexsatya/trexsatya.github.io/gh-pages/db/srts/index.json")
    srts = await srts.json()
    window.srts = srts

    srts.forEach(it => getSubtitlesForLink(it['link']))

    window.categories = await fetchCategorisation()

    populateAllLinks();
  }

  loadAllSubtitles()

  function srtToJson(text, lang) {
    if (!lang) lang = 'text'
    let items = []
    let currentItem = {}
    currentItem[lang] = ''
    text.split("\n").forEach(line => {
      line = line.trim()
      let matchTime = line.match(/(\d\d:\d\d:\d\d[,.]\d\d\d) --> (\d\d:\d\d:\d\d[,.]\d\d\d)/m)
      let matchId = line.match(/^\d+$/m)
      if (matchId) {
        items.push(currentItem)
        currentItem = {index: line, id: line}
        currentItem[lang] = ''
      } else if (matchTime) {
        currentItem['start'] = { ordinal: toSeconds(matchTime[1]) }
        currentItem['end'] = { ordinal: toSeconds(matchTime[2]) }
        currentItem['ts'] = matchTime[1]
        currentItem['te'] = matchTime[2]
      } else {
        currentItem[lang] += (line + "\n")
      }
    })

    items.push(currentItem)
    return items.filter(it => it.start && it.start.ordinal)
  }

  function getCategory(item) {
    let link = item.link;
    let category = window.categories[link];
    category = category && category.trim()
    return category || 'Okategoriserad';
  }

  function searchText() {
    let searchText = $("#searchInput").val().trim()

    if (searchText.length < 3) {
      populateAllLinks()
      return
    }

    function getSrtObject(it) {
      return window.srts.find(srt => srt.link === it);
    }

    let items = Object.keys(window.allSubtitles).map(it => {
      let s = window.allSubtitles[it]
      let svMatch = s.sv.toLowerCase().indexOf(searchText) >= 0
      let enMatch = s.en.toLowerCase().indexOf(searchText) >= 0
      return {link: it, svMatch, enMatch}
    })
      .map(it => {
        let srt = getSrtObject(it.link)
        return {...it, ...srt}
      }).filter(it => it.svMatch || it.enMatch)

    let $mp3Choice = $('#mp3Choice')
    $mp3Choice.html('<option>--</option>')

    let ogs = {}
    let getOptgroup = category => {
      if (!ogs[category]) {
        ogs[category] = $(`<optgroup label="${category}">`)
      }
      return ogs[category]
    }

    items.map(item => {
      let subs = window.allSubtitles[item.link]
      let text = ''
      if (item.svMatch) {
        text = subs['sv']
      } else {
        text = subs['en']
      }

      let count = (text.toLowerCase().match(new RegExp(searchText, "gi")) || []).length;
      return ({...item, matches: count})
    }).toSorted((x, y) => y.matches - x.matches)
      .forEach(item => {
        let $opt = $(`<option>(${item.matches}) ${item.name.replace(".en.srt", "").replace(".sv.srt", "")}</option>`).attr('value', item.link)
        getOptgroup(getCategory(item)).append($opt)
      })

    Object.values(ogs).forEach(it => $mp3Choice.append(it))
  }

  function storeSubtitles(subs) {
    let strategy = "Normal-Slow"

    let originalSubs = subs.map(it => ({...it}))

    originalSubs.forEach(it => {
      it['ts_o'] = it['ts']
      it['ts'] = toSeconds(it['ts'])
    })

    originalSubs = _.sortBy(originalSubs, it => it.ts)

    for (let i = 0; i < originalSubs.length - 1; i++) {
      originalSubs[i]['te_o'] = originalSubs[i + 1]['ts_o']
      originalSubs[i]['te'] = originalSubs[i + 1]['ts'] - 0.009
      originalSubs[i]['number'] = i + 1
    }
    window.subtitles = originalSubs
    return originalSubs;
  }

  window.allSubtitles = {}
  window.srts = []

  async function getSubtitlesForLink(link) {
    if (window.allSubtitles[link]) {
      return window.allSubtitles[link]
    }
    let svName = window.srts.find(it => it.link === link).name + ".sv.srt"
    let enName = window.srts.find(it => it.link === link).name + ".en.srt"
    let sv = await fetch("https://raw.githubusercontent.com/trexsatya/trexsatya.github.io/gh-pages/db/srts/" + svName)
    sv = await sv.text()
    let en = await fetch("https://raw.githubusercontent.com/trexsatya/trexsatya.github.io/gh-pages/db/srts/" + enName)
    en = await en.text()

    window.allSubtitles[link] = {sv, en}
    return window.allSubtitles[link]
  }

  async function loadSubtitlesForLink(link) {
    let {sv, en} = await getSubtitlesForLink(link)

    if (!sv) {
      alert("SV subtitle not found")
      return
    }

    if (!en) {
      en = {...sv}
    }

    window.srtLoaded = sv
    sv = srtToJson(sv, 'sv')

    en = srtToJson(en, 'en')
    let combined = sv.map(svItem => {
      let enItem = en.find(eni => eni.ts === svItem.ts)
      let combinedItem = {...svItem, ...enItem};
      combinedItem['id'] = svItem.id //Give priority to SV subtitle
      return combinedItem
    })
    // console.log(sv)
    // console.log(en)
    console.log(combined)

    storeSubtitles(combined)

    player.setSrc(link)

    playSelectedFile()
  }

  function playNewVideo(link) {
    clearSubtitles()
    stopVideo()
    //Load subtitle
    let youtubeVideoId = link
    if (youtubeVideoId.trim().length) {
      $('#player').show()
      loadVideo(youtubeVideoId)
      window.playingVideo = true;
      $('#youtube-link').hide()
      loadSubtitlesForLink(link);
    } else {
      $('#player').hide()
      window.playingVideo = false;
      loadSubtitlesForLink(link);
    }
  }

  function waitUntil(condition) {
    return new Promise((resolve, reject) => {
      let interval = setInterval(() => {
        if (condition()) {
          clearInterval(interval)
          resolve()
        }
      }, 100)
    })
  }

  window.onload = e => {
    let link = window.location.hash.replace("#", "")
    if (link.length > 2) {
      waitUntil(() => window.ytPlayerReady)
        .then(() => {
          console.log("Playing video", link)
          $mp3Choice.val(link).trigger('change')
        })
    }
  }

  $mp3Choice.change(async e => {
    let link = $mp3Choice.val();
    if(link) {
      window.location.hash = link
      playNewVideo(link)
    }
  })

  function setSpeed() {
    let newRate = $('.controlgroup input:checked').data('speed');
    if (playingVideo) {
      ytPlayer.setPlaybackRate(newRate)
    } else {
      player.setPlaybackRate(newRate)
    }
  }

  function goToCurrentPageNumber(manualHandling) {
    // console.log('Go to current page', new Date())
    let pageNum = $('#pagination').pagination('getCurrentPageNum')
    window.rewindData = null
    prepareSubsForPage(pageNum, true, manualHandling)
  }

  let playSelectedFile = function (pages) {
    let $pagination = $('#pagination');
    try {
      $pagination.pagination('destroy');
    } catch (e) {
      console.log(e)
    }

    let pageDataSource = pages || range(1, window.subtitles.length + 1);
    window.pageDataSource = pageDataSource
    $pagination.pagination({
      dataSource: pageDataSource,
      pageSize: 1,
      // showPrevious: false,
      // showNext: false,
      showGoInput: true,
      showGoButton: true,
      formatGoInput: 'go to <%= input %> st/rd/th',
      callback: function (data, pagination) {
        // console.log("Page changed", data)
      }, //page changed
      afterPageOnClick: e => {
        // console.log(e)
        goToCurrentPageNumber(true);
      },
      afterNextOnClick: e => {
        goToCurrentPageNumber(true);
      },
      afterPreviousOnClick: e => {
        goToCurrentPageNumber(true);
      }
    })

    $('#playBtn').attr('disabled', false)
    prepareSubsForPage(1, true)
    goToCurrentPageNumber()
    // console.log(originalSubs.map(it => `${it.number} ${it.ts_o}-${it.te_o} (${it.ts}-${it.te} )-> ${it.sv}`).join("\n"))
  }

  function updatePlayPauseButton() {
    if (ytPlayer.getPlayerState() === 2) {
      $('#playBtn').html('Play')
    } else if (ytPlayer.getPlayerState() === 1) {
      $('#playBtn').html('Pause')
    }
  }

  function getCurrentTime() {
    return ytPlayer.getCurrentTime()
  }
  const ontimeupdate = e => {
    if(ytPlayer.getPlayerState() !== 1) {
      return
    }
    // console.log(currentSub, player.currentTime)


    if (window.seekRequestProcessing) {
      return
    }

    updatePlayPauseButton()

    let ct = player.getCurrentTime()
    if (window.playingVideo) {
      ct = getCurrentTime()
    }

    if (window.rewindData) {
      if (ct >= window.rewindData.from) {
        window.rewindData = null
        console.log("Resetting speed", ct)
        player.setPlaybackRate(window.currentSub.speed)
      } else {
        // return
      }
    }

    if(window.youtubePlayInterval) {
      let s = window.youtubePlayInterval.start
      let e = window.youtubePlayInterval.end
      if(ct > e) {
        ytPlayer.pauseVideo()
        window.youtubePlayInterval = null
      }
    }

    renderSubtitles(window.currentSub)
    setSpeed();

    if (!window.rewindData && window.currentSub && ct >= window.currentSub.te) {
      // Go to next subtitle
      // player.pause()
      $('#pagination').pagination('next', data => {
        console.log('Ontimeupdate: Going to next page', new Date(), "Current Time ", ct, "Data", data)
        prepareSubsForPage(window.pageDataSource.findIndex(it => it + "" === data + "") + 1, true)
      })
    }
  }

  function updatePlayBtn() {
    let el = $('#playBtn')[0]

    if (player.paused) {
      $(el).html("Play").removeClass('pause-btn').addClass('play-btn')
    } else {
      $(el).html("Pause").removeClass('play-btn').addClass('pause-btn')
    }
  }

  player.addEventListener('timeupdate', ontimeupdate)
  player.addEventListener('pause', updatePlayBtn)
  player.addEventListener('ended', updatePlayBtn)
  player.addEventListener('playing', updatePlayBtn)

  player.addEventListener('ended', e => {
    $('#pagination').pagination('go', 1)
    goToCurrentPageNumber()
    if ($('#loopSwitch').is(":checked")) {
      console.log('Replaying')
      sleep(2).then(() => $('#playBtn').click())
    }
  })

  let inputNode = document.querySelector('#video-file')
  if (inputNode)
    inputNode.addEventListener('change', playSelectedFile, false)

  function rewind() {
    window.rewindData = window.rewindData || {
      from: window.playingVideo ? ytPlayer.getCurrentTime() : player.getCurrentTime(),
    }

    console.log("Should come back to", window.rewindData.from)
    player.setPlaybackRate($('.controlgroup input:checked').data('speed'))

    if (window.playingVideo) {
      ytPlayer.seekTo(ytPlayer.getCurrentTime() - 3)
    } else {
      player.setCurrentTime(player.currentTime - 3)
    }
  }

  $('.controlgroup').controlgroup()

  document.onkeyup = e => {
    if (e.which === 32) { //Space
      togglePlay()
    }
  }
</script>

<script>
  function chunkifySentence(text, max_chars) {
    let words = text.split(" ")
    let res = []
    let current = ""
    let sentences = splitSentences(text).filter(it => it.type === 'Sentence')
    for (let i = 0; i < sentences.length; i++) {
      let w = sentences[i].raw
      if (current.length + w.length >= max_chars) {
        res.push(current)
        current = w + " "
      } else {
        current += (w + " ")
      }
    }
    res.push(current)
    return res
  }

  function getTimes(el, fl) {
    let lines = $(el).find(".line").map((i, e) => $(e).data()).toArray()
      .map(it => it.index).map(idx => fl.data.find(it => it.index +'' === idx +''))

    return {
      start: lines[0].start.ordinal, end: lines[lines.length - 1].end.ordinal
    }
  }

  function highlightedText(text) {
    text = _.trim(text, "-:_")
    let hText = text
    try {
      let match = text.match(new RegExp(window.searchText, "i"))
      let index = match.index
      hText = text.substring(0, index) + "<span class='highlight'>" + text.substring(index, index + match[0].length) + "</span>" + text.substring(index + match[0].length);
    } catch (e) {
      // console.log(e)
    }
    return hText;
  }

  function playSelectedText(e) {
    let selTxt = getSelectionText() || ''

    function playChunk(_txt) {
      return new Promise(function (resolve, reject) {
        let a = new Audio()
        a.src = "http://localhost:5000/tts-proxy?q=" + _txt
        a.preload = "auto";
        a.onerror = reject;                      // on error, reject
        a.onended = resolve;                     // when done, resolve
        a.playbackRate = 1.2
        a.play()
      });
    }

    let play = () => {
      let txt = selTxt.length > 1 ? selTxt : $(e.target).parent().data('text')

      let chunks = chunkifySentence(txt)

      let first = chunks.shift()
      let promise = playChunk(first)

      promise.then(x => restoreBgMusic())
    }
    // dampenBgMusic().promise.then(x => play())
    play()
  }

  function numberOfItemsToShow() {
    let n = parseInt(numberOfFindingsToShow.value);
    if (n === -1) {
      return 1000
    }
    return n
  }

  function getWords(text, searchText) {
    const segmentor = new Intl.Segmenter([], {granularity: 'word'});
    const segmentedText = segmentor.segment(text);
    let words = Array.from(segmentedText, ({segment}) => segment).filter(it => it.trim().length > 1);
    words.push(searchText)
    return words;
  }

  function getMatchingWords(list, search, functionToGetLine) {
    let wordToItemsMap = {}
    list.forEach(item => {
      let matches = functionToGetLine(item).map(it => getWords(it.text, search))
        .flat().map(it => it.trim().toLowerCase())
        .filter(it => it.match(new RegExp(search.toLowerCase(), "i")))

      _.uniq(matches).forEach(match => {
        if (!wordToItemsMap[match]) {
          wordToItemsMap[match] = []
        }
        wordToItemsMap[match].push(item)
      })
    })
    return wordToItemsMap;
  }

  function populateNonSRTFindings(wordToItemsMap, $result) {
    Object.keys(wordToItemsMap).toSorted().forEach(word => {
      let items = wordToItemsMap[word]
      let wordBlock = $(`<div><h5 class="accordion">${word}</h5></div>`)

      _.take(items, numberOfItemsToShow()).forEach(item => {
        let parts = item.file.split("/")
        let fileName = parts[parts.length - 1]
        let $line = $(`<div class="normal-line" title="${fileName}"></div>`)

        chunkifySentence(item.text, 190).forEach(chunk => {
          let div = $(`
    <div class="line-part"> ${highlightedText(chunk)} <img src="/img/icons/play_icon.png"
        alt="" style="width: 20px;height: 20px;cursor: pointer;" class="play-btn">
    </div>`);
          div.data({text: chunk})
          $line.append(div)
        })
        wordBlock.append($line).append('<br>')
      })
      $result.append(wordBlock)
    })
  }

  function getMainSubAndSecondarySub(file, line) {
    let mainSub, secondarySub = {};
    if (file.path.endsWith(".sv.srt")) {
      mainSub = line;
      mainSub.text = highlightedText(mainSub.text)
      let found = window.searchResult.find(it => it['en_subs'] && it['en_subs'].path === file.path.replaceAll(".sv.srt", ".en.srt"));
      if (found) secondarySub = found.en_subs.data.find(it => it.index === line.index)
    } else {
      mainSub = window.searchResult.find(it => it['sv_subs'] && it['sv_subs'].path === file.path.replaceAll(".en.srt", ".sv.srt"))
        .sv_subs.data.find(it => it.index === line.index)
      secondarySub = line;
      secondarySub.text = highlightedText(secondarySub.text)
    }

    if (!secondarySub) secondarySub = {text: ""}
    if (!mainSub) mainSub = {text: ""}
    return {mainSub, secondarySub};
  }

  function htmlForSrtLine(_line, file, url) {
    let line = {..._line}

    let {mainSub, secondarySub} = getMainSubAndSecondarySub(file, line);



    return $(`<div class="srt-line" data-index="${line.index}" data-file="${file.path}">
                                    <span class="add-prev-btn btn"> + </span>
                                    <span class="remove-next-btn btn"> - </span>
                                    <span class="line main-line" data-index="${line.index}"> ${mainSub.text} </span>
                                    <span class="remove-prev-btn btn"> - </span>
                                    <span class="add-next-btn btn"> + </span>
                                    <span class="play-btn-container">
                                        <span class="info times"> ${fromSeconds(line.start.ordinal)}-${fromSeconds(line.end.ordinal)} </span>
                                        <img src="/img/icons/play_icon.png" alt="" style="width: 20px;height: 20px;cursor: pointer;background-color: inherit;" class="play-btn" data-url="${url}">
                                    </span>
                                    <br>
                                 </div>
                                 <div class="line secondary-line" data-index="${line.index}"> ${secondarySub.text} </div>
                                 <br>`).data({line: line, file: file})
  }

  function populateSRTFindings(wordToItemsMap, $result) {
    Object.keys(wordToItemsMap).toSorted().forEach(word => {
      let items = wordToItemsMap[word]
      let wordBlock = $(`<div ><h5 class="accordion">${word}</h5></div>`)

      let getSubs = it => it['en_match'] ? it['en_subs'] : it['sv_subs']

      _.take(items, numberOfItemsToShow()).filter(getSubs)
        .toSorted((x, y) => getSubs(x).path === window.preferredFile ? -1 : 1)
        .forEach(item => {
          let file = getSubs(item)
          let parts = file.path.split("/")
          let fileName = parts[parts.length - 1]
          let $file = $(`<div class="srt-file" title="${fileName}">
                            <h4 data-file="${file.path}" style="display: none;"> ${word} </h4>
                        </div>`)
          let matchingLines = file.data.filter(it => it.text.toLowerCase().match(word))

          _.take(matchingLines, numberOfItemsToShow()).forEach(line => {
            $file.append(htmlForSrtLine(line, file, item.sv_subs.url, items));
          })

          wordBlock.append($file)
        })
      $result.append(wordBlock)
    })
  }

  window.youtubePlayInterval = null

  function render(list, search) {
    let $result = $('#result');
    $result.html('')

    $result.append('<br><br>')

    let wordToItemsMap = getMatchingWords(list.filter(it => it.sv_subs), search, item => item.sv_subs.data);
    populateSRTFindings(wordToItemsMap, $result);

    $result.append("<hr>")

    wordToItemsMap = getMatchingWords(list.filter(it => it.text), search, item => [item]);
    populateNonSRTFindings(wordToItemsMap, $result);

    renderAccordions()

    $(".srt-file h4").dblclick(e => {
      window.preferredFile = $(e.target).data().file
    })

    $('.add-prev-btn').click(e => {
      let plusBtn = $(e.target);
      let dt = plusBtn.parent().data()

      let lines = plusBtn.parent().find(".line").toArray()
      let firstLine = $(lines[0])

      let nextLine = firstLine.data('index')
      if (nextLine < 2) return

      let newLn = dt.file.data[nextLine - 2]
      let $newLine = $(`<span class="line" data-index="${newLn.index}"> ${newLn.text}</span>`);
      $newLine.insertBefore(firstLine)
    })
    $('.add-next-btn').click(e => {
      let plusBtn = $(e.target);
      let dt = plusBtn.parent().data()
      let lines = plusBtn.parent().find(".line").toArray()
      let lastLine = $(lines[lines.length - 1])

      let prevLine = lastLine.data('index')
      if (prevLine === dt.file.data.length) return

      let newLn = dt.file.data[prevLine]
      let $newLine = $(`<span class="line" data-index="${newLn.index}"> ${newLn.text}</span>`);
      $newLine.insertAfter(lastLine)
    })

    $('.remove-prev-btn').click(e => {
      let btn = $(e.target);
      let dt = btn.parent().data()
      let prevLine = btn.prev('.line')
      if (prevLine.hasClass("main-line")) return

      prevLine.remove()
    })

    $('.remove-next-btn').click(e => {
      let btn = $(e.target);
      let dt = btn.parent().data()
      let nextLine = btn.next('.line')
      if (nextLine.hasClass("main-line")) return

      nextLine.remove()
    })

    $(".srt-line .play-btn").click(e => {
      if ($(e.target).hasClass('disabled')) return

      $('.srt-line').removeClass('selected')
      $(e.target).parents('.srt-line').addClass('selected')

      let url = $(e.target).data("url")
      let dt = $(e.target).parents('.srt-line').data()

      let times = getTimes($(e.target).parents('.srt-line'), dt.file)

      let btn = $(e.target)
      // $(btn).addClass('disabled')

      let play = () => {
        loadVideo(url)
        window.youtubePlayInterval = {...times}
        console.log(`Playing from ${fromSeconds(times.start)} to ${fromSeconds(times.end)}`)
        $('#player').show()
      }

      // dampenBgMusic().promise.then(x => play())
      play()
      // $( "#audioPlayerPopup" ).dialog('open')
      // $('#audioPlayerPopup').css({width: '100%'})
    })

    $(".normal-line .play-btn").click(e => {
      playSelectedText(e);
    })
  } // end render

  function getSubs(text, file, url) {
    return {data: srtToJson(text), path: file, url: url}
  }
  function fetchFromLocal() {
    return Object.keys(window.allSubtitles).map(it => {
      let svMatch = window.allSubtitles[it].sv.match(new RegExp(window.searchText));
      let enMatch = window.allSubtitles[it].en.match(new RegExp(window.searchText));
      if (svMatch || enMatch) {
        let v = {en_subs: getSubs(window.allSubtitles[it].en, it + ".en.srt", it), sv_subs: getSubs(window.allSubtitles[it].sv, it + ".sv.srt", it)}
        if (svMatch) v.sv_match = true;
        else v.en_match = true;
        return v;
      }
    }).filter(it => it);
  }

  async function fetchSRTs(searchText) {
    if ((typeof searchText) !== 'string') {
      searchText = null
    }
    let $searchText = $("#searchText");
    let txt = searchText || $searchText.val().toLowerCase()
    $searchText.val(txt)

    if(txt.length < 3) return

    window.searchText = txt;

    if(Object.keys(window.allSubtitles).length) {
      console.log("Loading from local")
      window.searchResult = fetchFromLocal()
    } else {
      let res = await fetch("http://localhost:5000/find?text=" + txt)
      window.searchResult = await res.json();
    }
    render(window.searchResult, window.searchText)
  }

  $('#numberOfFindingsToShow')[0].onchange = e => {
    render(window.searchResult, window.searchText)
  }

  function renderAccordions() {
    console.log('Rendering accordions')

    let isAccordion = it => Array.from(it.classList.values()).indexOf('accordion') >= 0

    function fixAccordionPanel(accordionEl) {
      let el = accordionEl.nextElementSibling
      let siblings = []
      while (el) {
        if (isAccordion(el)) break

        siblings.push(el)
        el = el.nextElementSibling
      }

      if (siblings.length > 1) {
        let newEl = document.createElement('div')
        newEl.classList.add('autocreated-panel')
        siblings.forEach(it => newEl.appendChild(it))

        accordionEl.insertAdjacentElement('afterend', newEl)
      }
    }

    let acc = document.getElementsByClassName("accordion");
    let i;

    for (i = 0; i < acc.length; i++) {
      acc[i].classList.add(i % 2 === 0 ? 'even' : 'odd')

      if (acc[i].dataset.accordion_rendered === "true") continue;

      fixAccordionPanel(acc[i])
      acc[i].addEventListener("click", function () {
        /* Toggle between adding and removing the "active" class,
        to highlight the button that controls the panel */
        this.classList.toggle("active");

        /* Toggle between hiding and showing the active panel */
        let panel = this.nextElementSibling;
        if (panel.style.display === "block") {
          panel.style.display = "none";
        } else {
          panel.style.display = "block";
        }
      });
    }
  }
</script>
<script>
  // 2. This code loads the IFrame Player API code asynchronously.
  var tag = document.createElement('script');

  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  // 3. This function creates an <iframe> (and YouTube player)
  //    after the API code downloads.

  function loadVideo(videoId) {
    let iframe = ytPlayer.getIframe()
    try {
      let currentVideoId = iframe.src.split("embed/")[1].split("?")[0]
      iframe.src = `${iframe.src}`.replaceAll(currentVideoId, videoId)
    } catch (e) {
      console.log(e)
    }
  }

  let wh = $(window).height(), ww = $(window).width();

  let ytVideoWidth = 940, ytHeight = 590;
  let subWidth = 0;

  if (ww >= 1000) {
    ytVideoWidth = ww * 0.6;
    subWidth = $(window).width() - (ytVideoWidth + 40)
  } else {
    ytVideoWidth = ww - 10;
    subWidth = ww - 10;
    ytHeight = wh / 2 - 50;
    $('#controls').css({width: '100%', bottom: '-15em', right: 0})
    $('#player-info').hide()
    $('#speed-control').parent().hide()

    $('#mp3Choice').parent().css({width: ww - 20})
  }

  function onYouTubeIframeAPIReady() {
    window.ytPlayer = new YT.Player('player', {
      height: ytHeight,
      width: ytVideoWidth,
      videoId: 'K8P_USOppfs',
      playerVars: {
        'playsinline': 1
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
    $('#subtitle-container').css({
      left: ytVideoWidth,
      marginLeft: '1em',
      width: subWidth
    })
  }

  // 4. The API will call this function when the video player is ready.
  function onPlayerReady(event) {
    event.target.playVideo();
    window.ytPlayerReady = true

    if(window.youtubePlayInterval) {
      seekToYoutubeTime(window.youtubePlayInterval.start)
    }
  }


  function onPlayerStateChange(event) {
    if(event.data === YT.PlayerState.PLAYING) {
      window.ytPlaying = true
    } else {
      window.ytPlaying = false;
    }
  }

  function stopVideo() {
    window.ytPlayer.stopVideo();
  }

  setInterval(() => {
    //Check time
    if (window.playingVideo && window.ytPlayer) {
      ontimeupdate()
    }
  }, 100)
</script>
</body>

</html>
